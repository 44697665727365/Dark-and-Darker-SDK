#include "pch.h"
#include "SDK.h"

bool AActor::WasRecentlyRendered(float Tolerance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.WasRecentlyRendered");

	FWasRecentlyRendered parms{};	
	parms.Tolerance = Tolerance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void AActor::UserConstructionScript(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.UserConstructionScript");

	FUserConstructionScript parms{};	

	ProcessEvent(fn, &parms);
}

void AActor::TearOff(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.TearOff");

	FTearOff parms{};	

	ProcessEvent(fn, &parms);
}

void AActor::SetTickGroup(enum class ETickingGroup NewTickGroup){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.SetTickGroup");

	FSetTickGroup parms{};	
	parms.NewTickGroup = NewTickGroup;

	ProcessEvent(fn, &parms);
}

void AActor::SetTickableWhenPaused(bool bTickableWhenPaused){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.SetTickableWhenPaused");

	FSetTickableWhenPaused parms{};	
	parms.bTickableWhenPaused = bTickableWhenPaused;

	ProcessEvent(fn, &parms);
}

void AActor::SetReplicates(bool bInReplicates){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.SetReplicates");

	FSetReplicates parms{};	
	parms.bInReplicates = bInReplicates;

	ProcessEvent(fn, &parms);
}

void AActor::SetReplicateMovement(bool bInReplicateMovement){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.SetReplicateMovement");

	FSetReplicateMovement parms{};	
	parms.bInReplicateMovement = bInReplicateMovement;

	ProcessEvent(fn, &parms);
}

void AActor::SetRayTracingGroupId(int32_t InRaytracingGroupId){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.SetRayTracingGroupId");

	FSetRayTracingGroupId parms{};	
	parms.InRaytracingGroupId = InRaytracingGroupId;

	ProcessEvent(fn, &parms);
}

void AActor::SetOwner(struct AActor* NewOwner){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.SetOwner");

	FSetOwner parms{};	
	parms.NewOwner = NewOwner;

	ProcessEvent(fn, &parms);
}

void AActor::SetNetDormancy(enum class ENetDormancy NewDormancy){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.SetNetDormancy");

	FSetNetDormancy parms{};	
	parms.NewDormancy = NewDormancy;

	ProcessEvent(fn, &parms);
}

void AActor::SetLifeSpan(float InLifespan){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.SetLifeSpan");

	FSetLifeSpan parms{};	
	parms.InLifespan = InLifespan;

	ProcessEvent(fn, &parms);
}

void AActor::SetAutoDestroyWhenFinished(bool bVal){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.SetAutoDestroyWhenFinished");

	FSetAutoDestroyWhenFinished parms{};	
	parms.bVal = bVal;

	ProcessEvent(fn, &parms);
}

void AActor::SetActorTickInterval(float TickInterval){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.SetActorTickInterval");

	FSetActorTickInterval parms{};	
	parms.TickInterval = TickInterval;

	ProcessEvent(fn, &parms);
}

void AActor::SetActorTickEnabled(bool bEnabled){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.SetActorTickEnabled");

	FSetActorTickEnabled parms{};	
	parms.bEnabled = bEnabled;

	ProcessEvent(fn, &parms);
}

void AActor::SetActorScale3D(struct FVector NewScale3D){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.SetActorScale3D");

	FSetActorScale3D parms{};	
	parms.NewScale3D = NewScale3D;

	ProcessEvent(fn, &parms);
}

void AActor::SetActorRelativeScale3D(struct FVector NewRelativeScale){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.SetActorRelativeScale3D");

	FSetActorRelativeScale3D parms{};	
	parms.NewRelativeScale = NewRelativeScale;

	ProcessEvent(fn, &parms);
}

void AActor::SetActorHiddenInGame(bool bNewHidden){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.SetActorHiddenInGame");

	FSetActorHiddenInGame parms{};	
	parms.bNewHidden = bNewHidden;

	ProcessEvent(fn, &parms);
}

void AActor::SetActorEnableCollision(bool bNewActorEnableCollision){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.SetActorEnableCollision");

	FSetActorEnableCollision parms{};	
	parms.bNewActorEnableCollision = bNewActorEnableCollision;

	ProcessEvent(fn, &parms);
}

void AActor::RemoveTickPrerequisiteComponent(struct UActorComponent* PrerequisiteComponent){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.RemoveTickPrerequisiteComponent");

	FRemoveTickPrerequisiteComponent parms{};	
	parms.PrerequisiteComponent = PrerequisiteComponent;

	ProcessEvent(fn, &parms);
}

void AActor::RemoveTickPrerequisiteActor(struct AActor* PrerequisiteActor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.RemoveTickPrerequisiteActor");

	FRemoveTickPrerequisiteActor parms{};	
	parms.PrerequisiteActor = PrerequisiteActor;

	ProcessEvent(fn, &parms);
}

void AActor::ReceiveTick(float DeltaSeconds){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveTick");

	FReceiveTick parms{};	
	parms.DeltaSeconds = DeltaSeconds;

	ProcessEvent(fn, &parms);
}

void AActor::ReceiveRadialDamage(float DamageReceived, struct UDamageType* DamageType, struct FVector Origin, struct FHitResult& HitInfo, struct AController* InstigatedBy, struct AActor* DamageCauser){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveRadialDamage");

	FReceiveRadialDamage parms{};	
	parms.DamageReceived = DamageReceived;
	parms.DamageType = DamageType;
	parms.Origin = Origin;
	parms.HitInfo = HitInfo;
	parms.InstigatedBy = InstigatedBy;
	parms.DamageCauser = DamageCauser;

	ProcessEvent(fn, &parms);
}

void AActor::ReceivePointDamage(float Damage, struct UDamageType* DamageType, struct FVector HitLocation, struct FVector HitNormal, struct UPrimitiveComponent* HitComponent, struct FName BoneName, struct FVector ShotFromDirection, struct AController* InstigatedBy, struct AActor* DamageCauser, struct FHitResult& HitInfo){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.ReceivePointDamage");

	FReceivePointDamage parms{};	
	parms.Damage = Damage;
	parms.DamageType = DamageType;
	parms.HitLocation = HitLocation;
	parms.HitNormal = HitNormal;
	parms.HitComponent = HitComponent;
	parms.BoneName = BoneName;
	parms.ShotFromDirection = ShotFromDirection;
	parms.InstigatedBy = InstigatedBy;
	parms.DamageCauser = DamageCauser;
	parms.HitInfo = HitInfo;

	ProcessEvent(fn, &parms);
}

void AActor::ReceiveHit(struct UPrimitiveComponent* MyComp, struct AActor* Other, struct UPrimitiveComponent* OtherComp, bool bSelfMoved, struct FVector HitLocation, struct FVector HitNormal, struct FVector NormalImpulse, struct FHitResult& Hit){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveHit");

	FReceiveHit parms{};	
	parms.MyComp = MyComp;
	parms.Other = Other;
	parms.OtherComp = OtherComp;
	parms.bSelfMoved = bSelfMoved;
	parms.HitLocation = HitLocation;
	parms.HitNormal = HitNormal;
	parms.NormalImpulse = NormalImpulse;
	parms.Hit = Hit;

	ProcessEvent(fn, &parms);
}

void AActor::ReceiveEndPlay(enum class EEndPlayReason EndPlayReason){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveEndPlay");

	FReceiveEndPlay parms{};	
	parms.EndPlayReason = EndPlayReason;

	ProcessEvent(fn, &parms);
}

void AActor::ReceiveDestroyed(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveDestroyed");

	FReceiveDestroyed parms{};	

	ProcessEvent(fn, &parms);
}

void AActor::ReceiveBeginPlay(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveBeginPlay");

	FReceiveBeginPlay parms{};	

	ProcessEvent(fn, &parms);
}

void AActor::ReceiveAsyncPhysicsTick(float DeltaSeconds, float SimSeconds){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveAsyncPhysicsTick");

	FReceiveAsyncPhysicsTick parms{};	
	parms.DeltaSeconds = DeltaSeconds;
	parms.SimSeconds = SimSeconds;

	ProcessEvent(fn, &parms);
}

void AActor::ReceiveAnyDamage(float Damage, struct UDamageType* DamageType, struct AController* InstigatedBy, struct AActor* DamageCauser){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveAnyDamage");

	FReceiveAnyDamage parms{};	
	parms.Damage = Damage;
	parms.DamageType = DamageType;
	parms.InstigatedBy = InstigatedBy;
	parms.DamageCauser = DamageCauser;

	ProcessEvent(fn, &parms);
}

void AActor::ReceiveActorOnReleased(struct FKey ButtonReleased){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorOnReleased");

	FReceiveActorOnReleased parms{};	
	parms.ButtonReleased = ButtonReleased;

	ProcessEvent(fn, &parms);
}

void AActor::ReceiveActorOnInputTouchLeave(enum class ETouchIndex FingerIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorOnInputTouchLeave");

	FReceiveActorOnInputTouchLeave parms{};	
	parms.FingerIndex = FingerIndex;

	ProcessEvent(fn, &parms);
}

void AActor::ReceiveActorOnInputTouchEnter(enum class ETouchIndex FingerIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorOnInputTouchEnter");

	FReceiveActorOnInputTouchEnter parms{};	
	parms.FingerIndex = FingerIndex;

	ProcessEvent(fn, &parms);
}

void AActor::ReceiveActorOnInputTouchEnd(enum class ETouchIndex FingerIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorOnInputTouchEnd");

	FReceiveActorOnInputTouchEnd parms{};	
	parms.FingerIndex = FingerIndex;

	ProcessEvent(fn, &parms);
}

void AActor::ReceiveActorOnInputTouchBegin(enum class ETouchIndex FingerIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorOnInputTouchBegin");

	FReceiveActorOnInputTouchBegin parms{};	
	parms.FingerIndex = FingerIndex;

	ProcessEvent(fn, &parms);
}

void AActor::ReceiveActorOnClicked(struct FKey ButtonPressed){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorOnClicked");

	FReceiveActorOnClicked parms{};	
	parms.ButtonPressed = ButtonPressed;

	ProcessEvent(fn, &parms);
}

void AActor::ReceiveActorEndOverlap(struct AActor* OtherActor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorEndOverlap");

	FReceiveActorEndOverlap parms{};	
	parms.OtherActor = OtherActor;

	ProcessEvent(fn, &parms);
}

void AActor::ReceiveActorEndCursorOver(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorEndCursorOver");

	FReceiveActorEndCursorOver parms{};	

	ProcessEvent(fn, &parms);
}

void AActor::ReceiveActorBeginOverlap(struct AActor* OtherActor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorBeginOverlap");

	FReceiveActorBeginOverlap parms{};	
	parms.OtherActor = OtherActor;

	ProcessEvent(fn, &parms);
}

void AActor::ReceiveActorBeginCursorOver(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorBeginCursorOver");

	FReceiveActorBeginCursorOver parms{};	

	ProcessEvent(fn, &parms);
}

void AActor::PrestreamTextures(float Seconds, bool bEnableStreaming, int32_t CinematicTextureGroups){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.PrestreamTextures");

	FPrestreamTextures parms{};	
	parms.Seconds = Seconds;
	parms.bEnableStreaming = bEnableStreaming;
	parms.CinematicTextureGroups = CinematicTextureGroups;

	ProcessEvent(fn, &parms);
}

void AActor::OnRep_ReplicateMovement(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.OnRep_ReplicateMovement");

	FOnRep_ReplicateMovement parms{};	

	ProcessEvent(fn, &parms);
}

void AActor::OnRep_ReplicatedMovement(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.OnRep_ReplicatedMovement");

	FOnRep_ReplicatedMovement parms{};	

	ProcessEvent(fn, &parms);
}

void AActor::OnRep_Owner(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.OnRep_Owner");

	FOnRep_Owner parms{};	

	ProcessEvent(fn, &parms);
}

void AActor::OnRep_Instigator(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.OnRep_Instigator");

	FOnRep_Instigator parms{};	

	ProcessEvent(fn, &parms);
}

void AActor::OnRep_AttachmentReplication(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.OnRep_AttachmentReplication");

	FOnRep_AttachmentReplication parms{};	

	ProcessEvent(fn, &parms);
}

void AActor::MakeNoise(float Loudness, struct APawn* NoiseInstigator, struct FVector NoiseLocation, float MaxRange, struct FName Tag){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.MakeNoise");

	FMakeNoise parms{};	
	parms.Loudness = Loudness;
	parms.NoiseInstigator = NoiseInstigator;
	parms.NoiseLocation = NoiseLocation;
	parms.MaxRange = MaxRange;
	parms.Tag = Tag;

	ProcessEvent(fn, &parms);
}

bool AActor::K2_TeleportTo(struct FVector DestLocation, struct FRotator DestRotation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.K2_TeleportTo");

	FK2_TeleportTo parms{};	
	parms.DestLocation = DestLocation;
	parms.DestRotation = DestRotation;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool AActor::K2_SetActorTransform(struct FTransform& NewTransform, bool bSweep, struct FHitResult& SweepHitResult, bool bTeleport){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.K2_SetActorTransform");

	FK2_SetActorTransform parms{};	
	parms.NewTransform = NewTransform;
	parms.bSweep = bSweep;
	parms.SweepHitResult = SweepHitResult;
	parms.bTeleport = bTeleport;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool AActor::K2_SetActorRotation(struct FRotator NewRotation, bool bTeleportPhysics){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.K2_SetActorRotation");

	FK2_SetActorRotation parms{};	
	parms.NewRotation = NewRotation;
	parms.bTeleportPhysics = bTeleportPhysics;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void AActor::K2_SetActorRelativeTransform(struct FTransform& NewRelativeTransform, bool bSweep, struct FHitResult& SweepHitResult, bool bTeleport){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.K2_SetActorRelativeTransform");

	FK2_SetActorRelativeTransform parms{};	
	parms.NewRelativeTransform = NewRelativeTransform;
	parms.bSweep = bSweep;
	parms.SweepHitResult = SweepHitResult;
	parms.bTeleport = bTeleport;

	ProcessEvent(fn, &parms);
}

void AActor::K2_SetActorRelativeRotation(struct FRotator NewRelativeRotation, bool bSweep, struct FHitResult& SweepHitResult, bool bTeleport){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.K2_SetActorRelativeRotation");

	FK2_SetActorRelativeRotation parms{};	
	parms.NewRelativeRotation = NewRelativeRotation;
	parms.bSweep = bSweep;
	parms.SweepHitResult = SweepHitResult;
	parms.bTeleport = bTeleport;

	ProcessEvent(fn, &parms);
}

void AActor::K2_SetActorRelativeLocation(struct FVector NewRelativeLocation, bool bSweep, struct FHitResult& SweepHitResult, bool bTeleport){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.K2_SetActorRelativeLocation");

	FK2_SetActorRelativeLocation parms{};	
	parms.NewRelativeLocation = NewRelativeLocation;
	parms.bSweep = bSweep;
	parms.SweepHitResult = SweepHitResult;
	parms.bTeleport = bTeleport;

	ProcessEvent(fn, &parms);
}

bool AActor::K2_SetActorLocationAndRotation(struct FVector NewLocation, struct FRotator NewRotation, bool bSweep, struct FHitResult& SweepHitResult, bool bTeleport){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.K2_SetActorLocationAndRotation");

	FK2_SetActorLocationAndRotation parms{};	
	parms.NewLocation = NewLocation;
	parms.NewRotation = NewRotation;
	parms.bSweep = bSweep;
	parms.SweepHitResult = SweepHitResult;
	parms.bTeleport = bTeleport;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool AActor::K2_SetActorLocation(struct FVector NewLocation, bool bSweep, struct FHitResult& SweepHitResult, bool bTeleport){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.K2_SetActorLocation");

	FK2_SetActorLocation parms{};	
	parms.NewLocation = NewLocation;
	parms.bSweep = bSweep;
	parms.SweepHitResult = SweepHitResult;
	parms.bTeleport = bTeleport;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void AActor::K2_OnReset(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.K2_OnReset");

	FK2_OnReset parms{};	

	ProcessEvent(fn, &parms);
}

void AActor::K2_OnEndViewTarget(struct APlayerController* PC){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.K2_OnEndViewTarget");

	FK2_OnEndViewTarget parms{};	
	parms.PC = PC;

	ProcessEvent(fn, &parms);
}

void AActor::K2_OnBecomeViewTarget(struct APlayerController* PC){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.K2_OnBecomeViewTarget");

	FK2_OnBecomeViewTarget parms{};	
	parms.PC = PC;

	ProcessEvent(fn, &parms);
}

struct USceneComponent* AActor::K2_GetRootComponent(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.K2_GetRootComponent");

	FK2_GetRootComponent parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<struct UActorComponent*> AActor::K2_GetComponentsByClass(UActorComponent* ComponentClass){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.K2_GetComponentsByClass");

	FK2_GetComponentsByClass parms{};	
	parms.ComponentClass = ComponentClass;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator AActor::K2_GetActorRotation(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.K2_GetActorRotation");

	FK2_GetActorRotation parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector AActor::K2_GetActorLocation(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.K2_GetActorLocation");

	FK2_GetActorLocation parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void AActor::K2_DetachFromActor(uint8_t LocationRule, uint8_t RotationRule, uint8_t ScaleRule){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.K2_DetachFromActor");

	FK2_DetachFromActor parms{};	
	parms.LocationRule = LocationRule;
	parms.RotationRule = RotationRule;
	parms.ScaleRule = ScaleRule;

	ProcessEvent(fn, &parms);
}

void AActor::K2_DestroyActor(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.K2_DestroyActor");

	FK2_DestroyActor parms{};	

	ProcessEvent(fn, &parms);
}

void AActor::K2_AttachToComponent(struct USceneComponent* Parent, struct FName SocketName, uint8_t LocationRule, uint8_t RotationRule, uint8_t ScaleRule, bool bWeldSimulatedBodies){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.K2_AttachToComponent");

	FK2_AttachToComponent parms{};	
	parms.Parent = Parent;
	parms.SocketName = SocketName;
	parms.LocationRule = LocationRule;
	parms.RotationRule = RotationRule;
	parms.ScaleRule = ScaleRule;
	parms.bWeldSimulatedBodies = bWeldSimulatedBodies;

	ProcessEvent(fn, &parms);
}

void AActor::K2_AttachToActor(struct AActor* ParentActor, struct FName SocketName, uint8_t LocationRule, uint8_t RotationRule, uint8_t ScaleRule, bool bWeldSimulatedBodies){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.K2_AttachToActor");

	FK2_AttachToActor parms{};	
	parms.ParentActor = ParentActor;
	parms.SocketName = SocketName;
	parms.LocationRule = LocationRule;
	parms.RotationRule = RotationRule;
	parms.ScaleRule = ScaleRule;
	parms.bWeldSimulatedBodies = bWeldSimulatedBodies;

	ProcessEvent(fn, &parms);
}

void AActor::K2_AttachRootComponentToActor(struct AActor* InParentActor, struct FName InSocketName, enum class EAttachLocation AttachLocationType, bool bWeldSimulatedBodies){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.K2_AttachRootComponentToActor");

	FK2_AttachRootComponentToActor parms{};	
	parms.InParentActor = InParentActor;
	parms.InSocketName = InSocketName;
	parms.AttachLocationType = AttachLocationType;
	parms.bWeldSimulatedBodies = bWeldSimulatedBodies;

	ProcessEvent(fn, &parms);
}

void AActor::K2_AttachRootComponentTo(struct USceneComponent* InParent, struct FName InSocketName, enum class EAttachLocation AttachLocationType, bool bWeldSimulatedBodies){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.K2_AttachRootComponentTo");

	FK2_AttachRootComponentTo parms{};	
	parms.InParent = InParent;
	parms.InSocketName = InSocketName;
	parms.AttachLocationType = AttachLocationType;
	parms.bWeldSimulatedBodies = bWeldSimulatedBodies;

	ProcessEvent(fn, &parms);
}

void AActor::K2_AddActorWorldTransformKeepScale(struct FTransform& DeltaTransform, bool bSweep, struct FHitResult& SweepHitResult, bool bTeleport){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.K2_AddActorWorldTransformKeepScale");

	FK2_AddActorWorldTransformKeepScale parms{};	
	parms.DeltaTransform = DeltaTransform;
	parms.bSweep = bSweep;
	parms.SweepHitResult = SweepHitResult;
	parms.bTeleport = bTeleport;

	ProcessEvent(fn, &parms);
}

void AActor::K2_AddActorWorldTransform(struct FTransform& DeltaTransform, bool bSweep, struct FHitResult& SweepHitResult, bool bTeleport){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.K2_AddActorWorldTransform");

	FK2_AddActorWorldTransform parms{};	
	parms.DeltaTransform = DeltaTransform;
	parms.bSweep = bSweep;
	parms.SweepHitResult = SweepHitResult;
	parms.bTeleport = bTeleport;

	ProcessEvent(fn, &parms);
}

void AActor::K2_AddActorWorldRotation(struct FRotator DeltaRotation, bool bSweep, struct FHitResult& SweepHitResult, bool bTeleport){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.K2_AddActorWorldRotation");

	FK2_AddActorWorldRotation parms{};	
	parms.DeltaRotation = DeltaRotation;
	parms.bSweep = bSweep;
	parms.SweepHitResult = SweepHitResult;
	parms.bTeleport = bTeleport;

	ProcessEvent(fn, &parms);
}

void AActor::K2_AddActorWorldOffset(struct FVector DeltaLocation, bool bSweep, struct FHitResult& SweepHitResult, bool bTeleport){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.K2_AddActorWorldOffset");

	FK2_AddActorWorldOffset parms{};	
	parms.DeltaLocation = DeltaLocation;
	parms.bSweep = bSweep;
	parms.SweepHitResult = SweepHitResult;
	parms.bTeleport = bTeleport;

	ProcessEvent(fn, &parms);
}

void AActor::K2_AddActorLocalTransform(struct FTransform& NewTransform, bool bSweep, struct FHitResult& SweepHitResult, bool bTeleport){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.K2_AddActorLocalTransform");

	FK2_AddActorLocalTransform parms{};	
	parms.NewTransform = NewTransform;
	parms.bSweep = bSweep;
	parms.SweepHitResult = SweepHitResult;
	parms.bTeleport = bTeleport;

	ProcessEvent(fn, &parms);
}

void AActor::K2_AddActorLocalRotation(struct FRotator DeltaRotation, bool bSweep, struct FHitResult& SweepHitResult, bool bTeleport){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.K2_AddActorLocalRotation");

	FK2_AddActorLocalRotation parms{};	
	parms.DeltaRotation = DeltaRotation;
	parms.bSweep = bSweep;
	parms.SweepHitResult = SweepHitResult;
	parms.bTeleport = bTeleport;

	ProcessEvent(fn, &parms);
}

void AActor::K2_AddActorLocalOffset(struct FVector DeltaLocation, bool bSweep, struct FHitResult& SweepHitResult, bool bTeleport){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.K2_AddActorLocalOffset");

	FK2_AddActorLocalOffset parms{};	
	parms.DeltaLocation = DeltaLocation;
	parms.bSweep = bSweep;
	parms.SweepHitResult = SweepHitResult;
	parms.bTeleport = bTeleport;

	ProcessEvent(fn, &parms);
}

bool AActor::IsOverlappingActor(struct AActor* Other){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.IsOverlappingActor");

	FIsOverlappingActor parms{};	
	parms.Other = Other;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool AActor::IsChildActor(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.IsChildActor");

	FIsChildActor parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool AActor::IsActorTickEnabled(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.IsActorTickEnabled");

	FIsActorTickEnabled parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool AActor::IsActorBeingDestroyed(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.IsActorBeingDestroyed");

	FIsActorBeingDestroyed parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool AActor::HasAuthority(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.HasAuthority");

	FHasAuthority parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float AActor::GetVerticalDistanceTo(struct AActor* OtherActor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetVerticalDistanceTo");

	FGetVerticalDistanceTo parms{};	
	parms.OtherActor = OtherActor;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector AActor::GetVelocity(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetVelocity");

	FGetVelocity parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTransform AActor::GetTransform(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetTransform");

	FGetTransform parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool AActor::GetTickableWhenPaused(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetTickableWhenPaused");

	FGetTickableWhenPaused parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float AActor::GetSquaredHorizontalDistanceTo(struct AActor* OtherActor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetSquaredHorizontalDistanceTo");

	FGetSquaredHorizontalDistanceTo parms{};	
	parms.OtherActor = OtherActor;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float AActor::GetSquaredDistanceTo(struct AActor* OtherActor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetSquaredDistanceTo");

	FGetSquaredDistanceTo parms{};	
	parms.OtherActor = OtherActor;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

enum class ENetRole AActor::GetRemoteRole(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetRemoteRole");

	FGetRemoteRole parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t AActor::GetRayTracingGroupId(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetRayTracingGroupId");

	FGetRayTracingGroupId parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UChildActorComponent* AActor::GetParentComponent(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetParentComponent");

	FGetParentComponent parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct AActor* AActor::GetParentActor(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetParentActor");

	FGetParentActor parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct AActor* AActor::GetOwner(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetOwner");

	FGetOwner parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void AActor::GetOverlappingComponents(struct TArray<struct UPrimitiveComponent*>& OverlappingComponents){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetOverlappingComponents");

	FGetOverlappingComponents parms{};	
	parms.OverlappingComponents = OverlappingComponents;

	ProcessEvent(fn, &parms);
}

void AActor::GetOverlappingActors(struct TArray<struct AActor*>& OverlappingActors, AActor* ClassFilter){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetOverlappingActors");

	FGetOverlappingActors parms{};	
	parms.OverlappingActors = OverlappingActors;
	parms.ClassFilter = ClassFilter;

	ProcessEvent(fn, &parms);
}

enum class ENetRole AActor::GetLocalRole(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetLocalRole");

	FGetLocalRole parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float AActor::GetLifeSpan(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetLifeSpan");

	FGetLifeSpan parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTransform AActor::GetLevelTransform(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetLevelTransform");

	FGetLevelTransform parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct ULevel* AActor::GetLevel(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetLevel");

	FGetLevel parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct AController* AActor::GetInstigatorController(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetInstigatorController");

	FGetInstigatorController parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct APawn* AActor::GetInstigator(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetInstigator");

	FGetInstigator parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector AActor::GetInputVectorAxisValue(struct FKey InputAxisKey){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetInputVectorAxisValue");

	FGetInputVectorAxisValue parms{};	
	parms.InputAxisKey = InputAxisKey;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float AActor::GetInputAxisValue(struct FName InputAxisName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetInputAxisValue");

	FGetInputAxisValue parms{};	
	parms.InputAxisName = InputAxisName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float AActor::GetInputAxisKeyValue(struct FKey InputAxisKey){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetInputAxisKeyValue");

	FGetInputAxisKeyValue parms{};	
	parms.InputAxisKey = InputAxisKey;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float AActor::GetHorizontalDotProductTo(struct AActor* OtherActor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetHorizontalDotProductTo");

	FGetHorizontalDotProductTo parms{};	
	parms.OtherActor = OtherActor;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float AActor::GetHorizontalDistanceTo(struct AActor* OtherActor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetHorizontalDistanceTo");

	FGetHorizontalDistanceTo parms{};	
	parms.OtherActor = OtherActor;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float AActor::GetGameTimeSinceCreation(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetGameTimeSinceCreation");

	FGetGameTimeSinceCreation parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float AActor::GetDotProductTo(struct AActor* OtherActor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetDotProductTo");

	FGetDotProductTo parms{};	
	parms.OtherActor = OtherActor;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float AActor::GetDistanceTo(struct AActor* OtherActor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetDistanceTo");

	FGetDistanceTo parms{};	
	parms.OtherActor = OtherActor;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<struct UActorComponent*> AActor::GetComponentsByTag(UActorComponent* ComponentClass, struct FName Tag){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetComponentsByTag");

	FGetComponentsByTag parms{};	
	parms.ComponentClass = ComponentClass;
	parms.Tag = Tag;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<struct UActorComponent*> AActor::GetComponentsByInterface(UInterface* Interface){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetComponentsByInterface");

	FGetComponentsByInterface parms{};	
	parms.Interface = Interface;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UActorComponent* AActor::GetComponentByClass(UActorComponent* ComponentClass){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetComponentByClass");

	FGetComponentByClass parms{};	
	parms.ComponentClass = ComponentClass;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FName AActor::GetAttachParentSocketName(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetAttachParentSocketName");

	FGetAttachParentSocketName parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct AActor* AActor::GetAttachParentActor(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetAttachParentActor");

	FGetAttachParentActor parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void AActor::GetAttachedActors(struct TArray<struct AActor*>& OutActors, bool bResetArray, bool bRecursivelyIncludeAttachedActors){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetAttachedActors");

	FGetAttachedActors parms{};	
	parms.OutActors = OutActors;
	parms.bResetArray = bResetArray;
	parms.bRecursivelyIncludeAttachedActors = bRecursivelyIncludeAttachedActors;

	ProcessEvent(fn, &parms);
}

void AActor::GetAllChildActors(struct TArray<struct AActor*>& ChildActors, bool bIncludeDescendants){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetAllChildActors");

	FGetAllChildActors parms{};	
	parms.ChildActors = ChildActors;
	parms.bIncludeDescendants = bIncludeDescendants;

	ProcessEvent(fn, &parms);
}

struct FVector AActor::GetActorUpVector(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetActorUpVector");

	FGetActorUpVector parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float AActor::GetActorTimeDilation(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetActorTimeDilation");

	FGetActorTimeDilation parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float AActor::GetActorTickInterval(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetActorTickInterval");

	FGetActorTickInterval parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector AActor::GetActorScale3D(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetActorScale3D");

	FGetActorScale3D parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector AActor::GetActorRightVector(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetActorRightVector");

	FGetActorRightVector parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector AActor::GetActorRelativeScale3D(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetActorRelativeScale3D");

	FGetActorRelativeScale3D parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector AActor::GetActorForwardVector(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetActorForwardVector");

	FGetActorForwardVector parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void AActor::GetActorEyesViewPoint(struct FVector& OutLocation, struct FRotator& OutRotation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetActorEyesViewPoint");

	FGetActorEyesViewPoint parms{};	
	parms.OutLocation = OutLocation;
	parms.OutRotation = OutRotation;

	ProcessEvent(fn, &parms);
}

bool AActor::GetActorEnableCollision(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetActorEnableCollision");

	FGetActorEnableCollision parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void AActor::GetActorBounds(bool bOnlyCollidingComponents, struct FVector& Origin, struct FVector& BoxExtent, bool bIncludeFromChildActors){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.GetActorBounds");

	FGetActorBounds parms{};	
	parms.bOnlyCollidingComponents = bOnlyCollidingComponents;
	parms.Origin = Origin;
	parms.BoxExtent = BoxExtent;
	parms.bIncludeFromChildActors = bIncludeFromChildActors;

	ProcessEvent(fn, &parms);
}

void AActor::ForceNetUpdate(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.ForceNetUpdate");

	FForceNetUpdate parms{};	

	ProcessEvent(fn, &parms);
}

void AActor::FlushNetDormancy(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.FlushNetDormancy");

	FFlushNetDormancy parms{};	

	ProcessEvent(fn, &parms);
}

void AActor::FinishAddComponent(struct UActorComponent* Component, bool bManualAttachment, struct FTransform& RelativeTransform){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.FinishAddComponent");

	FFinishAddComponent parms{};	
	parms.Component = Component;
	parms.bManualAttachment = bManualAttachment;
	parms.RelativeTransform = RelativeTransform;

	ProcessEvent(fn, &parms);
}

void AActor::EnableInput(struct APlayerController* PlayerController){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.EnableInput");

	FEnableInput parms{};	
	parms.PlayerController = PlayerController;

	ProcessEvent(fn, &parms);
}

void AActor::DisableInput(struct APlayerController* PlayerController){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.DisableInput");

	FDisableInput parms{};	
	parms.PlayerController = PlayerController;

	ProcessEvent(fn, &parms);
}

void AActor::DetachRootComponentFromParent(bool bMaintainWorldPosition){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.DetachRootComponentFromParent");

	FDetachRootComponentFromParent parms{};	
	parms.bMaintainWorldPosition = bMaintainWorldPosition;

	ProcessEvent(fn, &parms);
}

void AActor::AddTickPrerequisiteComponent(struct UActorComponent* PrerequisiteComponent){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.AddTickPrerequisiteComponent");

	FAddTickPrerequisiteComponent parms{};	
	parms.PrerequisiteComponent = PrerequisiteComponent;

	ProcessEvent(fn, &parms);
}

void AActor::AddTickPrerequisiteActor(struct AActor* PrerequisiteActor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.AddTickPrerequisiteActor");

	FAddTickPrerequisiteActor parms{};	
	parms.PrerequisiteActor = PrerequisiteActor;

	ProcessEvent(fn, &parms);
}

struct UActorComponent* AActor::AddComponentByClass(UActorComponent* Class, bool bManualAttachment, struct FTransform& RelativeTransform, bool bDeferredFinish){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.AddComponentByClass");

	FAddComponentByClass parms{};	
	parms.Class = Class;
	parms.bManualAttachment = bManualAttachment;
	parms.RelativeTransform = RelativeTransform;
	parms.bDeferredFinish = bDeferredFinish;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UActorComponent* AActor::AddComponent(struct FName TemplateName, bool bManualAttachment, struct FTransform& RelativeTransform, struct UObject* ComponentTemplateContext, bool bDeferredFinish){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.AddComponent");

	FAddComponent parms{};	
	parms.TemplateName = TemplateName;
	parms.bManualAttachment = bManualAttachment;
	parms.RelativeTransform = RelativeTransform;
	parms.ComponentTemplateContext = ComponentTemplateContext;
	parms.bDeferredFinish = bDeferredFinish;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool AActor::ActorHasTag(struct FName Tag){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Actor.ActorHasTag");

	FActorHasTag parms{};	
	parms.Tag = Tag;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void AHUD::ShowHUD(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.HUD.ShowHUD");

	FShowHUD parms{};	

	ProcessEvent(fn, &parms);
}

void AHUD::ShowDebugToggleSubCategory(struct FName Category){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.HUD.ShowDebugToggleSubCategory");

	FShowDebugToggleSubCategory parms{};	
	parms.Category = Category;

	ProcessEvent(fn, &parms);
}

void AHUD::ShowDebugForReticleTargetToggle(AActor* DesiredClass){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.HUD.ShowDebugForReticleTargetToggle");

	FShowDebugForReticleTargetToggle parms{};	
	parms.DesiredClass = DesiredClass;

	ProcessEvent(fn, &parms);
}

void AHUD::ShowDebug(struct FName DebugType){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.HUD.ShowDebug");

	FShowDebug parms{};	
	parms.DebugType = DebugType;

	ProcessEvent(fn, &parms);
}

void AHUD::RemoveDebugText(struct AActor* SrcActor, bool bLeaveDurationText){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.HUD.RemoveDebugText");

	FRemoveDebugText parms{};	
	parms.SrcActor = SrcActor;
	parms.bLeaveDurationText = bLeaveDurationText;

	ProcessEvent(fn, &parms);
}

void AHUD::RemoveAllDebugStrings(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.HUD.RemoveAllDebugStrings");

	FRemoveAllDebugStrings parms{};	

	ProcessEvent(fn, &parms);
}

void AHUD::ReceiveHitBoxRelease(struct FName BoxName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.HUD.ReceiveHitBoxRelease");

	FReceiveHitBoxRelease parms{};	
	parms.BoxName = BoxName;

	ProcessEvent(fn, &parms);
}

void AHUD::ReceiveHitBoxEndCursorOver(struct FName BoxName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.HUD.ReceiveHitBoxEndCursorOver");

	FReceiveHitBoxEndCursorOver parms{};	
	parms.BoxName = BoxName;

	ProcessEvent(fn, &parms);
}

void AHUD::ReceiveHitBoxClick(struct FName BoxName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.HUD.ReceiveHitBoxClick");

	FReceiveHitBoxClick parms{};	
	parms.BoxName = BoxName;

	ProcessEvent(fn, &parms);
}

void AHUD::ReceiveHitBoxBeginCursorOver(struct FName BoxName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.HUD.ReceiveHitBoxBeginCursorOver");

	FReceiveHitBoxBeginCursorOver parms{};	
	parms.BoxName = BoxName;

	ProcessEvent(fn, &parms);
}

void AHUD::ReceiveDrawHUD(int32_t SizeX, int32_t SizeY){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.HUD.ReceiveDrawHUD");

	FReceiveDrawHUD parms{};	
	parms.SizeX = SizeX;
	parms.SizeY = SizeY;

	ProcessEvent(fn, &parms);
}

struct FVector AHUD::Project(struct FVector Location, bool bClampToZeroPlane){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.HUD.Project");

	FProject parms{};	
	parms.Location = Location;
	parms.bClampToZeroPlane = bClampToZeroPlane;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void AHUD::PreviousDebugTarget(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.HUD.PreviousDebugTarget");

	FPreviousDebugTarget parms{};	

	ProcessEvent(fn, &parms);
}

void AHUD::NextDebugTarget(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.HUD.NextDebugTarget");

	FNextDebugTarget parms{};	

	ProcessEvent(fn, &parms);
}

void AHUD::GetTextSize(struct FString Text, float& OutWidth, float& OutHeight, struct UFont* Font, float Scale){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.HUD.GetTextSize");

	FGetTextSize parms{};	
	parms.Text = Text;
	parms.OutWidth = OutWidth;
	parms.OutHeight = OutHeight;
	parms.Font = Font;
	parms.Scale = Scale;

	ProcessEvent(fn, &parms);
}

struct APlayerController* AHUD::GetOwningPlayerController(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.HUD.GetOwningPlayerController");

	FGetOwningPlayerController parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct APawn* AHUD::GetOwningPawn(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.HUD.GetOwningPawn");

	FGetOwningPawn parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void AHUD::GetActorsInSelectionRectangle(AActor* ClassFilter, struct FVector2D& FirstPoint, struct FVector2D& SecondPoint, struct TArray<struct AActor*>& OutActors, bool bIncludeNonCollidingComponents, bool bActorMustBeFullyEnclosed){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.HUD.GetActorsInSelectionRectangle");

	FGetActorsInSelectionRectangle parms{};	
	parms.ClassFilter = ClassFilter;
	parms.FirstPoint = FirstPoint;
	parms.SecondPoint = SecondPoint;
	parms.OutActors = OutActors;
	parms.bIncludeNonCollidingComponents = bIncludeNonCollidingComponents;
	parms.bActorMustBeFullyEnclosed = bActorMustBeFullyEnclosed;

	ProcessEvent(fn, &parms);
}

void AHUD::DrawTextureSimple(struct UTexture* Texture, float ScreenX, float ScreenY, float Scale, bool bScalePosition){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.HUD.DrawTextureSimple");

	FDrawTextureSimple parms{};	
	parms.Texture = Texture;
	parms.ScreenX = ScreenX;
	parms.ScreenY = ScreenY;
	parms.Scale = Scale;
	parms.bScalePosition = bScalePosition;

	ProcessEvent(fn, &parms);
}

void AHUD::DrawTexture(struct UTexture* Texture, float ScreenX, float ScreenY, float ScreenW, float ScreenH, float TextureU, float TextureV, float TextureUWidth, float TextureVHeight, struct FLinearColor TintColor, enum class EBlendMode BlendMode, float Scale, bool bScalePosition, float Rotation, struct FVector2D RotPivot){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.HUD.DrawTexture");

	FDrawTexture parms{};	
	parms.Texture = Texture;
	parms.ScreenX = ScreenX;
	parms.ScreenY = ScreenY;
	parms.ScreenW = ScreenW;
	parms.ScreenH = ScreenH;
	parms.TextureU = TextureU;
	parms.TextureV = TextureV;
	parms.TextureUWidth = TextureUWidth;
	parms.TextureVHeight = TextureVHeight;
	parms.TintColor = TintColor;
	parms.BlendMode = BlendMode;
	parms.Scale = Scale;
	parms.bScalePosition = bScalePosition;
	parms.Rotation = Rotation;
	parms.RotPivot = RotPivot;

	ProcessEvent(fn, &parms);
}

void AHUD::DrawText(struct FString Text, struct FLinearColor TextColor, float ScreenX, float ScreenY, struct UFont* Font, float Scale, bool bScalePosition){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.HUD.DrawText");

	FDrawText parms{};	
	parms.Text = Text;
	parms.TextColor = TextColor;
	parms.ScreenX = ScreenX;
	parms.ScreenY = ScreenY;
	parms.Font = Font;
	parms.Scale = Scale;
	parms.bScalePosition = bScalePosition;

	ProcessEvent(fn, &parms);
}

void AHUD::DrawRect(struct FLinearColor RectColor, float ScreenX, float ScreenY, float ScreenW, float ScreenH){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.HUD.DrawRect");

	FDrawRect parms{};	
	parms.RectColor = RectColor;
	parms.ScreenX = ScreenX;
	parms.ScreenY = ScreenY;
	parms.ScreenW = ScreenW;
	parms.ScreenH = ScreenH;

	ProcessEvent(fn, &parms);
}

void AHUD::DrawMaterialTriangle(struct UMaterialInterface* Material, struct FVector2D V0_Pos, struct FVector2D V1_Pos, struct FVector2D V2_Pos, struct FVector2D V0_UV, struct FVector2D V1_UV, struct FVector2D V2_UV, struct FLinearColor V0_Color, struct FLinearColor V1_Color, struct FLinearColor V2_Color){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.HUD.DrawMaterialTriangle");

	FDrawMaterialTriangle parms{};	
	parms.Material = Material;
	parms.V0_Pos = V0_Pos;
	parms.V1_Pos = V1_Pos;
	parms.V2_Pos = V2_Pos;
	parms.V0_UV = V0_UV;
	parms.V1_UV = V1_UV;
	parms.V2_UV = V2_UV;
	parms.V0_Color = V0_Color;
	parms.V1_Color = V1_Color;
	parms.V2_Color = V2_Color;

	ProcessEvent(fn, &parms);
}

void AHUD::DrawMaterialSimple(struct UMaterialInterface* Material, float ScreenX, float ScreenY, float ScreenW, float ScreenH, float Scale, bool bScalePosition){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.HUD.DrawMaterialSimple");

	FDrawMaterialSimple parms{};	
	parms.Material = Material;
	parms.ScreenX = ScreenX;
	parms.ScreenY = ScreenY;
	parms.ScreenW = ScreenW;
	parms.ScreenH = ScreenH;
	parms.Scale = Scale;
	parms.bScalePosition = bScalePosition;

	ProcessEvent(fn, &parms);
}

void AHUD::DrawMaterial(struct UMaterialInterface* Material, float ScreenX, float ScreenY, float ScreenW, float ScreenH, float MaterialU, float MaterialV, float MaterialUWidth, float MaterialVHeight, float Scale, bool bScalePosition, float Rotation, struct FVector2D RotPivot){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.HUD.DrawMaterial");

	FDrawMaterial parms{};	
	parms.Material = Material;
	parms.ScreenX = ScreenX;
	parms.ScreenY = ScreenY;
	parms.ScreenW = ScreenW;
	parms.ScreenH = ScreenH;
	parms.MaterialU = MaterialU;
	parms.MaterialV = MaterialV;
	parms.MaterialUWidth = MaterialUWidth;
	parms.MaterialVHeight = MaterialVHeight;
	parms.Scale = Scale;
	parms.bScalePosition = bScalePosition;
	parms.Rotation = Rotation;
	parms.RotPivot = RotPivot;

	ProcessEvent(fn, &parms);
}

void AHUD::DrawLine(float StartScreenX, float StartScreenY, float EndScreenX, float EndScreenY, struct FLinearColor LineColor, float LineThickness){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.HUD.DrawLine");

	FDrawLine parms{};	
	parms.StartScreenX = StartScreenX;
	parms.StartScreenY = StartScreenY;
	parms.EndScreenX = EndScreenX;
	parms.EndScreenY = EndScreenY;
	parms.LineColor = LineColor;
	parms.LineThickness = LineThickness;

	ProcessEvent(fn, &parms);
}

void AHUD::Deproject(float ScreenX, float ScreenY, struct FVector& WorldPosition, struct FVector& WorldDirection){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.HUD.Deproject");

	FDeproject parms{};	
	parms.ScreenX = ScreenX;
	parms.ScreenY = ScreenY;
	parms.WorldPosition = WorldPosition;
	parms.WorldDirection = WorldDirection;

	ProcessEvent(fn, &parms);
}

void AHUD::AddHitBox(struct FVector2D Position, struct FVector2D Size, struct FName InName, bool bConsumesInput, int32_t Priority){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.HUD.AddHitBox");

	FAddHitBox parms{};	
	parms.Position = Position;
	parms.Size = Size;
	parms.InName = InName;
	parms.bConsumesInput = bConsumesInput;
	parms.Priority = Priority;

	ProcessEvent(fn, &parms);
}

void AHUD::AddDebugText(struct FString DebugText, struct AActor* SrcActor, float Duration, struct FVector Offset, struct FVector DesiredOffset, struct FColor TextColor, bool bSkipOverwriteCheck, bool bAbsoluteLocation, bool bKeepAttachedToActor, struct UFont* InFont, float FontScale, bool bDrawShadow){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.HUD.AddDebugText");

	FAddDebugText parms{};	
	parms.DebugText = DebugText;
	parms.SrcActor = SrcActor;
	parms.Duration = Duration;
	parms.Offset = Offset;
	parms.DesiredOffset = DesiredOffset;
	parms.TextColor = TextColor;
	parms.bSkipOverwriteCheck = bSkipOverwriteCheck;
	parms.bAbsoluteLocation = bAbsoluteLocation;
	parms.bKeepAttachedToActor = bKeepAttachedToActor;
	parms.InFont = InFont;
	parms.FontScale = FontScale;
	parms.bDrawShadow = bDrawShadow;

	ProcessEvent(fn, &parms);
}

bool UDataLayerInstance::IsVisible(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataLayerInstance.IsVisible");

	FIsVisible parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UDataLayerInstance::IsRuntime(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataLayerInstance.IsRuntime");

	FIsRuntime parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UDataLayerInstance::IsInitiallyVisible(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataLayerInstance.IsInitiallyVisible");

	FIsInitiallyVisible parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UDataLayerInstance::IsEffectiveVisible(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataLayerInstance.IsEffectiveVisible");

	FIsEffectiveVisible parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

uint8_t UDataLayerInstance::GetType(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataLayerInstance.GetType");

	FGetType parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

uint8_t UDataLayerInstance::GetInitialRuntimeState(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataLayerInstance.GetInitialRuntimeState");

	FGetInitialRuntimeState parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FColor UDataLayerInstance::GetDebugColor(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataLayerInstance.GetDebugColor");

	FGetDebugColor parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UBlueprintAsyncActionBase::Activate(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintAsyncActionBase.Activate");

	FActivate parms{};	

	ProcessEvent(fn, &parms);
}

void USceneCaptureComponent::ShowOnlyComponent(struct UPrimitiveComponent* InComponent){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponent.ShowOnlyComponent");

	FShowOnlyComponent parms{};	
	parms.InComponent = InComponent;

	ProcessEvent(fn, &parms);
}

void USceneCaptureComponent::ShowOnlyActorComponents(struct AActor* InActor, bool bIncludeFromChildActors){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponent.ShowOnlyActorComponents");

	FShowOnlyActorComponents parms{};	
	parms.InActor = InActor;
	parms.bIncludeFromChildActors = bIncludeFromChildActors;

	ProcessEvent(fn, &parms);
}

void USceneCaptureComponent::SetCaptureSortPriority(int32_t NewCaptureSortPriority){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponent.SetCaptureSortPriority");

	FSetCaptureSortPriority parms{};	
	parms.NewCaptureSortPriority = NewCaptureSortPriority;

	ProcessEvent(fn, &parms);
}

void USceneCaptureComponent::RemoveShowOnlyComponent(struct UPrimitiveComponent* InComponent){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponent.RemoveShowOnlyComponent");

	FRemoveShowOnlyComponent parms{};	
	parms.InComponent = InComponent;

	ProcessEvent(fn, &parms);
}

void USceneCaptureComponent::RemoveShowOnlyActorComponents(struct AActor* InActor, bool bIncludeFromChildActors){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponent.RemoveShowOnlyActorComponents");

	FRemoveShowOnlyActorComponents parms{};	
	parms.InActor = InActor;
	parms.bIncludeFromChildActors = bIncludeFromChildActors;

	ProcessEvent(fn, &parms);
}

void USceneCaptureComponent::HideComponent(struct UPrimitiveComponent* InComponent){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponent.HideComponent");

	FHideComponent parms{};	
	parms.InComponent = InComponent;

	ProcessEvent(fn, &parms);
}

void USceneCaptureComponent::HideActorComponents(struct AActor* InActor, bool bIncludeFromChildActors){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponent.HideActorComponents");

	FHideActorComponents parms{};	
	parms.InActor = InActor;
	parms.bIncludeFromChildActors = bIncludeFromChildActors;

	ProcessEvent(fn, &parms);
}

void USceneCaptureComponent::ClearShowOnlyComponents(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponent.ClearShowOnlyComponents");

	FClearShowOnlyComponents parms{};	

	ProcessEvent(fn, &parms);
}

void USceneCaptureComponent::ClearHiddenComponents(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponent.ClearHiddenComponents");

	FClearHiddenComponents parms{};	

	ProcessEvent(fn, &parms);
}

void UAudioComponent::StopDelayed(float DelayTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioComponent.StopDelayed");

	FStopDelayed parms{};	
	parms.DelayTime = DelayTime;

	ProcessEvent(fn, &parms);
}

void UAudioComponent::Stop(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioComponent.Stop");

	FStop parms{};	

	ProcessEvent(fn, &parms);
}

void UAudioComponent::SetWaveParameter(struct FName InName, struct USoundWave* InWave){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetWaveParameter");

	FSetWaveParameter parms{};	
	parms.InName = InName;
	parms.InWave = InWave;

	ProcessEvent(fn, &parms);
}

void UAudioComponent::SetVolumeMultiplier(float NewVolumeMultiplier){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetVolumeMultiplier");

	FSetVolumeMultiplier parms{};	
	parms.NewVolumeMultiplier = NewVolumeMultiplier;

	ProcessEvent(fn, &parms);
}

void UAudioComponent::SetUISound(bool bInUISound){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetUISound");

	FSetUISound parms{};	
	parms.bInUISound = bInUISound;

	ProcessEvent(fn, &parms);
}

void UAudioComponent::SetSubmixSend(struct USoundSubmixBase* Submix, float SendLevel){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetSubmixSend");

	FSetSubmixSend parms{};	
	parms.Submix = Submix;
	parms.SendLevel = SendLevel;

	ProcessEvent(fn, &parms);
}

void UAudioComponent::SetSourceBusSendPreEffect(struct USoundSourceBus* SoundSourceBus, float SourceBusSendLevel){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetSourceBusSendPreEffect");

	FSetSourceBusSendPreEffect parms{};	
	parms.SoundSourceBus = SoundSourceBus;
	parms.SourceBusSendLevel = SourceBusSendLevel;

	ProcessEvent(fn, &parms);
}

void UAudioComponent::SetSourceBusSendPostEffect(struct USoundSourceBus* SoundSourceBus, float SourceBusSendLevel){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetSourceBusSendPostEffect");

	FSetSourceBusSendPostEffect parms{};	
	parms.SoundSourceBus = SoundSourceBus;
	parms.SourceBusSendLevel = SourceBusSendLevel;

	ProcessEvent(fn, &parms);
}

void UAudioComponent::SetSound(struct USoundBase* NewSound){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetSound");

	FSetSound parms{};	
	parms.NewSound = NewSound;

	ProcessEvent(fn, &parms);
}

void UAudioComponent::SetPitchMultiplier(float NewPitchMultiplier){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetPitchMultiplier");

	FSetPitchMultiplier parms{};	
	parms.NewPitchMultiplier = NewPitchMultiplier;

	ProcessEvent(fn, &parms);
}

void UAudioComponent::SetPaused(bool bPause){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetPaused");

	FSetPaused parms{};	
	parms.bPause = bPause;

	ProcessEvent(fn, &parms);
}

void UAudioComponent::SetOutputToBusOnly(bool bInOutputToBusOnly){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetOutputToBusOnly");

	FSetOutputToBusOnly parms{};	
	parms.bInOutputToBusOnly = bInOutputToBusOnly;

	ProcessEvent(fn, &parms);
}

void UAudioComponent::SetLowPassFilterFrequency(float InLowPassFilterFrequency){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetLowPassFilterFrequency");

	FSetLowPassFilterFrequency parms{};	
	parms.InLowPassFilterFrequency = InLowPassFilterFrequency;

	ProcessEvent(fn, &parms);
}

void UAudioComponent::SetLowPassFilterEnabled(bool InLowPassFilterEnabled){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetLowPassFilterEnabled");

	FSetLowPassFilterEnabled parms{};	
	parms.InLowPassFilterEnabled = InLowPassFilterEnabled;

	ProcessEvent(fn, &parms);
}

void UAudioComponent::SetIntParameter(struct FName InName, int32_t inInt){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetIntParameter");

	FSetIntParameter parms{};	
	parms.InName = InName;
	parms.inInt = inInt;

	ProcessEvent(fn, &parms);
}

void UAudioComponent::SetFloatParameter(struct FName InName, float InFloat){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetFloatParameter");

	FSetFloatParameter parms{};	
	parms.InName = InName;
	parms.InFloat = InFloat;

	ProcessEvent(fn, &parms);
}

void UAudioComponent::SetBoolParameter(struct FName InName, bool InBool){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetBoolParameter");

	FSetBoolParameter parms{};	
	parms.InName = InName;
	parms.InBool = InBool;

	ProcessEvent(fn, &parms);
}

void UAudioComponent::SetAudioBusSendPreEffect(struct UAudioBus* AudioBus, float AudioBusSendLevel){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetAudioBusSendPreEffect");

	FSetAudioBusSendPreEffect parms{};	
	parms.AudioBus = AudioBus;
	parms.AudioBusSendLevel = AudioBusSendLevel;

	ProcessEvent(fn, &parms);
}

void UAudioComponent::SetAudioBusSendPostEffect(struct UAudioBus* AudioBus, float AudioBusSendLevel){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetAudioBusSendPostEffect");

	FSetAudioBusSendPostEffect parms{};	
	parms.AudioBus = AudioBus;
	parms.AudioBusSendLevel = AudioBusSendLevel;

	ProcessEvent(fn, &parms);
}

void UAudioComponent::PlayQuantized(struct UObject* WorldContextObject, struct UQuartzClockHandle*& InClockHandle, struct FQuartzQuantizationBoundary& InQuantizationBoundary, struct FDelegate& InDelegate, float InStartTime, float InFadeInDuration, float InFadeVolumeLevel, uint8_t InFadeCurve){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioComponent.PlayQuantized");

	FPlayQuantized parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.InClockHandle = InClockHandle;
	parms.InQuantizationBoundary = InQuantizationBoundary;
	parms.InDelegate = InDelegate;
	parms.InStartTime = InStartTime;
	parms.InFadeInDuration = InFadeInDuration;
	parms.InFadeVolumeLevel = InFadeVolumeLevel;
	parms.InFadeCurve = InFadeCurve;

	ProcessEvent(fn, &parms);
}

void UAudioComponent::Play(float StartTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioComponent.Play");

	FPlay parms{};	
	parms.StartTime = StartTime;

	ProcessEvent(fn, &parms);
}

bool UAudioComponent::IsVirtualized(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioComponent.IsVirtualized");

	FIsVirtualized parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAudioComponent::IsPlaying(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioComponent.IsPlaying");

	FIsPlaying parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAudioComponent::HasCookedFFTData(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioComponent.HasCookedFFTData");

	FHasCookedFFTData parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAudioComponent::HasCookedAmplitudeEnvelopeData(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioComponent.HasCookedAmplitudeEnvelopeData");

	FHasCookedAmplitudeEnvelopeData parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

uint8_t UAudioComponent::GetPlayState(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioComponent.GetPlayState");

	FGetPlayState parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAudioComponent::GetCookedFFTDataForAllPlayingSounds(struct TArray<struct FSoundWaveSpectralDataPerSound>& OutSoundWaveSpectralData){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioComponent.GetCookedFFTDataForAllPlayingSounds");

	FGetCookedFFTDataForAllPlayingSounds parms{};	
	parms.OutSoundWaveSpectralData = OutSoundWaveSpectralData;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAudioComponent::GetCookedFFTData(struct TArray<float>& FrequenciesToGet, struct TArray<struct FSoundWaveSpectralData>& OutSoundWaveSpectralData){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioComponent.GetCookedFFTData");

	FGetCookedFFTData parms{};	
	parms.FrequenciesToGet = FrequenciesToGet;
	parms.OutSoundWaveSpectralData = OutSoundWaveSpectralData;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAudioComponent::GetCookedEnvelopeDataForAllPlayingSounds(struct TArray<struct FSoundWaveEnvelopeDataPerSound>& OutEnvelopeData){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioComponent.GetCookedEnvelopeDataForAllPlayingSounds");

	FGetCookedEnvelopeDataForAllPlayingSounds parms{};	
	parms.OutEnvelopeData = OutEnvelopeData;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAudioComponent::GetCookedEnvelopeData(float& OutEnvelopeData){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioComponent.GetCookedEnvelopeData");

	FGetCookedEnvelopeData parms{};	
	parms.OutEnvelopeData = OutEnvelopeData;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UAudioComponent::FadeOut(float FadeOutDuration, float FadeVolumeLevel, uint8_t FadeCurve){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioComponent.FadeOut");

	FFadeOut parms{};	
	parms.FadeOutDuration = FadeOutDuration;
	parms.FadeVolumeLevel = FadeVolumeLevel;
	parms.FadeCurve = FadeCurve;

	ProcessEvent(fn, &parms);
}

void UAudioComponent::FadeIn(float FadeInDuration, float FadeVolumeLevel, float StartTime, uint8_t FadeCurve){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioComponent.FadeIn");

	FFadeIn parms{};	
	parms.FadeInDuration = FadeInDuration;
	parms.FadeVolumeLevel = FadeVolumeLevel;
	parms.StartTime = StartTime;
	parms.FadeCurve = FadeCurve;

	ProcessEvent(fn, &parms);
}

bool UAudioComponent::BP_GetAttenuationSettingsToApply(struct FSoundAttenuationSettings& OutAttenuationSettings){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioComponent.BP_GetAttenuationSettingsToApply");

	FBP_GetAttenuationSettingsToApply parms{};	
	parms.OutAttenuationSettings = OutAttenuationSettings;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UAudioComponent::AdjustVolume(float AdjustVolumeDuration, float AdjustVolumeLevel, uint8_t FadeCurve){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioComponent.AdjustVolume");

	FAdjustVolume parms{};	
	parms.AdjustVolumeDuration = AdjustVolumeDuration;
	parms.AdjustVolumeLevel = AdjustVolumeLevel;
	parms.FadeCurve = FadeCurve;

	ProcessEvent(fn, &parms);
}

void UAudioComponent::AdjustAttenuation(struct FSoundAttenuationSettings& InAttenuationSettings){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioComponent.AdjustAttenuation");

	FAdjustAttenuation parms{};	
	parms.InAttenuationSettings = InAttenuationSettings;

	ProcessEvent(fn, &parms);
}

bool UExporter::ScriptRunAssetExportTask(struct UAssetExportTask* Task){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Exporter.ScriptRunAssetExportTask");

	FScriptRunAssetExportTask parms{};	
	parms.Task = Task;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UExporter::RunAssetExportTasks(struct TArray<struct UAssetExportTask*>& ExportTasks){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Exporter.RunAssetExportTasks");

	FRunAssetExportTasks parms{};	
	parms.ExportTasks = ExportTasks;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UExporter::RunAssetExportTask(struct UAssetExportTask* Task){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Exporter.RunAssetExportTask");

	FRunAssetExportTask parms{};	
	parms.Task = Task;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UCancellableAsyncAction::IsActive(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CancellableAsyncAction.IsActive");

	FIsActive parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UCancellableAsyncAction::Cancel(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CancellableAsyncAction.Cancel");

	FCancel parms{};	

	ProcessEvent(fn, &parms);
}

struct FText UKismetTextLibrary::TextTrimTrailing(struct FText& InText){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextTrimTrailing");

	FTextTrimTrailing parms{};	
	parms.InText = InText;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FText UKismetTextLibrary::TextTrimPrecedingAndTrailing(struct FText& InText){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextTrimPrecedingAndTrailing");

	FTextTrimPrecedingAndTrailing parms{};	
	parms.InText = InText;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FText UKismetTextLibrary::TextTrimPreceding(struct FText& InText){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextTrimPreceding");

	FTextTrimPreceding parms{};	
	parms.InText = InText;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FText UKismetTextLibrary::TextToUpper(struct FText& InText){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextToUpper");

	FTextToUpper parms{};	
	parms.InText = InText;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FText UKismetTextLibrary::TextToLower(struct FText& InText){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextToLower");

	FTextToLower parms{};	
	parms.InText = InText;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetTextLibrary::TextIsTransient(struct FText& InText){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextIsTransient");

	FTextIsTransient parms{};	
	parms.InText = InText;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetTextLibrary::TextIsFromStringTable(struct FText& Text){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextIsFromStringTable");

	FTextIsFromStringTable parms{};	
	parms.Text = Text;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetTextLibrary::TextIsEmpty(struct FText& InText){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextIsEmpty");

	FTextIsEmpty parms{};	
	parms.InText = InText;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetTextLibrary::TextIsCultureInvariant(struct FText& InText){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextIsCultureInvariant");

	FTextIsCultureInvariant parms{};	
	parms.InText = InText;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FText UKismetTextLibrary::TextFromStringTable(struct FName TableId, struct FString Key){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextFromStringTable");

	FTextFromStringTable parms{};	
	parms.TableId = TableId;
	parms.Key = Key;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetTextLibrary::StringTableIdAndKeyFromText(struct FText Text, struct FName& OutTableId, struct FString& OutKey){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.StringTableIdAndKeyFromText");

	FStringTableIdAndKeyFromText parms{};	
	parms.Text = Text;
	parms.OutTableId = OutTableId;
	parms.OutKey = OutKey;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FText UKismetTextLibrary::PolyglotDataToText(struct FPolyglotTextData& PolyglotData){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.PolyglotDataToText");

	FPolyglotDataToText parms{};	
	parms.PolyglotData = PolyglotData;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetTextLibrary::NotEqual_TextText(struct FText& A, struct FText& B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.NotEqual_TextText");

	FNotEqual_TextText parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetTextLibrary::NotEqual_IgnoreCase_TextText(struct FText& A, struct FText& B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.NotEqual_IgnoreCase_TextText");

	FNotEqual_IgnoreCase_TextText parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetTextLibrary::IsPolyglotDataValid(struct FPolyglotTextData& PolyglotData, bool& IsValid, struct FText& ErrorMessage){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.IsPolyglotDataValid");

	FIsPolyglotDataValid parms{};	
	parms.PolyglotData = PolyglotData;
	parms.IsValid = IsValid;
	parms.ErrorMessage = ErrorMessage;

	ProcessEvent(fn, &parms);
}

struct FText UKismetTextLibrary::GetEmptyText(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.GetEmptyText");

	FGetEmptyText parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FText UKismetTextLibrary::Format(struct FText InPattern, struct TArray<struct FFormatArgumentData> InArgs){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Format");

	FFormat parms{};	
	parms.InPattern = InPattern;
	parms.InArgs = InArgs;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetTextLibrary::FindTextInLocalizationTable(struct FString Namespace, struct FString Key, struct FText& OutText){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.FindTextInLocalizationTable");

	FFindTextInLocalizationTable parms{};	
	parms.Namespace = Namespace;
	parms.Key = Key;
	parms.OutText = OutText;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetTextLibrary::EqualEqual_TextText(struct FText& A, struct FText& B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.EqualEqual_TextText");

	FEqualEqual_TextText parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetTextLibrary::EqualEqual_IgnoreCase_TextText(struct FText& A, struct FText& B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.EqualEqual_IgnoreCase_TextText");

	FEqualEqual_IgnoreCase_TextText parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FText UKismetTextLibrary::Conv_VectorToText(struct FVector InVec){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_VectorToText");

	FConv_VectorToText parms{};	
	parms.InVec = InVec;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FText UKismetTextLibrary::Conv_Vector2dToText(struct FVector2D InVec){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_Vector2dToText");

	FConv_Vector2dToText parms{};	
	parms.InVec = InVec;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FText UKismetTextLibrary::Conv_TransformToText(struct FTransform& InTrans){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_TransformToText");

	FConv_TransformToText parms{};	
	parms.InTrans = InTrans;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetTextLibrary::Conv_TextToString(struct FText& InText){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_TextToString");

	FConv_TextToString parms{};	
	parms.InText = InText;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FText UKismetTextLibrary::Conv_StringToText(struct FString InString){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_StringToText");

	FConv_StringToText parms{};	
	parms.InString = InString;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FText UKismetTextLibrary::Conv_RotatorToText(struct FRotator InRot){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_RotatorToText");

	FConv_RotatorToText parms{};	
	parms.InRot = InRot;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FText UKismetTextLibrary::Conv_ObjectToText(struct UObject* InObj){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_ObjectToText");

	FConv_ObjectToText parms{};	
	parms.InObj = InObj;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FText UKismetTextLibrary::Conv_NameToText(struct FName InName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_NameToText");

	FConv_NameToText parms{};	
	parms.InName = InName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FText UKismetTextLibrary::Conv_IntToText(int32_t Value, bool bAlwaysSign, bool bUseGrouping, int32_t MinimumIntegralDigits, int32_t MaximumIntegralDigits){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_IntToText");

	FConv_IntToText parms{};	
	parms.Value = Value;
	parms.bAlwaysSign = bAlwaysSign;
	parms.bUseGrouping = bUseGrouping;
	parms.MinimumIntegralDigits = MinimumIntegralDigits;
	parms.MaximumIntegralDigits = MaximumIntegralDigits;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FText UKismetTextLibrary::Conv_Int64ToText(int64_t Value, bool bAlwaysSign, bool bUseGrouping, int32_t MinimumIntegralDigits, int32_t MaximumIntegralDigits){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_Int64ToText");

	FConv_Int64ToText parms{};	
	parms.Value = Value;
	parms.bAlwaysSign = bAlwaysSign;
	parms.bUseGrouping = bUseGrouping;
	parms.MinimumIntegralDigits = MinimumIntegralDigits;
	parms.MaximumIntegralDigits = MaximumIntegralDigits;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FText UKismetTextLibrary::Conv_DoubleToText(double Value, enum class ERoundingMode RoundingMode, bool bAlwaysSign, bool bUseGrouping, int32_t MinimumIntegralDigits, int32_t MaximumIntegralDigits, int32_t MinimumFractionalDigits, int32_t MaximumFractionalDigits){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_DoubleToText");

	FConv_DoubleToText parms{};	
	parms.Value = Value;
	parms.RoundingMode = RoundingMode;
	parms.bAlwaysSign = bAlwaysSign;
	parms.bUseGrouping = bUseGrouping;
	parms.MinimumIntegralDigits = MinimumIntegralDigits;
	parms.MaximumIntegralDigits = MaximumIntegralDigits;
	parms.MinimumFractionalDigits = MinimumFractionalDigits;
	parms.MaximumFractionalDigits = MaximumFractionalDigits;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FText UKismetTextLibrary::Conv_ColorToText(struct FLinearColor InColor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_ColorToText");

	FConv_ColorToText parms{};	
	parms.InColor = InColor;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FText UKismetTextLibrary::Conv_ByteToText(char Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_ByteToText");

	FConv_ByteToText parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FText UKismetTextLibrary::Conv_BoolToText(bool InBool){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_BoolToText");

	FConv_BoolToText parms{};	
	parms.InBool = InBool;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FText UKismetTextLibrary::AsTimeZoneTime_DateTime(struct FDateTime& InDateTime, struct FString InTimeZone){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsTimeZoneTime_DateTime");

	FAsTimeZoneTime_DateTime parms{};	
	parms.InDateTime = InDateTime;
	parms.InTimeZone = InTimeZone;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FText UKismetTextLibrary::AsTimeZoneDateTime_DateTime(struct FDateTime& InDateTime, struct FString InTimeZone){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsTimeZoneDateTime_DateTime");

	FAsTimeZoneDateTime_DateTime parms{};	
	parms.InDateTime = InDateTime;
	parms.InTimeZone = InTimeZone;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FText UKismetTextLibrary::AsTimeZoneDate_DateTime(struct FDateTime& InDateTime, struct FString InTimeZone){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsTimeZoneDate_DateTime");

	FAsTimeZoneDate_DateTime parms{};	
	parms.InDateTime = InDateTime;
	parms.InTimeZone = InTimeZone;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FText UKismetTextLibrary::AsTimespan_Timespan(struct FTimespan& InTimespan){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsTimespan_Timespan");

	FAsTimespan_Timespan parms{};	
	parms.InTimespan = InTimespan;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FText UKismetTextLibrary::AsTime_DateTime(struct FDateTime& In){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsTime_DateTime");

	FAsTime_DateTime parms{};	
	parms.In = In;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FText UKismetTextLibrary::AsPercent_Float(float Value, enum class ERoundingMode RoundingMode, bool bAlwaysSign, bool bUseGrouping, int32_t MinimumIntegralDigits, int32_t MaximumIntegralDigits, int32_t MinimumFractionalDigits, int32_t MaximumFractionalDigits){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsPercent_Float");

	FAsPercent_Float parms{};	
	parms.Value = Value;
	parms.RoundingMode = RoundingMode;
	parms.bAlwaysSign = bAlwaysSign;
	parms.bUseGrouping = bUseGrouping;
	parms.MinimumIntegralDigits = MinimumIntegralDigits;
	parms.MaximumIntegralDigits = MaximumIntegralDigits;
	parms.MinimumFractionalDigits = MinimumFractionalDigits;
	parms.MaximumFractionalDigits = MaximumFractionalDigits;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FText UKismetTextLibrary::AsDateTime_DateTime(struct FDateTime& In){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsDateTime_DateTime");

	FAsDateTime_DateTime parms{};	
	parms.In = In;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FText UKismetTextLibrary::AsDate_DateTime(struct FDateTime& InDateTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsDate_DateTime");

	FAsDate_DateTime parms{};	
	parms.InDateTime = InDateTime;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FText UKismetTextLibrary::AsCurrencyBase(int32_t BaseValue, struct FString CurrencyCode){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsCurrencyBase");

	FAsCurrencyBase parms{};	
	parms.BaseValue = BaseValue;
	parms.CurrencyCode = CurrencyCode;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FText UKismetTextLibrary::AsCurrency_Integer(int32_t Value, enum class ERoundingMode RoundingMode, bool bAlwaysSign, bool bUseGrouping, int32_t MinimumIntegralDigits, int32_t MaximumIntegralDigits, int32_t MinimumFractionalDigits, int32_t MaximumFractionalDigits, struct FString CurrencyCode){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsCurrency_Integer");

	FAsCurrency_Integer parms{};	
	parms.Value = Value;
	parms.RoundingMode = RoundingMode;
	parms.bAlwaysSign = bAlwaysSign;
	parms.bUseGrouping = bUseGrouping;
	parms.MinimumIntegralDigits = MinimumIntegralDigits;
	parms.MaximumIntegralDigits = MaximumIntegralDigits;
	parms.MinimumFractionalDigits = MinimumFractionalDigits;
	parms.MaximumFractionalDigits = MaximumFractionalDigits;
	parms.CurrencyCode = CurrencyCode;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FText UKismetTextLibrary::AsCurrency_Float(float Value, enum class ERoundingMode RoundingMode, bool bAlwaysSign, bool bUseGrouping, int32_t MinimumIntegralDigits, int32_t MaximumIntegralDigits, int32_t MinimumFractionalDigits, int32_t MaximumFractionalDigits, struct FString CurrencyCode){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsCurrency_Float");

	FAsCurrency_Float parms{};	
	parms.Value = Value;
	parms.RoundingMode = RoundingMode;
	parms.bAlwaysSign = bAlwaysSign;
	parms.bUseGrouping = bUseGrouping;
	parms.MinimumIntegralDigits = MinimumIntegralDigits;
	parms.MaximumIntegralDigits = MaximumIntegralDigits;
	parms.MinimumFractionalDigits = MinimumFractionalDigits;
	parms.MaximumFractionalDigits = MaximumFractionalDigits;
	parms.CurrencyCode = CurrencyCode;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void APawn::SpawnDefaultController(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Pawn.SpawnDefaultController");

	FSpawnDefaultController parms{};	

	ProcessEvent(fn, &parms);
}

void APawn::SetCanAffectNavigationGeneration(bool bNewValue, bool bForceUpdate){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Pawn.SetCanAffectNavigationGeneration");

	FSetCanAffectNavigationGeneration parms{};	
	parms.bNewValue = bNewValue;
	parms.bForceUpdate = bForceUpdate;

	ProcessEvent(fn, &parms);
}

void APawn::ReceiveUnpossessed(struct AController* OldController){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Pawn.ReceiveUnpossessed");

	FReceiveUnpossessed parms{};	
	parms.OldController = OldController;

	ProcessEvent(fn, &parms);
}

void APawn::ReceiveRestarted(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Pawn.ReceiveRestarted");

	FReceiveRestarted parms{};	

	ProcessEvent(fn, &parms);
}

void APawn::ReceivePossessed(struct AController* NewController){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Pawn.ReceivePossessed");

	FReceivePossessed parms{};	
	parms.NewController = NewController;

	ProcessEvent(fn, &parms);
}

void APawn::ReceiveControllerChanged(struct AController* OldController, struct AController* NewController){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Pawn.ReceiveControllerChanged");

	FReceiveControllerChanged parms{};	
	parms.OldController = OldController;
	parms.NewController = NewController;

	ProcessEvent(fn, &parms);
}

void APawn::PawnMakeNoise(float Loudness, struct FVector NoiseLocation, bool bUseNoiseMakerLocation, struct AActor* NoiseMaker){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Pawn.PawnMakeNoise");

	FPawnMakeNoise parms{};	
	parms.Loudness = Loudness;
	parms.NoiseLocation = NoiseLocation;
	parms.bUseNoiseMakerLocation = bUseNoiseMakerLocation;
	parms.NoiseMaker = NoiseMaker;

	ProcessEvent(fn, &parms);
}

void APawn::OnRep_PlayerState(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Pawn.OnRep_PlayerState");

	FOnRep_PlayerState parms{};	

	ProcessEvent(fn, &parms);
}

void APawn::OnRep_Controller(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Pawn.OnRep_Controller");

	FOnRep_Controller parms{};	

	ProcessEvent(fn, &parms);
}

bool APawn::IsPlayerControlled(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Pawn.IsPlayerControlled");

	FIsPlayerControlled parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool APawn::IsPawnControlled(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Pawn.IsPawnControlled");

	FIsPawnControlled parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool APawn::IsMoveInputIgnored(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Pawn.IsMoveInputIgnored");

	FIsMoveInputIgnored parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool APawn::IsLocallyViewed(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Pawn.IsLocallyViewed");

	FIsLocallyViewed parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool APawn::IsLocallyControlled(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Pawn.IsLocallyControlled");

	FIsLocallyControlled parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool APawn::IsControlled(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Pawn.IsControlled");

	FIsControlled parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool APawn::IsBotControlled(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Pawn.IsBotControlled");

	FIsBotControlled parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector APawn::GetPendingMovementInputVector(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Pawn.GetPendingMovementInputVector");

	FGetPendingMovementInputVector parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

UInputComponent* APawn::GetOverrideInputComponentClass(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Pawn.GetOverrideInputComponentClass");

	FGetOverrideInputComponentClass parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector APawn::GetNavAgentLocation(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Pawn.GetNavAgentLocation");

	FGetNavAgentLocation parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UPawnMovementComponent* APawn::GetMovementComponent(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Pawn.GetMovementComponent");

	FGetMovementComponent parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct AActor* APawn::GetMovementBaseActor(struct APawn* Pawn){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Pawn.GetMovementBaseActor");

	FGetMovementBaseActor parms{};	
	parms.Pawn = Pawn;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct APlayerController* APawn::GetLocalViewingPlayerController(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Pawn.GetLocalViewingPlayerController");

	FGetLocalViewingPlayerController parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector APawn::GetLastMovementInputVector(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Pawn.GetLastMovementInputVector");

	FGetLastMovementInputVector parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator APawn::GetControlRotation(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Pawn.GetControlRotation");

	FGetControlRotation parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct AController* APawn::GetController(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Pawn.GetController");

	FGetController parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator APawn::GetBaseAimRotation(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Pawn.GetBaseAimRotation");

	FGetBaseAimRotation parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void APawn::DetachFromControllerPendingDestroy(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Pawn.DetachFromControllerPendingDestroy");

	FDetachFromControllerPendingDestroy parms{};	

	ProcessEvent(fn, &parms);
}

struct FVector APawn::ConsumeMovementInputVector(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Pawn.ConsumeMovementInputVector");

	FConsumeMovementInputVector parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void APawn::AddMovementInput(struct FVector WorldDirection, float ScaleValue, bool bForce){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Pawn.AddMovementInput");

	FAddMovementInput parms{};	
	parms.WorldDirection = WorldDirection;
	parms.ScaleValue = ScaleValue;
	parms.bForce = bForce;

	ProcessEvent(fn, &parms);
}

void APawn::AddControllerYawInput(float Val){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Pawn.AddControllerYawInput");

	FAddControllerYawInput parms{};	
	parms.Val = Val;

	ProcessEvent(fn, &parms);
}

void APawn::AddControllerRollInput(float Val){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Pawn.AddControllerRollInput");

	FAddControllerRollInput parms{};	
	parms.Val = Val;

	ProcessEvent(fn, &parms);
}

void APawn::AddControllerPitchInput(float Val){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Pawn.AddControllerPitchInput");

	FAddControllerPitchInput parms{};	
	parms.Val = Val;

	ProcessEvent(fn, &parms);
}

void UActorComponent::ToggleActive(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ActorComponent.ToggleActive");

	FToggleActive parms{};	

	ProcessEvent(fn, &parms);
}

void UActorComponent::SetTickGroup(enum class ETickingGroup NewTickGroup){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ActorComponent.SetTickGroup");

	FSetTickGroup parms{};	
	parms.NewTickGroup = NewTickGroup;

	ProcessEvent(fn, &parms);
}

void UActorComponent::SetTickableWhenPaused(bool bTickableWhenPaused){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ActorComponent.SetTickableWhenPaused");

	FSetTickableWhenPaused parms{};	
	parms.bTickableWhenPaused = bTickableWhenPaused;

	ProcessEvent(fn, &parms);
}

void UActorComponent::SetIsReplicated(bool ShouldReplicate){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ActorComponent.SetIsReplicated");

	FSetIsReplicated parms{};	
	parms.ShouldReplicate = ShouldReplicate;

	ProcessEvent(fn, &parms);
}

void UActorComponent::SetComponentTickIntervalAndCooldown(float TickInterval){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ActorComponent.SetComponentTickIntervalAndCooldown");

	FSetComponentTickIntervalAndCooldown parms{};	
	parms.TickInterval = TickInterval;

	ProcessEvent(fn, &parms);
}

void UActorComponent::SetComponentTickInterval(float TickInterval){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ActorComponent.SetComponentTickInterval");

	FSetComponentTickInterval parms{};	
	parms.TickInterval = TickInterval;

	ProcessEvent(fn, &parms);
}

void UActorComponent::SetComponentTickEnabled(bool bEnabled){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ActorComponent.SetComponentTickEnabled");

	FSetComponentTickEnabled parms{};	
	parms.bEnabled = bEnabled;

	ProcessEvent(fn, &parms);
}

void UActorComponent::SetAutoActivate(bool bNewAutoActivate){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ActorComponent.SetAutoActivate");

	FSetAutoActivate parms{};	
	parms.bNewAutoActivate = bNewAutoActivate;

	ProcessEvent(fn, &parms);
}

void UActorComponent::SetActive(bool bNewActive, bool bReset){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ActorComponent.SetActive");

	FSetActive parms{};	
	parms.bNewActive = bNewActive;
	parms.bReset = bReset;

	ProcessEvent(fn, &parms);
}

void UActorComponent::RemoveTickPrerequisiteComponent(struct UActorComponent* PrerequisiteComponent){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ActorComponent.RemoveTickPrerequisiteComponent");

	FRemoveTickPrerequisiteComponent parms{};	
	parms.PrerequisiteComponent = PrerequisiteComponent;

	ProcessEvent(fn, &parms);
}

void UActorComponent::RemoveTickPrerequisiteActor(struct AActor* PrerequisiteActor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ActorComponent.RemoveTickPrerequisiteActor");

	FRemoveTickPrerequisiteActor parms{};	
	parms.PrerequisiteActor = PrerequisiteActor;

	ProcessEvent(fn, &parms);
}

void UActorComponent::ReceiveTick(float DeltaSeconds){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ActorComponent.ReceiveTick");

	FReceiveTick parms{};	
	parms.DeltaSeconds = DeltaSeconds;

	ProcessEvent(fn, &parms);
}

void UActorComponent::ReceiveEndPlay(enum class EEndPlayReason EndPlayReason){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ActorComponent.ReceiveEndPlay");

	FReceiveEndPlay parms{};	
	parms.EndPlayReason = EndPlayReason;

	ProcessEvent(fn, &parms);
}

void UActorComponent::ReceiveBeginPlay(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ActorComponent.ReceiveBeginPlay");

	FReceiveBeginPlay parms{};	

	ProcessEvent(fn, &parms);
}

void UActorComponent::ReceiveAsyncPhysicsTick(float DeltaSeconds, float SimSeconds){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ActorComponent.ReceiveAsyncPhysicsTick");

	FReceiveAsyncPhysicsTick parms{};	
	parms.DeltaSeconds = DeltaSeconds;
	parms.SimSeconds = SimSeconds;

	ProcessEvent(fn, &parms);
}

void UActorComponent::OnRep_IsActive(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ActorComponent.OnRep_IsActive");

	FOnRep_IsActive parms{};	

	ProcessEvent(fn, &parms);
}

void UActorComponent::K2_DestroyComponent(struct UObject* Object){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ActorComponent.K2_DestroyComponent");

	FK2_DestroyComponent parms{};	
	parms.Object = Object;

	ProcessEvent(fn, &parms);
}

bool UActorComponent::IsComponentTickEnabled(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ActorComponent.IsComponentTickEnabled");

	FIsComponentTickEnabled parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UActorComponent::IsBeingDestroyed(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ActorComponent.IsBeingDestroyed");

	FIsBeingDestroyed parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UActorComponent::IsActive(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ActorComponent.IsActive");

	FIsActive parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct AActor* UActorComponent::GetOwner(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ActorComponent.GetOwner");

	FGetOwner parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UActorComponent::GetComponentTickInterval(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ActorComponent.GetComponentTickInterval");

	FGetComponentTickInterval parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UActorComponent::Deactivate(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ActorComponent.Deactivate");

	FDeactivate parms{};	

	ProcessEvent(fn, &parms);
}

bool UActorComponent::ComponentHasTag(struct FName Tag){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ActorComponent.ComponentHasTag");

	FComponentHasTag parms{};	
	parms.Tag = Tag;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UActorComponent::AddTickPrerequisiteComponent(struct UActorComponent* PrerequisiteComponent){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ActorComponent.AddTickPrerequisiteComponent");

	FAddTickPrerequisiteComponent parms{};	
	parms.PrerequisiteComponent = PrerequisiteComponent;

	ProcessEvent(fn, &parms);
}

void UActorComponent::AddTickPrerequisiteActor(struct AActor* PrerequisiteActor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ActorComponent.AddTickPrerequisiteActor");

	FAddTickPrerequisiteActor parms{};	
	parms.PrerequisiteActor = PrerequisiteActor;

	ProcessEvent(fn, &parms);
}

void UActorComponent::Activate(bool bReset){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ActorComponent.Activate");

	FActivate parms{};	
	parms.bReset = bReset;

	ProcessEvent(fn, &parms);
}

void ADefaultPawn::TurnAtRate(float Rate){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DefaultPawn.TurnAtRate");

	FTurnAtRate parms{};	
	parms.Rate = Rate;

	ProcessEvent(fn, &parms);
}

void ADefaultPawn::MoveUp_World(float Val){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DefaultPawn.MoveUp_World");

	FMoveUp_World parms{};	
	parms.Val = Val;

	ProcessEvent(fn, &parms);
}

void ADefaultPawn::MoveRight(float Val){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DefaultPawn.MoveRight");

	FMoveRight parms{};	
	parms.Val = Val;

	ProcessEvent(fn, &parms);
}

void ADefaultPawn::MoveForward(float Val){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DefaultPawn.MoveForward");

	FMoveForward parms{};	
	parms.Val = Val;

	ProcessEvent(fn, &parms);
}

void ADefaultPawn::LookUpAtRate(float Rate){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DefaultPawn.LookUpAtRate");

	FLookUpAtRate parms{};	
	parms.Rate = Rate;

	ProcessEvent(fn, &parms);
}

bool UAnimNotify::Received_Notify(struct USkeletalMeshComponent* MeshComp, struct UAnimSequenceBase* Animation, struct FAnimNotifyEventReference& EventReference){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimNotify.Received_Notify");

	FReceived_Notify parms{};	
	parms.MeshComp = MeshComp;
	parms.Animation = Animation;
	parms.EventReference = EventReference;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UAnimNotify::GetNotifyName(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimNotify.GetNotifyName");

	FGetNotifyName parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UAnimNotify::GetDefaultTriggerWeightThreshold(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimNotify.GetDefaultTriggerWeightThreshold");

	FGetDefaultTriggerWeightThreshold parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimNotifyState::Received_NotifyTick(struct USkeletalMeshComponent* MeshComp, struct UAnimSequenceBase* Animation, float FrameDeltaTime, struct FAnimNotifyEventReference& EventReference){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimNotifyState.Received_NotifyTick");

	FReceived_NotifyTick parms{};	
	parms.MeshComp = MeshComp;
	parms.Animation = Animation;
	parms.FrameDeltaTime = FrameDeltaTime;
	parms.EventReference = EventReference;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimNotifyState::Received_NotifyEnd(struct USkeletalMeshComponent* MeshComp, struct UAnimSequenceBase* Animation, struct FAnimNotifyEventReference& EventReference){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimNotifyState.Received_NotifyEnd");

	FReceived_NotifyEnd parms{};	
	parms.MeshComp = MeshComp;
	parms.Animation = Animation;
	parms.EventReference = EventReference;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimNotifyState::Received_NotifyBegin(struct USkeletalMeshComponent* MeshComp, struct UAnimSequenceBase* Animation, float TotalDuration, struct FAnimNotifyEventReference& EventReference){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimNotifyState.Received_NotifyBegin");

	FReceived_NotifyBegin parms{};	
	parms.MeshComp = MeshComp;
	parms.Animation = Animation;
	parms.TotalDuration = TotalDuration;
	parms.EventReference = EventReference;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UAnimNotifyState::GetNotifyName(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimNotifyState.GetNotifyName");

	FGetNotifyName parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UAnimNotifyState::GetDefaultTriggerWeightThreshold(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimNotifyState.GetDefaultTriggerWeightThreshold");

	FGetDefaultTriggerWeightThreshold parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UPrimitiveComponent::WasRecentlyRendered(float Tolerance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.WasRecentlyRendered");

	FWasRecentlyRendered parms{};	
	parms.Tolerance = Tolerance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UPrimitiveComponent::WakeRigidBody(struct FName BoneName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.WakeRigidBody");

	FWakeRigidBody parms{};	
	parms.BoneName = BoneName;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::WakeAllRigidBodies(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.WakeAllRigidBodies");

	FWakeAllRigidBodies parms{};	

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetWalkableSlopeOverride(struct FWalkableSlopeOverride& NewOverride){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetWalkableSlopeOverride");

	FSetWalkableSlopeOverride parms{};	
	parms.NewOverride = NewOverride;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetVisibleInSceneCaptureOnly(bool bValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetVisibleInSceneCaptureOnly");

	FSetVisibleInSceneCaptureOnly parms{};	
	parms.bValue = bValue;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetVisibleInRayTracing(bool bNewVisibleInRayTracing){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetVisibleInRayTracing");

	FSetVisibleInRayTracing parms{};	
	parms.bNewVisibleInRayTracing = bNewVisibleInRayTracing;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetVectorParameterForDefaultCustomPrimitiveData(struct FName ParameterName, struct FVector4 Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetVectorParameterForDefaultCustomPrimitiveData");

	FSetVectorParameterForDefaultCustomPrimitiveData parms{};	
	parms.ParameterName = ParameterName;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetVectorParameterForCustomPrimitiveData(struct FName ParameterName, struct FVector4 Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetVectorParameterForCustomPrimitiveData");

	FSetVectorParameterForCustomPrimitiveData parms{};	
	parms.ParameterName = ParameterName;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetUseCCD(bool InUseCCD, struct FName BoneName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetUseCCD");

	FSetUseCCD parms{};	
	parms.InUseCCD = InUseCCD;
	parms.BoneName = BoneName;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetTranslucentSortPriority(int32_t NewTranslucentSortPriority){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetTranslucentSortPriority");

	FSetTranslucentSortPriority parms{};	
	parms.NewTranslucentSortPriority = NewTranslucentSortPriority;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetTranslucencySortDistanceOffset(float NewTranslucencySortDistanceOffset){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetTranslucencySortDistanceOffset");

	FSetTranslucencySortDistanceOffset parms{};	
	parms.NewTranslucencySortDistanceOffset = NewTranslucencySortDistanceOffset;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetSingleSampleShadowFromStationaryLights(bool bNewSingleSampleShadowFromStationaryLights){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetSingleSampleShadowFromStationaryLights");

	FSetSingleSampleShadowFromStationaryLights parms{};	
	parms.bNewSingleSampleShadowFromStationaryLights = bNewSingleSampleShadowFromStationaryLights;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetSimulatePhysics(bool bSimulate){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetSimulatePhysics");

	FSetSimulatePhysics parms{};	
	parms.bSimulate = bSimulate;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetScalarParameterForDefaultCustomPrimitiveData(struct FName ParameterName, float Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetScalarParameterForDefaultCustomPrimitiveData");

	FSetScalarParameterForDefaultCustomPrimitiveData parms{};	
	parms.ParameterName = ParameterName;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetScalarParameterForCustomPrimitiveData(struct FName ParameterName, float Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetScalarParameterForCustomPrimitiveData");

	FSetScalarParameterForCustomPrimitiveData parms{};	
	parms.ParameterName = ParameterName;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetRenderInMainPass(bool bValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetRenderInMainPass");

	FSetRenderInMainPass parms{};	
	parms.bValue = bValue;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetRenderInDepthPass(bool bValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetRenderInDepthPass");

	FSetRenderInDepthPass parms{};	
	parms.bValue = bValue;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetRenderCustomDepth(bool bValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetRenderCustomDepth");

	FSetRenderCustomDepth parms{};	
	parms.bValue = bValue;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetReceivesDecals(bool bNewReceivesDecals){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetReceivesDecals");

	FSetReceivesDecals parms{};	
	parms.bNewReceivesDecals = bNewReceivesDecals;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetPhysMaterialOverride(struct UPhysicalMaterial* NewPhysMaterial){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetPhysMaterialOverride");

	FSetPhysMaterialOverride parms{};	
	parms.NewPhysMaterial = NewPhysMaterial;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetPhysicsMaxAngularVelocityInRadians(float NewMaxAngVel, bool bAddToCurrent, struct FName BoneName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetPhysicsMaxAngularVelocityInRadians");

	FSetPhysicsMaxAngularVelocityInRadians parms{};	
	parms.NewMaxAngVel = NewMaxAngVel;
	parms.bAddToCurrent = bAddToCurrent;
	parms.BoneName = BoneName;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetPhysicsMaxAngularVelocityInDegrees(float NewMaxAngVel, bool bAddToCurrent, struct FName BoneName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetPhysicsMaxAngularVelocityInDegrees");

	FSetPhysicsMaxAngularVelocityInDegrees parms{};	
	parms.NewMaxAngVel = NewMaxAngVel;
	parms.bAddToCurrent = bAddToCurrent;
	parms.BoneName = BoneName;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetPhysicsLinearVelocity(struct FVector NewVel, bool bAddToCurrent, struct FName BoneName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetPhysicsLinearVelocity");

	FSetPhysicsLinearVelocity parms{};	
	parms.NewVel = NewVel;
	parms.bAddToCurrent = bAddToCurrent;
	parms.BoneName = BoneName;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetPhysicsAngularVelocityInRadians(struct FVector NewAngVel, bool bAddToCurrent, struct FName BoneName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetPhysicsAngularVelocityInRadians");

	FSetPhysicsAngularVelocityInRadians parms{};	
	parms.NewAngVel = NewAngVel;
	parms.bAddToCurrent = bAddToCurrent;
	parms.BoneName = BoneName;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetPhysicsAngularVelocityInDegrees(struct FVector NewAngVel, bool bAddToCurrent, struct FName BoneName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetPhysicsAngularVelocityInDegrees");

	FSetPhysicsAngularVelocityInDegrees parms{};	
	parms.NewAngVel = NewAngVel;
	parms.bAddToCurrent = bAddToCurrent;
	parms.BoneName = BoneName;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetOwnerNoSee(bool bNewOwnerNoSee){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetOwnerNoSee");

	FSetOwnerNoSee parms{};	
	parms.bNewOwnerNoSee = bNewOwnerNoSee;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetOnlyOwnerSee(bool bNewOnlyOwnerSee){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetOnlyOwnerSee");

	FSetOnlyOwnerSee parms{};	
	parms.bNewOnlyOwnerSee = bNewOnlyOwnerSee;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetNotifyRigidBodyCollision(bool bNewNotifyRigidBodyCollision){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetNotifyRigidBodyCollision");

	FSetNotifyRigidBodyCollision parms{};	
	parms.bNewNotifyRigidBodyCollision = bNewNotifyRigidBodyCollision;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetMaterialByName(struct FName MaterialSlotName, struct UMaterialInterface* Material){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetMaterialByName");

	FSetMaterialByName parms{};	
	parms.MaterialSlotName = MaterialSlotName;
	parms.Material = Material;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetMaterial(int32_t ElementIndex, struct UMaterialInterface* Material){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetMaterial");

	FSetMaterial parms{};	
	parms.ElementIndex = ElementIndex;
	parms.Material = Material;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetMassScale(struct FName BoneName, float InMassScale){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetMassScale");

	FSetMassScale parms{};	
	parms.BoneName = BoneName;
	parms.InMassScale = InMassScale;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetMassOverrideInKg(struct FName BoneName, float MassInKg, bool bOverrideMass){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetMassOverrideInKg");

	FSetMassOverrideInKg parms{};	
	parms.BoneName = BoneName;
	parms.MassInKg = MassInKg;
	parms.bOverrideMass = bOverrideMass;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetLinearDamping(float InDamping){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetLinearDamping");

	FSetLinearDamping parms{};	
	parms.InDamping = InDamping;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetLightingChannels(bool bChannel0, bool bChannel1, bool bChannel2){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetLightingChannels");

	FSetLightingChannels parms{};	
	parms.bChannel0 = bChannel0;
	parms.bChannel1 = bChannel1;
	parms.bChannel2 = bChannel2;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetLightAttachmentsAsGroup(bool bInLightAttachmentsAsGroup){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetLightAttachmentsAsGroup");

	FSetLightAttachmentsAsGroup parms{};	
	parms.bInLightAttachmentsAsGroup = bInLightAttachmentsAsGroup;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetHiddenInSceneCapture(bool bValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetHiddenInSceneCapture");

	FSetHiddenInSceneCapture parms{};	
	parms.bValue = bValue;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetGenerateOverlapEvents(bool bInGenerateOverlapEvents){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetGenerateOverlapEvents");

	FSetGenerateOverlapEvents parms{};	
	parms.bInGenerateOverlapEvents = bInGenerateOverlapEvents;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetExcludeFromLightAttachmentGroup(bool bInExcludeFromLightAttachmentGroup){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetExcludeFromLightAttachmentGroup");

	FSetExcludeFromLightAttachmentGroup parms{};	
	parms.bInExcludeFromLightAttachmentGroup = bInExcludeFromLightAttachmentGroup;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetEnableGravity(bool bGravityEnabled){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetEnableGravity");

	FSetEnableGravity parms{};	
	parms.bGravityEnabled = bGravityEnabled;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetEmissiveLightSource(bool NewEmissiveLightSource){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetEmissiveLightSource");

	FSetEmissiveLightSource parms{};	
	parms.NewEmissiveLightSource = NewEmissiveLightSource;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetDefaultCustomPrimitiveDataVector4(int32_t DataIndex, struct FVector4 Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetDefaultCustomPrimitiveDataVector4");

	FSetDefaultCustomPrimitiveDataVector4 parms{};	
	parms.DataIndex = DataIndex;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetDefaultCustomPrimitiveDataVector3(int32_t DataIndex, struct FVector Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetDefaultCustomPrimitiveDataVector3");

	FSetDefaultCustomPrimitiveDataVector3 parms{};	
	parms.DataIndex = DataIndex;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetDefaultCustomPrimitiveDataVector2(int32_t DataIndex, struct FVector2D Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetDefaultCustomPrimitiveDataVector2");

	FSetDefaultCustomPrimitiveDataVector2 parms{};	
	parms.DataIndex = DataIndex;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetDefaultCustomPrimitiveDataFloat(int32_t DataIndex, float Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetDefaultCustomPrimitiveDataFloat");

	FSetDefaultCustomPrimitiveDataFloat parms{};	
	parms.DataIndex = DataIndex;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetCustomPrimitiveDataVector4(int32_t DataIndex, struct FVector4 Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCustomPrimitiveDataVector4");

	FSetCustomPrimitiveDataVector4 parms{};	
	parms.DataIndex = DataIndex;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetCustomPrimitiveDataVector3(int32_t DataIndex, struct FVector Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCustomPrimitiveDataVector3");

	FSetCustomPrimitiveDataVector3 parms{};	
	parms.DataIndex = DataIndex;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetCustomPrimitiveDataVector2(int32_t DataIndex, struct FVector2D Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCustomPrimitiveDataVector2");

	FSetCustomPrimitiveDataVector2 parms{};	
	parms.DataIndex = DataIndex;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetCustomPrimitiveDataFloat(int32_t DataIndex, float Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCustomPrimitiveDataFloat");

	FSetCustomPrimitiveDataFloat parms{};	
	parms.DataIndex = DataIndex;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetCustomDepthStencilWriteMask(uint8_t WriteMaskBit){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCustomDepthStencilWriteMask");

	FSetCustomDepthStencilWriteMask parms{};	
	parms.WriteMaskBit = WriteMaskBit;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetCustomDepthStencilValue(int32_t Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCustomDepthStencilValue");

	FSetCustomDepthStencilValue parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetCullDistance(float NewCullDistance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCullDistance");

	FSetCullDistance parms{};	
	parms.NewCullDistance = NewCullDistance;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetConstraintMode(enum class EDOFMode ConstraintMode){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetConstraintMode");

	FSetConstraintMode parms{};	
	parms.ConstraintMode = ConstraintMode;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetCollisionResponseToChannel(enum class ECollisionChannel Channel, enum class ECollisionResponse NewResponse){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCollisionResponseToChannel");

	FSetCollisionResponseToChannel parms{};	
	parms.Channel = Channel;
	parms.NewResponse = NewResponse;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetCollisionResponseToAllChannels(enum class ECollisionResponse NewResponse){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCollisionResponseToAllChannels");

	FSetCollisionResponseToAllChannels parms{};	
	parms.NewResponse = NewResponse;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetCollisionProfileName(struct FName InCollisionProfileName, bool bUpdateOverlaps){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCollisionProfileName");

	FSetCollisionProfileName parms{};	
	parms.InCollisionProfileName = InCollisionProfileName;
	parms.bUpdateOverlaps = bUpdateOverlaps;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetCollisionObjectType(enum class ECollisionChannel Channel){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCollisionObjectType");

	FSetCollisionObjectType parms{};	
	parms.Channel = Channel;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetCollisionEnabled(enum class ECollisionEnabled NewType){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCollisionEnabled");

	FSetCollisionEnabled parms{};	
	parms.NewType = NewType;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetCenterOfMass(struct FVector CenterOfMassOffset, struct FName BoneName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCenterOfMass");

	FSetCenterOfMass parms{};	
	parms.CenterOfMassOffset = CenterOfMassOffset;
	parms.BoneName = BoneName;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetCastShadow(bool NewCastShadow){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCastShadow");

	FSetCastShadow parms{};	
	parms.NewCastShadow = NewCastShadow;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetCastInsetShadow(bool bInCastInsetShadow){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCastInsetShadow");

	FSetCastInsetShadow parms{};	
	parms.bInCastInsetShadow = bInCastInsetShadow;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetCastHiddenShadow(bool NewCastHiddenShadow){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCastHiddenShadow");

	FSetCastHiddenShadow parms{};	
	parms.NewCastHiddenShadow = NewCastHiddenShadow;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetCastContactShadow(bool bInCastContactShadow){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCastContactShadow");

	FSetCastContactShadow parms{};	
	parms.bInCastContactShadow = bInCastContactShadow;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetBoundsScale(float NewBoundsScale){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetBoundsScale");

	FSetBoundsScale parms{};	
	parms.NewBoundsScale = NewBoundsScale;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetAngularDamping(float InDamping){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetAngularDamping");

	FSetAngularDamping parms{};	
	parms.InDamping = InDamping;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetAllUseCCD(bool InUseCCD){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetAllUseCCD");

	FSetAllUseCCD parms{};	
	parms.InUseCCD = InUseCCD;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetAllPhysicsLinearVelocity(struct FVector NewVel, bool bAddToCurrent){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetAllPhysicsLinearVelocity");

	FSetAllPhysicsLinearVelocity parms{};	
	parms.NewVel = NewVel;
	parms.bAddToCurrent = bAddToCurrent;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetAllPhysicsAngularVelocityInRadians(struct FVector& NewAngVel, bool bAddToCurrent){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetAllPhysicsAngularVelocityInRadians");

	FSetAllPhysicsAngularVelocityInRadians parms{};	
	parms.NewAngVel = NewAngVel;
	parms.bAddToCurrent = bAddToCurrent;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetAllPhysicsAngularVelocityInDegrees(struct FVector& NewAngVel, bool bAddToCurrent){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetAllPhysicsAngularVelocityInDegrees");

	FSetAllPhysicsAngularVelocityInDegrees parms{};	
	parms.NewAngVel = NewAngVel;
	parms.bAddToCurrent = bAddToCurrent;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::SetAllMassScale(float InMassScale){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetAllMassScale");

	FSetAllMassScale parms{};	
	parms.InMassScale = InMassScale;

	ProcessEvent(fn, &parms);
}

struct FVector UPrimitiveComponent::ScaleByMomentOfInertia(struct FVector InputVector, struct FName BoneName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.ScaleByMomentOfInertia");

	FScaleByMomentOfInertia parms{};	
	parms.InputVector = InputVector;
	parms.BoneName = BoneName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UPrimitiveComponent::PutRigidBodyToSleep(struct FName BoneName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.PutRigidBodyToSleep");

	FPutRigidBodyToSleep parms{};	
	parms.BoneName = BoneName;

	ProcessEvent(fn, &parms);
}

bool UPrimitiveComponent::K2_SphereTraceComponent(struct FVector TraceStart, struct FVector TraceEnd, float SphereRadius, bool bTraceComplex, bool bShowTrace, bool bPersistentShowTrace, struct FVector& HitLocation, struct FVector& HitNormal, struct FName& BoneName, struct FHitResult& OutHit){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.K2_SphereTraceComponent");

	FK2_SphereTraceComponent parms{};	
	parms.TraceStart = TraceStart;
	parms.TraceEnd = TraceEnd;
	parms.SphereRadius = SphereRadius;
	parms.bTraceComplex = bTraceComplex;
	parms.bShowTrace = bShowTrace;
	parms.bPersistentShowTrace = bPersistentShowTrace;
	parms.HitLocation = HitLocation;
	parms.HitNormal = HitNormal;
	parms.BoneName = BoneName;
	parms.OutHit = OutHit;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UPrimitiveComponent::K2_SphereOverlapComponent(struct FVector InSphereCentre, float InSphereRadius, bool bTraceComplex, bool bShowTrace, bool bPersistentShowTrace, struct FVector& HitLocation, struct FVector& HitNormal, struct FName& BoneName, struct FHitResult& OutHit){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.K2_SphereOverlapComponent");

	FK2_SphereOverlapComponent parms{};	
	parms.InSphereCentre = InSphereCentre;
	parms.InSphereRadius = InSphereRadius;
	parms.bTraceComplex = bTraceComplex;
	parms.bShowTrace = bShowTrace;
	parms.bPersistentShowTrace = bPersistentShowTrace;
	parms.HitLocation = HitLocation;
	parms.HitNormal = HitNormal;
	parms.BoneName = BoneName;
	parms.OutHit = OutHit;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UPrimitiveComponent::K2_LineTraceComponent(struct FVector TraceStart, struct FVector TraceEnd, bool bTraceComplex, bool bShowTrace, bool bPersistentShowTrace, struct FVector& HitLocation, struct FVector& HitNormal, struct FName& BoneName, struct FHitResult& OutHit){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.K2_LineTraceComponent");

	FK2_LineTraceComponent parms{};	
	parms.TraceStart = TraceStart;
	parms.TraceEnd = TraceEnd;
	parms.bTraceComplex = bTraceComplex;
	parms.bShowTrace = bShowTrace;
	parms.bPersistentShowTrace = bPersistentShowTrace;
	parms.HitLocation = HitLocation;
	parms.HitNormal = HitNormal;
	parms.BoneName = BoneName;
	parms.OutHit = OutHit;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UPrimitiveComponent::K2_IsQueryCollisionEnabled(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.K2_IsQueryCollisionEnabled");

	FK2_IsQueryCollisionEnabled parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UPrimitiveComponent::K2_IsPhysicsCollisionEnabled(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.K2_IsPhysicsCollisionEnabled");

	FK2_IsPhysicsCollisionEnabled parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UPrimitiveComponent::K2_IsCollisionEnabled(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.K2_IsCollisionEnabled");

	FK2_IsCollisionEnabled parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UPrimitiveComponent::K2_BoxOverlapComponent(struct FVector InBoxCentre, struct FBox InBox, bool bTraceComplex, bool bShowTrace, bool bPersistentShowTrace, struct FVector& HitLocation, struct FVector& HitNormal, struct FName& BoneName, struct FHitResult& OutHit){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.K2_BoxOverlapComponent");

	FK2_BoxOverlapComponent parms{};	
	parms.InBoxCentre = InBoxCentre;
	parms.InBox = InBox;
	parms.bTraceComplex = bTraceComplex;
	parms.bShowTrace = bShowTrace;
	parms.bPersistentShowTrace = bPersistentShowTrace;
	parms.HitLocation = HitLocation;
	parms.HitNormal = HitNormal;
	parms.BoneName = BoneName;
	parms.OutHit = OutHit;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UPrimitiveComponent::IsOverlappingComponent(struct UPrimitiveComponent* OtherComp){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.IsOverlappingComponent");

	FIsOverlappingComponent parms{};	
	parms.OtherComp = OtherComp;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UPrimitiveComponent::IsOverlappingActor(struct AActor* Other){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.IsOverlappingActor");

	FIsOverlappingActor parms{};	
	parms.Other = Other;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UPrimitiveComponent::IsGravityEnabled(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.IsGravityEnabled");

	FIsGravityEnabled parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UPrimitiveComponent::IsAnyRigidBodyAwake(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.IsAnyRigidBodyAwake");

	FIsAnyRigidBodyAwake parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UPrimitiveComponent::InvalidateLumenSurfaceCache(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.InvalidateLumenSurfaceCache");

	FInvalidateLumenSurfaceCache parms{};	

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::IgnoreComponentWhenMoving(struct UPrimitiveComponent* Component, bool bShouldIgnore){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.IgnoreComponentWhenMoving");

	FIgnoreComponentWhenMoving parms{};	
	parms.Component = Component;
	parms.bShouldIgnore = bShouldIgnore;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::IgnoreActorWhenMoving(struct AActor* Actor, bool bShouldIgnore){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.IgnoreActorWhenMoving");

	FIgnoreActorWhenMoving parms{};	
	parms.Actor = Actor;
	parms.bShouldIgnore = bShouldIgnore;

	ProcessEvent(fn, &parms);
}

struct FWalkableSlopeOverride UPrimitiveComponent::GetWalkableSlopeOverride(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetWalkableSlopeOverride");

	FGetWalkableSlopeOverride parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UPrimitiveComponent::GetPhysicsLinearVelocityAtPoint(struct FVector Point, struct FName BoneName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetPhysicsLinearVelocityAtPoint");

	FGetPhysicsLinearVelocityAtPoint parms{};	
	parms.Point = Point;
	parms.BoneName = BoneName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UPrimitiveComponent::GetPhysicsLinearVelocity(struct FName BoneName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetPhysicsLinearVelocity");

	FGetPhysicsLinearVelocity parms{};	
	parms.BoneName = BoneName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UPrimitiveComponent::GetPhysicsAngularVelocityInRadians(struct FName BoneName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetPhysicsAngularVelocityInRadians");

	FGetPhysicsAngularVelocityInRadians parms{};	
	parms.BoneName = BoneName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UPrimitiveComponent::GetPhysicsAngularVelocityInDegrees(struct FName BoneName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetPhysicsAngularVelocityInDegrees");

	FGetPhysicsAngularVelocityInDegrees parms{};	
	parms.BoneName = BoneName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UPrimitiveComponent::GetOverlappingComponents(struct TArray<struct UPrimitiveComponent*>& OutOverlappingComponents){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetOverlappingComponents");

	FGetOverlappingComponents parms{};	
	parms.OutOverlappingComponents = OutOverlappingComponents;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::GetOverlappingActors(struct TArray<struct AActor*>& OverlappingActors, AActor* ClassFilter){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetOverlappingActors");

	FGetOverlappingActors parms{};	
	parms.OverlappingActors = OverlappingActors;
	parms.ClassFilter = ClassFilter;

	ProcessEvent(fn, &parms);
}

int32_t UPrimitiveComponent::GetNumMaterials(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetNumMaterials");

	FGetNumMaterials parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UMaterialInterface* UPrimitiveComponent::GetMaterialFromCollisionFaceIndex(int32_t FaceIndex, int32_t& SectionIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetMaterialFromCollisionFaceIndex");

	FGetMaterialFromCollisionFaceIndex parms{};	
	parms.FaceIndex = FaceIndex;
	parms.SectionIndex = SectionIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UMaterialInterface* UPrimitiveComponent::GetMaterial(int32_t ElementIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetMaterial");

	FGetMaterial parms{};	
	parms.ElementIndex = ElementIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UPrimitiveComponent::GetMassScale(struct FName BoneName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetMassScale");

	FGetMassScale parms{};	
	parms.BoneName = BoneName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UPrimitiveComponent::GetMass(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetMass");

	FGetMass parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UPrimitiveComponent::GetLinearDamping(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetLinearDamping");

	FGetLinearDamping parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UPrimitiveComponent::GetInertiaTensor(struct FName BoneName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetInertiaTensor");

	FGetInertiaTensor parms{};	
	parms.BoneName = BoneName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UPrimitiveComponent::GetGenerateOverlapEvents(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetGenerateOverlapEvents");

	FGetGenerateOverlapEvents parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UPrimitiveComponent::GetCustomPrimitiveDataIndexForVectorParameter(struct FName ParameterName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetCustomPrimitiveDataIndexForVectorParameter");

	FGetCustomPrimitiveDataIndexForVectorParameter parms{};	
	parms.ParameterName = ParameterName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UPrimitiveComponent::GetCustomPrimitiveDataIndexForScalarParameter(struct FName ParameterName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetCustomPrimitiveDataIndexForScalarParameter");

	FGetCustomPrimitiveDataIndexForScalarParameter parms{};	
	parms.ParameterName = ParameterName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

enum class ECollisionResponse UPrimitiveComponent::GetCollisionResponseToChannel(enum class ECollisionChannel Channel){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetCollisionResponseToChannel");

	FGetCollisionResponseToChannel parms{};	
	parms.Channel = Channel;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FName UPrimitiveComponent::GetCollisionProfileName(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetCollisionProfileName");

	FGetCollisionProfileName parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

enum class ECollisionChannel UPrimitiveComponent::GetCollisionObjectType(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetCollisionObjectType");

	FGetCollisionObjectType parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

enum class ECollisionEnabled UPrimitiveComponent::GetCollisionEnabled(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetCollisionEnabled");

	FGetCollisionEnabled parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UPrimitiveComponent::GetClosestPointOnCollision(struct FVector& Point, struct FVector& OutPointOnBody, struct FName BoneName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetClosestPointOnCollision");

	FGetClosestPointOnCollision parms{};	
	parms.Point = Point;
	parms.OutPointOnBody = OutPointOnBody;
	parms.BoneName = BoneName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UPrimitiveComponent::GetCenterOfMass(struct FName BoneName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetCenterOfMass");

	FGetCenterOfMass parms{};	
	parms.BoneName = BoneName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FBodyInstanceAsyncPhysicsTickHandle UPrimitiveComponent::GetBodyInstanceAsyncPhysicsTickHandle(struct FName BoneName, bool bGetWelded, int32_t Index){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetBodyInstanceAsyncPhysicsTickHandle");

	FGetBodyInstanceAsyncPhysicsTickHandle parms{};	
	parms.BoneName = BoneName;
	parms.bGetWelded = bGetWelded;
	parms.Index = Index;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UPrimitiveComponent::GetAngularDamping(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetAngularDamping");

	FGetAngularDamping parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UMaterialInstanceDynamic* UPrimitiveComponent::CreateDynamicMaterialInstance(int32_t ElementIndex, struct UMaterialInterface* SourceMaterial, struct FName OptionalName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.CreateDynamicMaterialInstance");

	FCreateDynamicMaterialInstance parms{};	
	parms.ElementIndex = ElementIndex;
	parms.SourceMaterial = SourceMaterial;
	parms.OptionalName = OptionalName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UMaterialInstanceDynamic* UPrimitiveComponent::CreateAndSetMaterialInstanceDynamicFromMaterial(int32_t ElementIndex, struct UMaterialInterface* Parent){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.CreateAndSetMaterialInstanceDynamicFromMaterial");

	FCreateAndSetMaterialInstanceDynamicFromMaterial parms{};	
	parms.ElementIndex = ElementIndex;
	parms.Parent = Parent;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UMaterialInstanceDynamic* UPrimitiveComponent::CreateAndSetMaterialInstanceDynamic(int32_t ElementIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.CreateAndSetMaterialInstanceDynamic");

	FCreateAndSetMaterialInstanceDynamic parms{};	
	parms.ElementIndex = ElementIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<struct UPrimitiveComponent*> UPrimitiveComponent::CopyArrayOfMoveIgnoreComponents(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.CopyArrayOfMoveIgnoreComponents");

	FCopyArrayOfMoveIgnoreComponents parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<struct AActor*> UPrimitiveComponent::CopyArrayOfMoveIgnoreActors(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.CopyArrayOfMoveIgnoreActors");

	FCopyArrayOfMoveIgnoreActors parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UPrimitiveComponent::ClearMoveIgnoreComponents(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.ClearMoveIgnoreComponents");

	FClearMoveIgnoreComponents parms{};	

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::ClearMoveIgnoreActors(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.ClearMoveIgnoreActors");

	FClearMoveIgnoreActors parms{};	

	ProcessEvent(fn, &parms);
}

bool UPrimitiveComponent::CanCharacterStepUp(struct APawn* Pawn){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.CanCharacterStepUp");

	FCanCharacterStepUp parms{};	
	parms.Pawn = Pawn;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UPrimitiveComponent::AddVelocityChangeImpulseAtLocation(struct FVector Impulse, struct FVector Location, struct FName BoneName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddVelocityChangeImpulseAtLocation");

	FAddVelocityChangeImpulseAtLocation parms{};	
	parms.Impulse = Impulse;
	parms.Location = Location;
	parms.BoneName = BoneName;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::AddTorqueInRadians(struct FVector Torque, struct FName BoneName, bool bAccelChange){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddTorqueInRadians");

	FAddTorqueInRadians parms{};	
	parms.Torque = Torque;
	parms.BoneName = BoneName;
	parms.bAccelChange = bAccelChange;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::AddTorqueInDegrees(struct FVector Torque, struct FName BoneName, bool bAccelChange){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddTorqueInDegrees");

	FAddTorqueInDegrees parms{};	
	parms.Torque = Torque;
	parms.BoneName = BoneName;
	parms.bAccelChange = bAccelChange;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::AddRadialImpulse(struct FVector Origin, float Radius, float Strength, enum class ERadialImpulseFalloff Falloff, bool bVelChange){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddRadialImpulse");

	FAddRadialImpulse parms{};	
	parms.Origin = Origin;
	parms.Radius = Radius;
	parms.Strength = Strength;
	parms.Falloff = Falloff;
	parms.bVelChange = bVelChange;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::AddRadialForce(struct FVector Origin, float Radius, float Strength, enum class ERadialImpulseFalloff Falloff, bool bAccelChange){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddRadialForce");

	FAddRadialForce parms{};	
	parms.Origin = Origin;
	parms.Radius = Radius;
	parms.Strength = Strength;
	parms.Falloff = Falloff;
	parms.bAccelChange = bAccelChange;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::AddImpulseAtLocation(struct FVector Impulse, struct FVector Location, struct FName BoneName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddImpulseAtLocation");

	FAddImpulseAtLocation parms{};	
	parms.Impulse = Impulse;
	parms.Location = Location;
	parms.BoneName = BoneName;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::AddImpulse(struct FVector Impulse, struct FName BoneName, bool bVelChange){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddImpulse");

	FAddImpulse parms{};	
	parms.Impulse = Impulse;
	parms.BoneName = BoneName;
	parms.bVelChange = bVelChange;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::AddForceAtLocationLocal(struct FVector Force, struct FVector Location, struct FName BoneName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddForceAtLocationLocal");

	FAddForceAtLocationLocal parms{};	
	parms.Force = Force;
	parms.Location = Location;
	parms.BoneName = BoneName;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::AddForceAtLocation(struct FVector Force, struct FVector Location, struct FName BoneName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddForceAtLocation");

	FAddForceAtLocation parms{};	
	parms.Force = Force;
	parms.Location = Location;
	parms.BoneName = BoneName;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::AddForce(struct FVector Force, struct FName BoneName, bool bAccelChange){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddForce");

	FAddForce parms{};	
	parms.Force = Force;
	parms.BoneName = BoneName;
	parms.bAccelChange = bAccelChange;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::AddAngularImpulseInRadians(struct FVector Impulse, struct FName BoneName, bool bVelChange){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddAngularImpulseInRadians");

	FAddAngularImpulseInRadians parms{};	
	parms.Impulse = Impulse;
	parms.BoneName = BoneName;
	parms.bVelChange = bVelChange;

	ProcessEvent(fn, &parms);
}

void UPrimitiveComponent::AddAngularImpulseInDegrees(struct FVector Impulse, struct FName BoneName, bool bVelChange){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddAngularImpulseInDegrees");

	FAddAngularImpulseInDegrees parms{};	
	parms.Impulse = Impulse;
	parms.BoneName = BoneName;
	parms.bVelChange = bVelChange;

	ProcessEvent(fn, &parms);
}

void USceneComponent::ToggleVisibility(bool bPropagateToChildren){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.ToggleVisibility");

	FToggleVisibility parms{};	
	parms.bPropagateToChildren = bPropagateToChildren;

	ProcessEvent(fn, &parms);
}

void USceneComponent::SetWorldScale3D(struct FVector NewScale){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.SetWorldScale3D");

	FSetWorldScale3D parms{};	
	parms.NewScale = NewScale;

	ProcessEvent(fn, &parms);
}

void USceneComponent::SetVisibility(bool bNewVisibility, bool bPropagateToChildren){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.SetVisibility");

	FSetVisibility parms{};	
	parms.bNewVisibility = bNewVisibility;
	parms.bPropagateToChildren = bPropagateToChildren;

	ProcessEvent(fn, &parms);
}

void USceneComponent::SetShouldUpdatePhysicsVolume(bool bInShouldUpdatePhysicsVolume){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.SetShouldUpdatePhysicsVolume");

	FSetShouldUpdatePhysicsVolume parms{};	
	parms.bInShouldUpdatePhysicsVolume = bInShouldUpdatePhysicsVolume;

	ProcessEvent(fn, &parms);
}

void USceneComponent::SetRelativeScale3D(struct FVector NewScale3D){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.SetRelativeScale3D");

	FSetRelativeScale3D parms{};	
	parms.NewScale3D = NewScale3D;

	ProcessEvent(fn, &parms);
}

void USceneComponent::SetMobility(enum class EComponentMobility NewMobility){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.SetMobility");

	FSetMobility parms{};	
	parms.NewMobility = NewMobility;

	ProcessEvent(fn, &parms);
}

void USceneComponent::SetHiddenInGame(bool NewHidden, bool bPropagateToChildren){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.SetHiddenInGame");

	FSetHiddenInGame parms{};	
	parms.NewHidden = NewHidden;
	parms.bPropagateToChildren = bPropagateToChildren;

	ProcessEvent(fn, &parms);
}

void USceneComponent::SetAbsolute(bool bNewAbsoluteLocation, bool bNewAbsoluteRotation, bool bNewAbsoluteScale){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.SetAbsolute");

	FSetAbsolute parms{};	
	parms.bNewAbsoluteLocation = bNewAbsoluteLocation;
	parms.bNewAbsoluteRotation = bNewAbsoluteRotation;
	parms.bNewAbsoluteScale = bNewAbsoluteScale;

	ProcessEvent(fn, &parms);
}

void USceneComponent::ResetRelativeTransform(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.ResetRelativeTransform");

	FResetRelativeTransform parms{};	

	ProcessEvent(fn, &parms);
}

void USceneComponent::OnRep_Visibility(bool OldValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.OnRep_Visibility");

	FOnRep_Visibility parms{};	
	parms.OldValue = OldValue;

	ProcessEvent(fn, &parms);
}

void USceneComponent::OnRep_Transform(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.OnRep_Transform");

	FOnRep_Transform parms{};	

	ProcessEvent(fn, &parms);
}

void USceneComponent::OnRep_AttachSocketName(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.OnRep_AttachSocketName");

	FOnRep_AttachSocketName parms{};	

	ProcessEvent(fn, &parms);
}

void USceneComponent::OnRep_AttachParent(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.OnRep_AttachParent");

	FOnRep_AttachParent parms{};	

	ProcessEvent(fn, &parms);
}

void USceneComponent::OnRep_AttachChildren(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.OnRep_AttachChildren");

	FOnRep_AttachChildren parms{};	

	ProcessEvent(fn, &parms);
}

void USceneComponent::K2_SetWorldTransform(struct FTransform& NewTransform, bool bSweep, struct FHitResult& SweepHitResult, bool bTeleport){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_SetWorldTransform");

	FK2_SetWorldTransform parms{};	
	parms.NewTransform = NewTransform;
	parms.bSweep = bSweep;
	parms.SweepHitResult = SweepHitResult;
	parms.bTeleport = bTeleport;

	ProcessEvent(fn, &parms);
}

void USceneComponent::K2_SetWorldRotation(struct FRotator NewRotation, bool bSweep, struct FHitResult& SweepHitResult, bool bTeleport){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_SetWorldRotation");

	FK2_SetWorldRotation parms{};	
	parms.NewRotation = NewRotation;
	parms.bSweep = bSweep;
	parms.SweepHitResult = SweepHitResult;
	parms.bTeleport = bTeleport;

	ProcessEvent(fn, &parms);
}

void USceneComponent::K2_SetWorldLocationAndRotation(struct FVector NewLocation, struct FRotator NewRotation, bool bSweep, struct FHitResult& SweepHitResult, bool bTeleport){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_SetWorldLocationAndRotation");

	FK2_SetWorldLocationAndRotation parms{};	
	parms.NewLocation = NewLocation;
	parms.NewRotation = NewRotation;
	parms.bSweep = bSweep;
	parms.SweepHitResult = SweepHitResult;
	parms.bTeleport = bTeleport;

	ProcessEvent(fn, &parms);
}

void USceneComponent::K2_SetWorldLocation(struct FVector NewLocation, bool bSweep, struct FHitResult& SweepHitResult, bool bTeleport){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_SetWorldLocation");

	FK2_SetWorldLocation parms{};	
	parms.NewLocation = NewLocation;
	parms.bSweep = bSweep;
	parms.SweepHitResult = SweepHitResult;
	parms.bTeleport = bTeleport;

	ProcessEvent(fn, &parms);
}

void USceneComponent::K2_SetRelativeTransform(struct FTransform& NewTransform, bool bSweep, struct FHitResult& SweepHitResult, bool bTeleport){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_SetRelativeTransform");

	FK2_SetRelativeTransform parms{};	
	parms.NewTransform = NewTransform;
	parms.bSweep = bSweep;
	parms.SweepHitResult = SweepHitResult;
	parms.bTeleport = bTeleport;

	ProcessEvent(fn, &parms);
}

void USceneComponent::K2_SetRelativeRotation(struct FRotator NewRotation, bool bSweep, struct FHitResult& SweepHitResult, bool bTeleport){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_SetRelativeRotation");

	FK2_SetRelativeRotation parms{};	
	parms.NewRotation = NewRotation;
	parms.bSweep = bSweep;
	parms.SweepHitResult = SweepHitResult;
	parms.bTeleport = bTeleport;

	ProcessEvent(fn, &parms);
}

void USceneComponent::K2_SetRelativeLocationAndRotation(struct FVector NewLocation, struct FRotator NewRotation, bool bSweep, struct FHitResult& SweepHitResult, bool bTeleport){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_SetRelativeLocationAndRotation");

	FK2_SetRelativeLocationAndRotation parms{};	
	parms.NewLocation = NewLocation;
	parms.NewRotation = NewRotation;
	parms.bSweep = bSweep;
	parms.SweepHitResult = SweepHitResult;
	parms.bTeleport = bTeleport;

	ProcessEvent(fn, &parms);
}

void USceneComponent::K2_SetRelativeLocation(struct FVector NewLocation, bool bSweep, struct FHitResult& SweepHitResult, bool bTeleport){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_SetRelativeLocation");

	FK2_SetRelativeLocation parms{};	
	parms.NewLocation = NewLocation;
	parms.bSweep = bSweep;
	parms.SweepHitResult = SweepHitResult;
	parms.bTeleport = bTeleport;

	ProcessEvent(fn, &parms);
}

struct FTransform USceneComponent::K2_GetComponentToWorld(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_GetComponentToWorld");

	FK2_GetComponentToWorld parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USceneComponent::K2_GetComponentScale(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_GetComponentScale");

	FK2_GetComponentScale parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator USceneComponent::K2_GetComponentRotation(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_GetComponentRotation");

	FK2_GetComponentRotation parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USceneComponent::K2_GetComponentLocation(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_GetComponentLocation");

	FK2_GetComponentLocation parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void USceneComponent::K2_DetachFromComponent(uint8_t LocationRule, uint8_t RotationRule, uint8_t ScaleRule, bool bCallModify){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_DetachFromComponent");

	FK2_DetachFromComponent parms{};	
	parms.LocationRule = LocationRule;
	parms.RotationRule = RotationRule;
	parms.ScaleRule = ScaleRule;
	parms.bCallModify = bCallModify;

	ProcessEvent(fn, &parms);
}

bool USceneComponent::K2_AttachToComponent(struct USceneComponent* Parent, struct FName SocketName, uint8_t LocationRule, uint8_t RotationRule, uint8_t ScaleRule, bool bWeldSimulatedBodies){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AttachToComponent");

	FK2_AttachToComponent parms{};	
	parms.Parent = Parent;
	parms.SocketName = SocketName;
	parms.LocationRule = LocationRule;
	parms.RotationRule = RotationRule;
	parms.ScaleRule = ScaleRule;
	parms.bWeldSimulatedBodies = bWeldSimulatedBodies;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool USceneComponent::K2_AttachTo(struct USceneComponent* InParent, struct FName InSocketName, enum class EAttachLocation AttachType, bool bWeldSimulatedBodies){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AttachTo");

	FK2_AttachTo parms{};	
	parms.InParent = InParent;
	parms.InSocketName = InSocketName;
	parms.AttachType = AttachType;
	parms.bWeldSimulatedBodies = bWeldSimulatedBodies;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void USceneComponent::K2_AddWorldTransformKeepScale(struct FTransform& DeltaTransform, bool bSweep, struct FHitResult& SweepHitResult, bool bTeleport){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AddWorldTransformKeepScale");

	FK2_AddWorldTransformKeepScale parms{};	
	parms.DeltaTransform = DeltaTransform;
	parms.bSweep = bSweep;
	parms.SweepHitResult = SweepHitResult;
	parms.bTeleport = bTeleport;

	ProcessEvent(fn, &parms);
}

void USceneComponent::K2_AddWorldTransform(struct FTransform& DeltaTransform, bool bSweep, struct FHitResult& SweepHitResult, bool bTeleport){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AddWorldTransform");

	FK2_AddWorldTransform parms{};	
	parms.DeltaTransform = DeltaTransform;
	parms.bSweep = bSweep;
	parms.SweepHitResult = SweepHitResult;
	parms.bTeleport = bTeleport;

	ProcessEvent(fn, &parms);
}

void USceneComponent::K2_AddWorldRotation(struct FRotator DeltaRotation, bool bSweep, struct FHitResult& SweepHitResult, bool bTeleport){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AddWorldRotation");

	FK2_AddWorldRotation parms{};	
	parms.DeltaRotation = DeltaRotation;
	parms.bSweep = bSweep;
	parms.SweepHitResult = SweepHitResult;
	parms.bTeleport = bTeleport;

	ProcessEvent(fn, &parms);
}

void USceneComponent::K2_AddWorldOffset(struct FVector DeltaLocation, bool bSweep, struct FHitResult& SweepHitResult, bool bTeleport){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AddWorldOffset");

	FK2_AddWorldOffset parms{};	
	parms.DeltaLocation = DeltaLocation;
	parms.bSweep = bSweep;
	parms.SweepHitResult = SweepHitResult;
	parms.bTeleport = bTeleport;

	ProcessEvent(fn, &parms);
}

void USceneComponent::K2_AddRelativeRotation(struct FRotator DeltaRotation, bool bSweep, struct FHitResult& SweepHitResult, bool bTeleport){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AddRelativeRotation");

	FK2_AddRelativeRotation parms{};	
	parms.DeltaRotation = DeltaRotation;
	parms.bSweep = bSweep;
	parms.SweepHitResult = SweepHitResult;
	parms.bTeleport = bTeleport;

	ProcessEvent(fn, &parms);
}

void USceneComponent::K2_AddRelativeLocation(struct FVector DeltaLocation, bool bSweep, struct FHitResult& SweepHitResult, bool bTeleport){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AddRelativeLocation");

	FK2_AddRelativeLocation parms{};	
	parms.DeltaLocation = DeltaLocation;
	parms.bSweep = bSweep;
	parms.SweepHitResult = SweepHitResult;
	parms.bTeleport = bTeleport;

	ProcessEvent(fn, &parms);
}

void USceneComponent::K2_AddLocalTransform(struct FTransform& DeltaTransform, bool bSweep, struct FHitResult& SweepHitResult, bool bTeleport){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AddLocalTransform");

	FK2_AddLocalTransform parms{};	
	parms.DeltaTransform = DeltaTransform;
	parms.bSweep = bSweep;
	parms.SweepHitResult = SweepHitResult;
	parms.bTeleport = bTeleport;

	ProcessEvent(fn, &parms);
}

void USceneComponent::K2_AddLocalRotation(struct FRotator DeltaRotation, bool bSweep, struct FHitResult& SweepHitResult, bool bTeleport){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AddLocalRotation");

	FK2_AddLocalRotation parms{};	
	parms.DeltaRotation = DeltaRotation;
	parms.bSweep = bSweep;
	parms.SweepHitResult = SweepHitResult;
	parms.bTeleport = bTeleport;

	ProcessEvent(fn, &parms);
}

void USceneComponent::K2_AddLocalOffset(struct FVector DeltaLocation, bool bSweep, struct FHitResult& SweepHitResult, bool bTeleport){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AddLocalOffset");

	FK2_AddLocalOffset parms{};	
	parms.DeltaLocation = DeltaLocation;
	parms.bSweep = bSweep;
	parms.SweepHitResult = SweepHitResult;
	parms.bTeleport = bTeleport;

	ProcessEvent(fn, &parms);
}

bool USceneComponent::IsVisible(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.IsVisible");

	FIsVisible parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool USceneComponent::IsSimulatingPhysics(struct FName BoneName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.IsSimulatingPhysics");

	FIsSimulatingPhysics parms{};	
	parms.BoneName = BoneName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool USceneComponent::IsAnySimulatingPhysics(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.IsAnySimulatingPhysics");

	FIsAnySimulatingPhysics parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USceneComponent::GetUpVector(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetUpVector");

	FGetUpVector parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTransform USceneComponent::GetSocketTransform(struct FName InSocketName, enum class ERelativeTransformSpace TransformSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetSocketTransform");

	FGetSocketTransform parms{};	
	parms.InSocketName = InSocketName;
	parms.TransformSpace = TransformSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator USceneComponent::GetSocketRotation(struct FName InSocketName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetSocketRotation");

	FGetSocketRotation parms{};	
	parms.InSocketName = InSocketName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FQuat USceneComponent::GetSocketQuaternion(struct FName InSocketName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetSocketQuaternion");

	FGetSocketQuaternion parms{};	
	parms.InSocketName = InSocketName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USceneComponent::GetSocketLocation(struct FName InSocketName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetSocketLocation");

	FGetSocketLocation parms{};	
	parms.InSocketName = InSocketName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool USceneComponent::GetShouldUpdatePhysicsVolume(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetShouldUpdatePhysicsVolume");

	FGetShouldUpdatePhysicsVolume parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USceneComponent::GetRightVector(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetRightVector");

	FGetRightVector parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTransform USceneComponent::GetRelativeTransform(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetRelativeTransform");

	FGetRelativeTransform parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct APhysicsVolume* USceneComponent::GetPhysicsVolume(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetPhysicsVolume");

	FGetPhysicsVolume parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void USceneComponent::GetParentComponents(struct TArray<struct USceneComponent*>& Parents){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetParentComponents");

	FGetParentComponents parms{};	
	parms.Parents = Parents;

	ProcessEvent(fn, &parms);
}

int32_t USceneComponent::GetNumChildrenComponents(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetNumChildrenComponents");

	FGetNumChildrenComponents parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USceneComponent::GetForwardVector(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetForwardVector");

	FGetForwardVector parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USceneComponent::GetComponentVelocity(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetComponentVelocity");

	FGetComponentVelocity parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void USceneComponent::GetChildrenComponents(bool bIncludeAllDescendants, struct TArray<struct USceneComponent*>& Children){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetChildrenComponents");

	FGetChildrenComponents parms{};	
	parms.bIncludeAllDescendants = bIncludeAllDescendants;
	parms.Children = Children;

	ProcessEvent(fn, &parms);
}

struct USceneComponent* USceneComponent::GetChildComponent(int32_t ChildIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetChildComponent");

	FGetChildComponent parms{};	
	parms.ChildIndex = ChildIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FName USceneComponent::GetAttachSocketName(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetAttachSocketName");

	FGetAttachSocketName parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct USceneComponent* USceneComponent::GetAttachParent(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetAttachParent");

	FGetAttachParent parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<struct FName> USceneComponent::GetAllSocketNames(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetAllSocketNames");

	FGetAllSocketNames parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool USceneComponent::DoesSocketExist(struct FName InSocketName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.DoesSocketExist");

	FDoesSocketExist parms{};	
	parms.InSocketName = InSocketName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void USceneComponent::DetachFromParent(bool bMaintainWorldPosition, bool bCallModify){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneComponent.DetachFromParent");

	FDetachFromParent parms{};	
	parms.bMaintainWorldPosition = bMaintainWorldPosition;
	parms.bCallModify = bCallModify;

	ProcessEvent(fn, &parms);
}

void UFXSystemComponent::SetVectorParameter(struct FName ParameterName, struct FVector Param){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.FXSystemComponent.SetVectorParameter");

	FSetVectorParameter parms{};	
	parms.ParameterName = ParameterName;
	parms.Param = Param;

	ProcessEvent(fn, &parms);
}

void UFXSystemComponent::SetUseAutoManageAttachment(bool bAutoManage){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.FXSystemComponent.SetUseAutoManageAttachment");

	FSetUseAutoManageAttachment parms{};	
	parms.bAutoManage = bAutoManage;

	ProcessEvent(fn, &parms);
}

void UFXSystemComponent::SetIntParameter(struct FName ParameterName, int32_t Param){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.FXSystemComponent.SetIntParameter");

	FSetIntParameter parms{};	
	parms.ParameterName = ParameterName;
	parms.Param = Param;

	ProcessEvent(fn, &parms);
}

void UFXSystemComponent::SetFloatParameter(struct FName ParameterName, float Param){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.FXSystemComponent.SetFloatParameter");

	FSetFloatParameter parms{};	
	parms.ParameterName = ParameterName;
	parms.Param = Param;

	ProcessEvent(fn, &parms);
}

void UFXSystemComponent::SetEmitterEnable(struct FName EmitterName, bool bNewEnableState){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.FXSystemComponent.SetEmitterEnable");

	FSetEmitterEnable parms{};	
	parms.EmitterName = EmitterName;
	parms.bNewEnableState = bNewEnableState;

	ProcessEvent(fn, &parms);
}

void UFXSystemComponent::SetColorParameter(struct FName ParameterName, struct FLinearColor Param){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.FXSystemComponent.SetColorParameter");

	FSetColorParameter parms{};	
	parms.ParameterName = ParameterName;
	parms.Param = Param;

	ProcessEvent(fn, &parms);
}

void UFXSystemComponent::SetBoolParameter(struct FName ParameterName, bool Param){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.FXSystemComponent.SetBoolParameter");

	FSetBoolParameter parms{};	
	parms.ParameterName = ParameterName;
	parms.Param = Param;

	ProcessEvent(fn, &parms);
}

void UFXSystemComponent::SetAutoAttachmentParameters(struct USceneComponent* Parent, struct FName SocketName, uint8_t LocationRule, uint8_t RotationRule, uint8_t ScaleRule){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.FXSystemComponent.SetAutoAttachmentParameters");

	FSetAutoAttachmentParameters parms{};	
	parms.Parent = Parent;
	parms.SocketName = SocketName;
	parms.LocationRule = LocationRule;
	parms.RotationRule = RotationRule;
	parms.ScaleRule = ScaleRule;

	ProcessEvent(fn, &parms);
}

void UFXSystemComponent::SetActorParameter(struct FName ParameterName, struct AActor* Param){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.FXSystemComponent.SetActorParameter");

	FSetActorParameter parms{};	
	parms.ParameterName = ParameterName;
	parms.Param = Param;

	ProcessEvent(fn, &parms);
}

void UFXSystemComponent::ReleaseToPool(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.FXSystemComponent.ReleaseToPool");

	FReleaseToPool parms{};	

	ProcessEvent(fn, &parms);
}

struct UFXSystemAsset* UFXSystemComponent::GetFXSystemAsset(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.FXSystemComponent.GetFXSystemAsset");

	FGetFXSystemAsset parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UPlayerInput::SetMouseSensitivity(float Sensitivity){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerInput.SetMouseSensitivity");

	FSetMouseSensitivity parms{};	
	parms.Sensitivity = Sensitivity;

	ProcessEvent(fn, &parms);
}

void UPlayerInput::SetBind(struct FName BindName, struct FString Command){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerInput.SetBind");

	FSetBind parms{};	
	parms.BindName = BindName;
	parms.Command = Command;

	ProcessEvent(fn, &parms);
}

void UPlayerInput::InvertAxisKey(struct FKey AxisKey){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerInput.InvertAxisKey");

	FInvertAxisKey parms{};	
	parms.AxisKey = AxisKey;

	ProcessEvent(fn, &parms);
}

void UPlayerInput::InvertAxis(struct FName AxisName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerInput.InvertAxis");

	FInvertAxis parms{};	
	parms.AxisName = AxisName;

	ProcessEvent(fn, &parms);
}

struct APlayerController* UPlayerInput::GetOuterAPlayerController(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerInput.GetOuterAPlayerController");

	FGetOuterAPlayerController parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UPlayerInput::ClearSmoothing(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerInput.ClearSmoothing");

	FClearSmoothing parms{};	

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::UnlinkAnimClassLayers(UAnimInstance* InClass){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.UnlinkAnimClassLayers");

	FUnlinkAnimClassLayers parms{};	
	parms.InClass = InClass;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::UnbindClothFromLeaderPoseComponent(bool bRestoreSimulationSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.UnbindClothFromLeaderPoseComponent");

	FUnbindClothFromLeaderPoseComponent parms{};	
	parms.bRestoreSimulationSpace = bRestoreSimulationSpace;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::ToggleDisablePostProcessBlueprint(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.ToggleDisablePostProcessBlueprint");

	FToggleDisablePostProcessBlueprint parms{};	

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::TermBodiesBelow(struct FName ParentBoneName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.TermBodiesBelow");

	FTermBodiesBelow parms{};	
	parms.ParentBoneName = ParentBoneName;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::SuspendClothingSimulation(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SuspendClothingSimulation");

	FSuspendClothingSimulation parms{};	

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::Stop(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.Stop");

	FStop parms{};	

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::SnapshotPose(struct FPoseSnapshot& Snapshot){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SnapshotPose");

	FSnapshotPose parms{};	
	parms.Snapshot = Snapshot;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::SetUpdateClothInEditor(bool NewUpdateState){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetUpdateClothInEditor");

	FSetUpdateClothInEditor parms{};	
	parms.NewUpdateState = NewUpdateState;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::SetUpdateAnimationInEditor(bool NewUpdateState){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetUpdateAnimationInEditor");

	FSetUpdateAnimationInEditor parms{};	
	parms.NewUpdateState = NewUpdateState;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::SetTeleportRotationThreshold(float Threshold){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetTeleportRotationThreshold");

	FSetTeleportRotationThreshold parms{};	
	parms.Threshold = Threshold;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::SetTeleportDistanceThreshold(float Threshold){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetTeleportDistanceThreshold");

	FSetTeleportDistanceThreshold parms{};	
	parms.Threshold = Threshold;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::SetSkeletalMeshAsset(struct USkeletalMesh* NewMesh){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetSkeletalMeshAsset");

	FSetSkeletalMeshAsset parms{};	
	parms.NewMesh = NewMesh;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::SetPosition(float InPos, bool bFireNotifies){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetPosition");

	FSetPosition parms{};	
	parms.InPos = InPos;
	parms.bFireNotifies = bFireNotifies;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::SetPlayRate(float Rate){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetPlayRate");

	FSetPlayRate parms{};	
	parms.Rate = Rate;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::SetPhysicsBlendWeight(float PhysicsBlendWeight){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetPhysicsBlendWeight");

	FSetPhysicsBlendWeight parms{};	
	parms.PhysicsBlendWeight = PhysicsBlendWeight;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::SetNotifyRigidBodyCollisionBelow(bool bNewNotifyRigidBodyCollision, struct FName BoneName, bool bIncludeSelf){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetNotifyRigidBodyCollisionBelow");

	FSetNotifyRigidBodyCollisionBelow parms{};	
	parms.bNewNotifyRigidBodyCollision = bNewNotifyRigidBodyCollision;
	parms.BoneName = BoneName;
	parms.bIncludeSelf = bIncludeSelf;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::SetMorphTarget(struct FName MorphTargetName, float Value, bool bRemoveZeroWeight){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetMorphTarget");

	FSetMorphTarget parms{};	
	parms.MorphTargetName = MorphTargetName;
	parms.Value = Value;
	parms.bRemoveZeroWeight = bRemoveZeroWeight;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::SetEnablePhysicsBlending(bool bNewBlendPhysics){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetEnablePhysicsBlending");

	FSetEnablePhysicsBlending parms{};	
	parms.bNewBlendPhysics = bNewBlendPhysics;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::SetEnableGravityOnAllBodiesBelow(bool bEnableGravity, struct FName BoneName, bool bIncludeSelf){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetEnableGravityOnAllBodiesBelow");

	FSetEnableGravityOnAllBodiesBelow parms{};	
	parms.bEnableGravity = bEnableGravity;
	parms.BoneName = BoneName;
	parms.bIncludeSelf = bIncludeSelf;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::SetEnableBodyGravity(bool bEnableGravity, struct FName BoneName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetEnableBodyGravity");

	FSetEnableBodyGravity parms{};	
	parms.bEnableGravity = bEnableGravity;
	parms.BoneName = BoneName;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::SetDisablePostProcessBlueprint(bool bInDisablePostProcess){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetDisablePostProcessBlueprint");

	FSetDisablePostProcessBlueprint parms{};	
	parms.bInDisablePostProcess = bInDisablePostProcess;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::SetDisableAnimCurves(bool bInDisableAnimCurves){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetDisableAnimCurves");

	FSetDisableAnimCurves parms{};	
	parms.bInDisableAnimCurves = bInDisableAnimCurves;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::SetConstraintProfileForAll(struct FName ProfileName, bool bDefaultIfNotFound){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetConstraintProfileForAll");

	FSetConstraintProfileForAll parms{};	
	parms.ProfileName = ProfileName;
	parms.bDefaultIfNotFound = bDefaultIfNotFound;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::SetConstraintProfile(struct FName JointName, struct FName ProfileName, bool bDefaultIfNotFound){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetConstraintProfile");

	FSetConstraintProfile parms{};	
	parms.JointName = JointName;
	parms.ProfileName = ProfileName;
	parms.bDefaultIfNotFound = bDefaultIfNotFound;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::SetClothMaxDistanceScale(float Scale){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetClothMaxDistanceScale");

	FSetClothMaxDistanceScale parms{};	
	parms.Scale = Scale;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::SetBodyNotifyRigidBodyCollision(bool bNewNotifyRigidBodyCollision, struct FName BoneName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetBodyNotifyRigidBodyCollision");

	FSetBodyNotifyRigidBodyCollision parms{};	
	parms.bNewNotifyRigidBodyCollision = bNewNotifyRigidBodyCollision;
	parms.BoneName = BoneName;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::SetAnimClass(UObject* NewClass){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAnimClass");

	FSetAnimClass parms{};	
	parms.NewClass = NewClass;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::SetAnimationMode(enum class EAnimationMode InAnimationMode){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAnimationMode");

	FSetAnimationMode parms{};	
	parms.InAnimationMode = InAnimationMode;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::SetAnimation(struct UAnimationAsset* NewAnimToPlay){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAnimation");

	FSetAnimation parms{};	
	parms.NewAnimToPlay = NewAnimToPlay;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::SetAngularLimits(struct FName InBoneName, float Swing1LimitAngle, float TwistLimitAngle, float Swing2LimitAngle){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAngularLimits");

	FSetAngularLimits parms{};	
	parms.InBoneName = InBoneName;
	parms.Swing1LimitAngle = Swing1LimitAngle;
	parms.TwistLimitAngle = TwistLimitAngle;
	parms.Swing2LimitAngle = Swing2LimitAngle;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::SetAllowRigidBodyAnimNode(bool bInAllow, bool bReinitAnim){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllowRigidBodyAnimNode");

	FSetAllowRigidBodyAnimNode parms{};	
	parms.bInAllow = bInAllow;
	parms.bReinitAnim = bReinitAnim;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::SetAllowedAnimCurvesEvaluation(struct TArray<struct FName>& List, bool bAllow){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllowedAnimCurvesEvaluation");

	FSetAllowedAnimCurvesEvaluation parms{};	
	parms.List = List;
	parms.bAllow = bAllow;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::SetAllowClothActors(bool bInAllow){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllowClothActors");

	FSetAllowClothActors parms{};	
	parms.bInAllow = bInAllow;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::SetAllowAnimCurveEvaluation(bool bInAllow){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllowAnimCurveEvaluation");

	FSetAllowAnimCurveEvaluation parms{};	
	parms.bInAllow = bInAllow;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::SetAllMotorsAngularVelocityDrive(bool bEnableSwingDrive, bool bEnableTwistDrive, bool bSkipCustomPhysicsType){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllMotorsAngularVelocityDrive");

	FSetAllMotorsAngularVelocityDrive parms{};	
	parms.bEnableSwingDrive = bEnableSwingDrive;
	parms.bEnableTwistDrive = bEnableTwistDrive;
	parms.bSkipCustomPhysicsType = bSkipCustomPhysicsType;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::SetAllMotorsAngularPositionDrive(bool bEnableSwingDrive, bool bEnableTwistDrive, bool bSkipCustomPhysicsType){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllMotorsAngularPositionDrive");

	FSetAllMotorsAngularPositionDrive parms{};	
	parms.bEnableSwingDrive = bEnableSwingDrive;
	parms.bEnableTwistDrive = bEnableTwistDrive;
	parms.bSkipCustomPhysicsType = bSkipCustomPhysicsType;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::SetAllMotorsAngularDriveParams(float InSpring, float InDamping, float InForceLimit, bool bSkipCustomPhysicsType){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllMotorsAngularDriveParams");

	FSetAllMotorsAngularDriveParams parms{};	
	parms.InSpring = InSpring;
	parms.InDamping = InDamping;
	parms.InForceLimit = InForceLimit;
	parms.bSkipCustomPhysicsType = bSkipCustomPhysicsType;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::SetAllBodiesSimulatePhysics(bool bNewSimulate){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllBodiesSimulatePhysics");

	FSetAllBodiesSimulatePhysics parms{};	
	parms.bNewSimulate = bNewSimulate;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::SetAllBodiesPhysicsBlendWeight(float PhysicsBlendWeight, bool bSkipCustomPhysicsType){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllBodiesPhysicsBlendWeight");

	FSetAllBodiesPhysicsBlendWeight parms{};	
	parms.PhysicsBlendWeight = PhysicsBlendWeight;
	parms.bSkipCustomPhysicsType = bSkipCustomPhysicsType;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::SetAllBodiesBelowSimulatePhysics(struct FName& InBoneName, bool bNewSimulate, bool bIncludeSelf){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllBodiesBelowSimulatePhysics");

	FSetAllBodiesBelowSimulatePhysics parms{};	
	parms.InBoneName = InBoneName;
	parms.bNewSimulate = bNewSimulate;
	parms.bIncludeSelf = bIncludeSelf;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::SetAllBodiesBelowPhysicsDisabled(struct FName& InBoneName, bool bDisabled, bool bIncludeSelf){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllBodiesBelowPhysicsDisabled");

	FSetAllBodiesBelowPhysicsDisabled parms{};	
	parms.InBoneName = InBoneName;
	parms.bDisabled = bDisabled;
	parms.bIncludeSelf = bIncludeSelf;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::SetAllBodiesBelowPhysicsBlendWeight(struct FName& InBoneName, float PhysicsBlendWeight, bool bSkipCustomPhysicsType, bool bIncludeSelf){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllBodiesBelowPhysicsBlendWeight");

	FSetAllBodiesBelowPhysicsBlendWeight parms{};	
	parms.InBoneName = InBoneName;
	parms.PhysicsBlendWeight = PhysicsBlendWeight;
	parms.bSkipCustomPhysicsType = bSkipCustomPhysicsType;
	parms.bIncludeSelf = bIncludeSelf;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::SetAllBodiesBelowLinearVelocity(struct FName& InBoneName, struct FVector& LinearVelocity, bool bIncludeSelf){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllBodiesBelowLinearVelocity");

	FSetAllBodiesBelowLinearVelocity parms{};	
	parms.InBoneName = InBoneName;
	parms.LinearVelocity = LinearVelocity;
	parms.bIncludeSelf = bIncludeSelf;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::ResumeClothingSimulation(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.ResumeClothingSimulation");

	FResumeClothingSimulation parms{};	

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::ResetClothTeleportMode(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.ResetClothTeleportMode");

	FResetClothTeleportMode parms{};	

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::ResetAnimInstanceDynamics(uint8_t InTeleportType){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.ResetAnimInstanceDynamics");

	FResetAnimInstanceDynamics parms{};	
	parms.InTeleportType = InTeleportType;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::ResetAllowedAnimCurveEvaluation(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.ResetAllowedAnimCurveEvaluation");

	FResetAllowedAnimCurveEvaluation parms{};	

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::ResetAllBodiesSimulatePhysics(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.ResetAllBodiesSimulatePhysics");

	FResetAllBodiesSimulatePhysics parms{};	

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::PlayAnimation(struct UAnimationAsset* NewAnimToPlay, bool bLooping){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.PlayAnimation");

	FPlayAnimation parms{};	
	parms.NewAnimToPlay = NewAnimToPlay;
	parms.bLooping = bLooping;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::Play(bool bLooping){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.Play");

	FPlay parms{};	
	parms.bLooping = bLooping;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::OverrideAnimationData(struct UAnimationAsset* InAnimToPlay, bool bIsLooping, bool bIsPlaying, float Position, float PlayRate){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.OverrideAnimationData");

	FOverrideAnimationData parms{};	
	parms.InAnimToPlay = InAnimToPlay;
	parms.bIsLooping = bIsLooping;
	parms.bIsPlaying = bIsPlaying;
	parms.Position = Position;
	parms.PlayRate = PlayRate;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::LinkAnimGraphByTag(struct FName InTag, UAnimInstance* InClass){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.LinkAnimGraphByTag");

	FLinkAnimGraphByTag parms{};	
	parms.InTag = InTag;
	parms.InClass = InClass;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::LinkAnimClassLayers(UAnimInstance* InClass){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.LinkAnimClassLayers");

	FLinkAnimClassLayers parms{};	
	parms.InClass = InClass;

	ProcessEvent(fn, &parms);
}

bool USkeletalMeshComponent::K2_GetClosestPointOnPhysicsAsset(struct FVector& WorldPosition, struct FVector& ClosestWorldPosition, struct FVector& Normal, struct FName& BoneName, float& Distance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.K2_GetClosestPointOnPhysicsAsset");

	FK2_GetClosestPointOnPhysicsAsset parms{};	
	parms.WorldPosition = WorldPosition;
	parms.ClosestWorldPosition = ClosestWorldPosition;
	parms.Normal = Normal;
	parms.BoneName = BoneName;
	parms.Distance = Distance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool USkeletalMeshComponent::IsPlaying(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.IsPlaying");

	FIsPlaying parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool USkeletalMeshComponent::IsClothingSimulationSuspended(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.IsClothingSimulationSuspended");

	FIsClothingSimulationSuspended parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool USkeletalMeshComponent::IsBodyGravityEnabled(struct FName BoneName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.IsBodyGravityEnabled");

	FIsBodyGravityEnabled parms{};	
	parms.BoneName = BoneName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool USkeletalMeshComponent::HasValidAnimationInstance(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.HasValidAnimationInstance");

	FHasValidAnimationInstance parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool USkeletalMeshComponent::GetTransformAttribute_Ref(struct FName& BoneName, struct FName& AttributeName, struct FTransform& OutValue, uint8_t LookupType){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetTransformAttribute_Ref");

	FGetTransformAttribute_Ref parms{};	
	parms.BoneName = BoneName;
	parms.AttributeName = AttributeName;
	parms.OutValue = OutValue;
	parms.LookupType = LookupType;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool USkeletalMeshComponent::GetTransformAttribute(struct FName& BoneName, struct FName& AttributeName, struct FTransform DefaultValue, struct FTransform& OutValue, uint8_t LookupType){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetTransformAttribute");

	FGetTransformAttribute parms{};	
	parms.BoneName = BoneName;
	parms.AttributeName = AttributeName;
	parms.DefaultValue = DefaultValue;
	parms.OutValue = OutValue;
	parms.LookupType = LookupType;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float USkeletalMeshComponent::GetTeleportRotationThreshold(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetTeleportRotationThreshold");

	FGetTeleportRotationThreshold parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float USkeletalMeshComponent::GetTeleportDistanceThreshold(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetTeleportDistanceThreshold");

	FGetTeleportDistanceThreshold parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool USkeletalMeshComponent::GetStringAttribute_Ref(struct FName& BoneName, struct FName& AttributeName, struct FString& OutValue, uint8_t LookupType){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetStringAttribute_Ref");

	FGetStringAttribute_Ref parms{};	
	parms.BoneName = BoneName;
	parms.AttributeName = AttributeName;
	parms.OutValue = OutValue;
	parms.LookupType = LookupType;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool USkeletalMeshComponent::GetStringAttribute(struct FName& BoneName, struct FName& AttributeName, struct FString DefaultValue, struct FString& OutValue, uint8_t LookupType){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetStringAttribute");

	FGetStringAttribute parms{};	
	parms.BoneName = BoneName;
	parms.AttributeName = AttributeName;
	parms.DefaultValue = DefaultValue;
	parms.OutValue = OutValue;
	parms.LookupType = LookupType;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct USkeletalMesh* USkeletalMeshComponent::GetSkeletalMeshAsset(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetSkeletalMeshAsset");

	FGetSkeletalMeshAsset parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USkeletalMeshComponent::GetSkeletalCenterOfMass(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetSkeletalCenterOfMass");

	FGetSkeletalCenterOfMass parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UAnimInstance* USkeletalMeshComponent::GetPostProcessInstance(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetPostProcessInstance");

	FGetPostProcessInstance parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float USkeletalMeshComponent::GetPosition(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetPosition");

	FGetPosition parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float USkeletalMeshComponent::GetPlayRate(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetPlayRate");

	FGetPlayRate parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float USkeletalMeshComponent::GetMorphTarget(struct FName MorphTargetName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetMorphTarget");

	FGetMorphTarget parms{};	
	parms.MorphTargetName = MorphTargetName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UAnimInstance* USkeletalMeshComponent::GetLinkedAnimLayerInstanceByGroup(struct FName InGroup){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetLinkedAnimLayerInstanceByGroup");

	FGetLinkedAnimLayerInstanceByGroup parms{};	
	parms.InGroup = InGroup;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UAnimInstance* USkeletalMeshComponent::GetLinkedAnimLayerInstanceByClass(UAnimInstance* InClass){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetLinkedAnimLayerInstanceByClass");

	FGetLinkedAnimLayerInstanceByClass parms{};	
	parms.InClass = InClass;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void USkeletalMeshComponent::GetLinkedAnimGraphInstancesByTag(struct FName InTag, struct TArray<struct UAnimInstance*>& OutLinkedInstances){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetLinkedAnimGraphInstancesByTag");

	FGetLinkedAnimGraphInstancesByTag parms{};	
	parms.InTag = InTag;
	parms.OutLinkedInstances = OutLinkedInstances;

	ProcessEvent(fn, &parms);
}

struct UAnimInstance* USkeletalMeshComponent::GetLinkedAnimGraphInstanceByTag(struct FName InTag){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetLinkedAnimGraphInstanceByTag");

	FGetLinkedAnimGraphInstanceByTag parms{};	
	parms.InTag = InTag;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool USkeletalMeshComponent::GetIntegerAttribute_Ref(struct FName& BoneName, struct FName& AttributeName, int32_t& OutValue, uint8_t LookupType){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetIntegerAttribute_Ref");

	FGetIntegerAttribute_Ref parms{};	
	parms.BoneName = BoneName;
	parms.AttributeName = AttributeName;
	parms.OutValue = OutValue;
	parms.LookupType = LookupType;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool USkeletalMeshComponent::GetIntegerAttribute(struct FName& BoneName, struct FName& AttributeName, int32_t DefaultValue, int32_t& OutValue, uint8_t LookupType){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetIntegerAttribute");

	FGetIntegerAttribute parms{};	
	parms.BoneName = BoneName;
	parms.AttributeName = AttributeName;
	parms.DefaultValue = DefaultValue;
	parms.OutValue = OutValue;
	parms.LookupType = LookupType;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool USkeletalMeshComponent::GetFloatAttribute_Ref(struct FName& BoneName, struct FName& AttributeName, float& OutValue, uint8_t LookupType){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetFloatAttribute_Ref");

	FGetFloatAttribute_Ref parms{};	
	parms.BoneName = BoneName;
	parms.AttributeName = AttributeName;
	parms.OutValue = OutValue;
	parms.LookupType = LookupType;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool USkeletalMeshComponent::GetFloatAttribute(struct FName& BoneName, struct FName& AttributeName, float DefaultValue, float& OutValue, uint8_t LookupType){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetFloatAttribute");

	FGetFloatAttribute parms{};	
	parms.BoneName = BoneName;
	parms.AttributeName = AttributeName;
	parms.DefaultValue = DefaultValue;
	parms.OutValue = OutValue;
	parms.LookupType = LookupType;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool USkeletalMeshComponent::GetDisablePostProcessBlueprint(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetDisablePostProcessBlueprint");

	FGetDisablePostProcessBlueprint parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool USkeletalMeshComponent::GetDisableAnimCurves(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetDisableAnimCurves");

	FGetDisableAnimCurves parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void USkeletalMeshComponent::GetCurrentJointAngles(struct FName InBoneName, float& Swing1Angle, float& TwistAngle, float& Swing2Angle){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetCurrentJointAngles");

	FGetCurrentJointAngles parms{};	
	parms.InBoneName = InBoneName;
	parms.Swing1Angle = Swing1Angle;
	parms.TwistAngle = TwistAngle;
	parms.Swing2Angle = Swing2Angle;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::GetConstraintsFromBody(struct FName BodyName, bool bParentConstraints, bool bChildConstraints, bool bIncludesTerminated, struct TArray<struct FConstraintInstanceAccessor>& OutConstraints){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetConstraintsFromBody");

	FGetConstraintsFromBody parms{};	
	parms.BodyName = BodyName;
	parms.bParentConstraints = bParentConstraints;
	parms.bChildConstraints = bChildConstraints;
	parms.bIncludesTerminated = bIncludesTerminated;
	parms.OutConstraints = OutConstraints;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::GetConstraints(bool bIncludesTerminated, struct TArray<struct FConstraintInstanceAccessor>& OutConstraints){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetConstraints");

	FGetConstraints parms{};	
	parms.bIncludesTerminated = bIncludesTerminated;
	parms.OutConstraints = OutConstraints;

	ProcessEvent(fn, &parms);
}

struct FConstraintInstanceAccessor USkeletalMeshComponent::GetConstraintByName(struct FName ConstraintName, bool bIncludesTerminated){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetConstraintByName");

	FGetConstraintByName parms{};	
	parms.ConstraintName = ConstraintName;
	parms.bIncludesTerminated = bIncludesTerminated;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float USkeletalMeshComponent::GetClothMaxDistanceScale(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetClothMaxDistanceScale");

	FGetClothMaxDistanceScale parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UClothingSimulationInteractor* USkeletalMeshComponent::GetClothingSimulationInteractor(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetClothingSimulationInteractor");

	FGetClothingSimulationInteractor parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float USkeletalMeshComponent::GetBoneMass(struct FName BoneName, bool bScaleMass){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetBoneMass");

	FGetBoneMass parms{};	
	parms.BoneName = BoneName;
	parms.bScaleMass = bScaleMass;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USkeletalMeshComponent::GetBoneLinearVelocity(struct FName& InBoneName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetBoneLinearVelocity");

	FGetBoneLinearVelocity parms{};	
	parms.InBoneName = InBoneName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UAnimInstance* USkeletalMeshComponent::GetAnimInstance(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetAnimInstance");

	FGetAnimInstance parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

UObject* USkeletalMeshComponent::GetAnimClass(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetAnimClass");

	FGetAnimClass parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

enum class EAnimationMode USkeletalMeshComponent::GetAnimationMode(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetAnimationMode");

	FGetAnimationMode parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool USkeletalMeshComponent::GetAllowRigidBodyAnimNode(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetAllowRigidBodyAnimNode");

	FGetAllowRigidBodyAnimNode parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool USkeletalMeshComponent::GetAllowedAnimCurveEvaluate(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetAllowedAnimCurveEvaluate");

	FGetAllowedAnimCurveEvaluate parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool USkeletalMeshComponent::GetAllowClothActors(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetAllowClothActors");

	FGetAllowClothActors parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void USkeletalMeshComponent::ForceClothNextUpdateTeleportAndReset(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.ForceClothNextUpdateTeleportAndReset");

	FForceClothNextUpdateTeleportAndReset parms{};	

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::ForceClothNextUpdateTeleport(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.ForceClothNextUpdateTeleport");

	FForceClothNextUpdateTeleport parms{};	

	ProcessEvent(fn, &parms);
}

struct FName USkeletalMeshComponent::FindConstraintBoneName(int32_t ConstraintIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.FindConstraintBoneName");

	FFindConstraintBoneName parms{};	
	parms.ConstraintIndex = ConstraintIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void USkeletalMeshComponent::ClearMorphTargets(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.ClearMorphTargets");

	FClearMorphTargets parms{};	

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::BreakConstraint(struct FVector Impulse, struct FVector HitLocation, struct FName InBoneName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.BreakConstraint");

	FBreakConstraint parms{};	
	parms.Impulse = Impulse;
	parms.HitLocation = HitLocation;
	parms.InBoneName = InBoneName;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::BindClothToLeaderPoseComponent(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.BindClothToLeaderPoseComponent");

	FBindClothToLeaderPoseComponent parms{};	

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::AllowAnimCurveEvaluation(struct FName NameOfCurve, bool bAllow){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.AllowAnimCurveEvaluation");

	FAllowAnimCurveEvaluation parms{};	
	parms.NameOfCurve = NameOfCurve;
	parms.bAllow = bAllow;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::AddImpulseToAllBodiesBelow(struct FVector Impulse, struct FName BoneName, bool bVelChange, bool bIncludeSelf){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.AddImpulseToAllBodiesBelow");

	FAddImpulseToAllBodiesBelow parms{};	
	parms.Impulse = Impulse;
	parms.BoneName = BoneName;
	parms.bVelChange = bVelChange;
	parms.bIncludeSelf = bIncludeSelf;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::AddForceToAllBodiesBelow(struct FVector Force, struct FName BoneName, bool bAccelChange, bool bIncludeSelf){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.AddForceToAllBodiesBelow");

	FAddForceToAllBodiesBelow parms{};	
	parms.Force = Force;
	parms.BoneName = BoneName;
	parms.bAccelChange = bAccelChange;
	parms.bIncludeSelf = bIncludeSelf;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshComponent::AccumulateAllBodiesBelowPhysicsBlendWeight(struct FName& InBoneName, float AddPhysicsBlendWeight, bool bSkipCustomPhysicsType){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.AccumulateAllBodiesBelowPhysicsBlendWeight");

	FAccumulateAllBodiesBelowPhysicsBlendWeight parms{};	
	parms.InBoneName = InBoneName;
	parms.AddPhysicsBlendWeight = AddPhysicsBlendWeight;
	parms.bSkipCustomPhysicsType = bSkipCustomPhysicsType;

	ProcessEvent(fn, &parms);
}

void ACharacter::UnCrouch(bool bClientSimulation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.UnCrouch");

	FUnCrouch parms{};	
	parms.bClientSimulation = bClientSimulation;

	ProcessEvent(fn, &parms);
}

void ACharacter::StopJumping(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.StopJumping");

	FStopJumping parms{};	

	ProcessEvent(fn, &parms);
}

void ACharacter::StopAnimMontage(struct UAnimMontage* AnimMontage){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.StopAnimMontage");

	FStopAnimMontage parms{};	
	parms.AnimMontage = AnimMontage;

	ProcessEvent(fn, &parms);
}

void ACharacter::ServerMovePacked(struct FCharacterServerMovePackedBits PackedBits){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.ServerMovePacked");

	FServerMovePacked parms{};	
	parms.PackedBits = PackedBits;

	ProcessEvent(fn, &parms);
}

void ACharacter::ServerMoveOld(float OldTimeStamp, struct FVector_NetQuantize10 OldAccel, char OldMoveFlags){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.ServerMoveOld");

	FServerMoveOld parms{};	
	parms.OldTimeStamp = OldTimeStamp;
	parms.OldAccel = OldAccel;
	parms.OldMoveFlags = OldMoveFlags;

	ProcessEvent(fn, &parms);
}

void ACharacter::ServerMoveNoBase(float Timestamp, struct FVector_NetQuantize10 InAccel, struct FVector_NetQuantize100 ClientLoc, char CompressedMoveFlags, char ClientRoll, uint32_t View, char ClientMovementMode){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.ServerMoveNoBase");

	FServerMoveNoBase parms{};	
	parms.Timestamp = Timestamp;
	parms.InAccel = InAccel;
	parms.ClientLoc = ClientLoc;
	parms.CompressedMoveFlags = CompressedMoveFlags;
	parms.ClientRoll = ClientRoll;
	parms.View = View;
	parms.ClientMovementMode = ClientMovementMode;

	ProcessEvent(fn, &parms);
}

void ACharacter::ServerMoveDualNoBase(float TimeStamp0, struct FVector_NetQuantize10 InAccel0, char PendingFlags, uint32_t View0, float Timestamp, struct FVector_NetQuantize10 InAccel, struct FVector_NetQuantize100 ClientLoc, char NewFlags, char ClientRoll, uint32_t View, char ClientMovementMode){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.ServerMoveDualNoBase");

	FServerMoveDualNoBase parms{};	
	parms.TimeStamp0 = TimeStamp0;
	parms.InAccel0 = InAccel0;
	parms.PendingFlags = PendingFlags;
	parms.View0 = View0;
	parms.Timestamp = Timestamp;
	parms.InAccel = InAccel;
	parms.ClientLoc = ClientLoc;
	parms.NewFlags = NewFlags;
	parms.ClientRoll = ClientRoll;
	parms.View = View;
	parms.ClientMovementMode = ClientMovementMode;

	ProcessEvent(fn, &parms);
}

void ACharacter::ServerMoveDualHybridRootMotion(float TimeStamp0, struct FVector_NetQuantize10 InAccel0, char PendingFlags, uint32_t View0, float Timestamp, struct FVector_NetQuantize10 InAccel, struct FVector_NetQuantize100 ClientLoc, char NewFlags, char ClientRoll, uint32_t View, struct UPrimitiveComponent* ClientMovementBase, struct FName ClientBaseBoneName, char ClientMovementMode){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.ServerMoveDualHybridRootMotion");

	FServerMoveDualHybridRootMotion parms{};	
	parms.TimeStamp0 = TimeStamp0;
	parms.InAccel0 = InAccel0;
	parms.PendingFlags = PendingFlags;
	parms.View0 = View0;
	parms.Timestamp = Timestamp;
	parms.InAccel = InAccel;
	parms.ClientLoc = ClientLoc;
	parms.NewFlags = NewFlags;
	parms.ClientRoll = ClientRoll;
	parms.View = View;
	parms.ClientMovementBase = ClientMovementBase;
	parms.ClientBaseBoneName = ClientBaseBoneName;
	parms.ClientMovementMode = ClientMovementMode;

	ProcessEvent(fn, &parms);
}

void ACharacter::ServerMoveDual(float TimeStamp0, struct FVector_NetQuantize10 InAccel0, char PendingFlags, uint32_t View0, float Timestamp, struct FVector_NetQuantize10 InAccel, struct FVector_NetQuantize100 ClientLoc, char NewFlags, char ClientRoll, uint32_t View, struct UPrimitiveComponent* ClientMovementBase, struct FName ClientBaseBoneName, char ClientMovementMode){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.ServerMoveDual");

	FServerMoveDual parms{};	
	parms.TimeStamp0 = TimeStamp0;
	parms.InAccel0 = InAccel0;
	parms.PendingFlags = PendingFlags;
	parms.View0 = View0;
	parms.Timestamp = Timestamp;
	parms.InAccel = InAccel;
	parms.ClientLoc = ClientLoc;
	parms.NewFlags = NewFlags;
	parms.ClientRoll = ClientRoll;
	parms.View = View;
	parms.ClientMovementBase = ClientMovementBase;
	parms.ClientBaseBoneName = ClientBaseBoneName;
	parms.ClientMovementMode = ClientMovementMode;

	ProcessEvent(fn, &parms);
}

void ACharacter::ServerMove(float Timestamp, struct FVector_NetQuantize10 InAccel, struct FVector_NetQuantize100 ClientLoc, char CompressedMoveFlags, char ClientRoll, uint32_t View, struct UPrimitiveComponent* ClientMovementBase, struct FName ClientBaseBoneName, char ClientMovementMode){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.ServerMove");

	FServerMove parms{};	
	parms.Timestamp = Timestamp;
	parms.InAccel = InAccel;
	parms.ClientLoc = ClientLoc;
	parms.CompressedMoveFlags = CompressedMoveFlags;
	parms.ClientRoll = ClientRoll;
	parms.View = View;
	parms.ClientMovementBase = ClientMovementBase;
	parms.ClientBaseBoneName = ClientBaseBoneName;
	parms.ClientMovementMode = ClientMovementMode;

	ProcessEvent(fn, &parms);
}

void ACharacter::RootMotionDebugClientPrintOnScreen(struct FString InString){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.RootMotionDebugClientPrintOnScreen");

	FRootMotionDebugClientPrintOnScreen parms{};	
	parms.InString = InString;

	ProcessEvent(fn, &parms);
}

float ACharacter::PlayAnimMontage(struct UAnimMontage* AnimMontage, float InPlayRate, struct FName StartSectionName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.PlayAnimMontage");

	FPlayAnimMontage parms{};	
	parms.AnimMontage = AnimMontage;
	parms.InPlayRate = InPlayRate;
	parms.StartSectionName = StartSectionName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void ACharacter::OnWalkingOffLedge(struct FVector& PreviousFloorImpactNormal, struct FVector& PreviousFloorContactNormal, struct FVector& PreviousLocation, float TimeDelta){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.OnWalkingOffLedge");

	FOnWalkingOffLedge parms{};	
	parms.PreviousFloorImpactNormal = PreviousFloorImpactNormal;
	parms.PreviousFloorContactNormal = PreviousFloorContactNormal;
	parms.PreviousLocation = PreviousLocation;
	parms.TimeDelta = TimeDelta;

	ProcessEvent(fn, &parms);
}

void ACharacter::OnRep_RootMotion(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.OnRep_RootMotion");

	FOnRep_RootMotion parms{};	

	ProcessEvent(fn, &parms);
}

void ACharacter::OnRep_ReplicatedBasedMovement(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.OnRep_ReplicatedBasedMovement");

	FOnRep_ReplicatedBasedMovement parms{};	

	ProcessEvent(fn, &parms);
}

void ACharacter::OnRep_ReplayLastTransformUpdateTimeStamp(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.OnRep_ReplayLastTransformUpdateTimeStamp");

	FOnRep_ReplayLastTransformUpdateTimeStamp parms{};	

	ProcessEvent(fn, &parms);
}

void ACharacter::OnRep_IsCrouched(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.OnRep_IsCrouched");

	FOnRep_IsCrouched parms{};	

	ProcessEvent(fn, &parms);
}

void ACharacter::OnLaunched(struct FVector LaunchVelocity, bool bXYOverride, bool bZOverride){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.OnLaunched");

	FOnLaunched parms{};	
	parms.LaunchVelocity = LaunchVelocity;
	parms.bXYOverride = bXYOverride;
	parms.bZOverride = bZOverride;

	ProcessEvent(fn, &parms);
}

void ACharacter::OnLanded(struct FHitResult& Hit){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.OnLanded");

	FOnLanded parms{};	
	parms.Hit = Hit;

	ProcessEvent(fn, &parms);
}

void ACharacter::OnJumped(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.OnJumped");

	FOnJumped parms{};	

	ProcessEvent(fn, &parms);
}

void ACharacter::LaunchCharacter(struct FVector LaunchVelocity, bool bXYOverride, bool bZOverride){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.LaunchCharacter");

	FLaunchCharacter parms{};	
	parms.LaunchVelocity = LaunchVelocity;
	parms.bXYOverride = bXYOverride;
	parms.bZOverride = bZOverride;

	ProcessEvent(fn, &parms);
}

void ACharacter::K2_UpdateCustomMovement(float DeltaTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.K2_UpdateCustomMovement");

	FK2_UpdateCustomMovement parms{};	
	parms.DeltaTime = DeltaTime;

	ProcessEvent(fn, &parms);
}

void ACharacter::K2_OnStartCrouch(float HalfHeightAdjust, float ScaledHalfHeightAdjust){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.K2_OnStartCrouch");

	FK2_OnStartCrouch parms{};	
	parms.HalfHeightAdjust = HalfHeightAdjust;
	parms.ScaledHalfHeightAdjust = ScaledHalfHeightAdjust;

	ProcessEvent(fn, &parms);
}

void ACharacter::K2_OnMovementModeChanged(enum class EMovementMode PrevMovementMode, enum class EMovementMode NewMovementMode, char PrevCustomMode, char NewCustomMode){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.K2_OnMovementModeChanged");

	FK2_OnMovementModeChanged parms{};	
	parms.PrevMovementMode = PrevMovementMode;
	parms.NewMovementMode = NewMovementMode;
	parms.PrevCustomMode = PrevCustomMode;
	parms.NewCustomMode = NewCustomMode;

	ProcessEvent(fn, &parms);
}

void ACharacter::K2_OnEndCrouch(float HalfHeightAdjust, float ScaledHalfHeightAdjust){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.K2_OnEndCrouch");

	FK2_OnEndCrouch parms{};	
	parms.HalfHeightAdjust = HalfHeightAdjust;
	parms.ScaledHalfHeightAdjust = ScaledHalfHeightAdjust;

	ProcessEvent(fn, &parms);
}

void ACharacter::Jump(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.Jump");

	FJump parms{};	

	ProcessEvent(fn, &parms);
}

bool ACharacter::IsPlayingRootMotion(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.IsPlayingRootMotion");

	FIsPlayingRootMotion parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool ACharacter::IsPlayingNetworkedRootMotionMontage(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.IsPlayingNetworkedRootMotionMontage");

	FIsPlayingNetworkedRootMotionMontage parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool ACharacter::IsJumpProvidingForce(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.IsJumpProvidingForce");

	FIsJumpProvidingForce parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool ACharacter::HasAnyRootMotion(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.HasAnyRootMotion");

	FHasAnyRootMotion parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UAnimMontage* ACharacter::GetCurrentMontage(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.GetCurrentMontage");

	FGetCurrentMontage parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector ACharacter::GetBaseTranslationOffset(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.GetBaseTranslationOffset");

	FGetBaseTranslationOffset parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator ACharacter::GetBaseRotationOffsetRotator(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.GetBaseRotationOffsetRotator");

	FGetBaseRotationOffsetRotator parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float ACharacter::GetAnimRootMotionTranslationScale(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.GetAnimRootMotionTranslationScale");

	FGetAnimRootMotionTranslationScale parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void ACharacter::Crouch(bool bClientSimulation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.Crouch");

	FCrouch parms{};	
	parms.bClientSimulation = bClientSimulation;

	ProcessEvent(fn, &parms);
}

void ACharacter::ClientVeryShortAdjustPosition(float Timestamp, struct FVector NewLoc, struct UPrimitiveComponent* NewBase, struct FName NewBaseBoneName, bool bHasBase, bool bBaseRelativePosition, char ServerMovementMode){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.ClientVeryShortAdjustPosition");

	FClientVeryShortAdjustPosition parms{};	
	parms.Timestamp = Timestamp;
	parms.NewLoc = NewLoc;
	parms.NewBase = NewBase;
	parms.NewBaseBoneName = NewBaseBoneName;
	parms.bHasBase = bHasBase;
	parms.bBaseRelativePosition = bBaseRelativePosition;
	parms.ServerMovementMode = ServerMovementMode;

	ProcessEvent(fn, &parms);
}

void ACharacter::ClientMoveResponsePacked(struct FCharacterMoveResponsePackedBits PackedBits){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.ClientMoveResponsePacked");

	FClientMoveResponsePacked parms{};	
	parms.PackedBits = PackedBits;

	ProcessEvent(fn, &parms);
}

void ACharacter::ClientCheatWalk(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.ClientCheatWalk");

	FClientCheatWalk parms{};	

	ProcessEvent(fn, &parms);
}

void ACharacter::ClientCheatGhost(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.ClientCheatGhost");

	FClientCheatGhost parms{};	

	ProcessEvent(fn, &parms);
}

void ACharacter::ClientCheatFly(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.ClientCheatFly");

	FClientCheatFly parms{};	

	ProcessEvent(fn, &parms);
}

void ACharacter::ClientAdjustRootMotionSourcePosition(float Timestamp, struct FRootMotionSourceGroup ServerRootMotion, bool bHasAnimRootMotion, float ServerMontageTrackPosition, struct FVector ServerLoc, struct FVector_NetQuantizeNormal ServerRotation, float ServerVelZ, struct UPrimitiveComponent* ServerBase, struct FName ServerBoneName, bool bHasBase, bool bBaseRelativePosition, char ServerMovementMode){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.ClientAdjustRootMotionSourcePosition");

	FClientAdjustRootMotionSourcePosition parms{};	
	parms.Timestamp = Timestamp;
	parms.ServerRootMotion = ServerRootMotion;
	parms.bHasAnimRootMotion = bHasAnimRootMotion;
	parms.ServerMontageTrackPosition = ServerMontageTrackPosition;
	parms.ServerLoc = ServerLoc;
	parms.ServerRotation = ServerRotation;
	parms.ServerVelZ = ServerVelZ;
	parms.ServerBase = ServerBase;
	parms.ServerBoneName = ServerBoneName;
	parms.bHasBase = bHasBase;
	parms.bBaseRelativePosition = bBaseRelativePosition;
	parms.ServerMovementMode = ServerMovementMode;

	ProcessEvent(fn, &parms);
}

void ACharacter::ClientAdjustRootMotionPosition(float Timestamp, float ServerMontageTrackPosition, struct FVector ServerLoc, struct FVector_NetQuantizeNormal ServerRotation, float ServerVelZ, struct UPrimitiveComponent* ServerBase, struct FName ServerBoneName, bool bHasBase, bool bBaseRelativePosition, char ServerMovementMode){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.ClientAdjustRootMotionPosition");

	FClientAdjustRootMotionPosition parms{};	
	parms.Timestamp = Timestamp;
	parms.ServerMontageTrackPosition = ServerMontageTrackPosition;
	parms.ServerLoc = ServerLoc;
	parms.ServerRotation = ServerRotation;
	parms.ServerVelZ = ServerVelZ;
	parms.ServerBase = ServerBase;
	parms.ServerBoneName = ServerBoneName;
	parms.bHasBase = bHasBase;
	parms.bBaseRelativePosition = bBaseRelativePosition;
	parms.ServerMovementMode = ServerMovementMode;

	ProcessEvent(fn, &parms);
}

void ACharacter::ClientAdjustPosition(float Timestamp, struct FVector NewLoc, struct FVector NewVel, struct UPrimitiveComponent* NewBase, struct FName NewBaseBoneName, bool bHasBase, bool bBaseRelativePosition, char ServerMovementMode){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.ClientAdjustPosition");

	FClientAdjustPosition parms{};	
	parms.Timestamp = Timestamp;
	parms.NewLoc = NewLoc;
	parms.NewVel = NewVel;
	parms.NewBase = NewBase;
	parms.NewBaseBoneName = NewBaseBoneName;
	parms.bHasBase = bHasBase;
	parms.bBaseRelativePosition = bBaseRelativePosition;
	parms.ServerMovementMode = ServerMovementMode;

	ProcessEvent(fn, &parms);
}

void ACharacter::ClientAckGoodMove(float Timestamp){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.ClientAckGoodMove");

	FClientAckGoodMove parms{};	
	parms.Timestamp = Timestamp;

	ProcessEvent(fn, &parms);
}

bool ACharacter::CanJumpInternal(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.CanJumpInternal");

	FCanJumpInternal parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool ACharacter::CanJump(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.CanJump");

	FCanJump parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool ACharacter::CanCrouch(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.CanCrouch");

	FCanCrouch parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void ACharacter::CacheInitialMeshOffset(struct FVector MeshRelativeLocation, struct FRotator MeshRelativeRotation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Character.CacheInitialMeshOffset");

	FCacheInitialMeshOffset parms{};	
	parms.MeshRelativeLocation = MeshRelativeLocation;
	parms.MeshRelativeRotation = MeshRelativeRotation;

	ProcessEvent(fn, &parms);
}

void UMeshComponent::SetVectorParameterValueOnMaterials(struct FName ParameterName, struct FVector ParameterValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MeshComponent.SetVectorParameterValueOnMaterials");

	FSetVectorParameterValueOnMaterials parms{};	
	parms.ParameterName = ParameterName;
	parms.ParameterValue = ParameterValue;

	ProcessEvent(fn, &parms);
}

void UMeshComponent::SetScalarParameterValueOnMaterials(struct FName ParameterName, float ParameterValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MeshComponent.SetScalarParameterValueOnMaterials");

	FSetScalarParameterValueOnMaterials parms{};	
	parms.ParameterName = ParameterName;
	parms.ParameterValue = ParameterValue;

	ProcessEvent(fn, &parms);
}

void UMeshComponent::SetOverlayMaterialMaxDrawDistance(float InMaxDrawDistance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MeshComponent.SetOverlayMaterialMaxDrawDistance");

	FSetOverlayMaterialMaxDrawDistance parms{};	
	parms.InMaxDrawDistance = InMaxDrawDistance;

	ProcessEvent(fn, &parms);
}

void UMeshComponent::SetOverlayMaterial(struct UMaterialInterface* NewOverlayMaterial){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MeshComponent.SetOverlayMaterial");

	FSetOverlayMaterial parms{};	
	parms.NewOverlayMaterial = NewOverlayMaterial;

	ProcessEvent(fn, &parms);
}

void UMeshComponent::PrestreamTextures(float Seconds, bool bPrioritizeCharacterTextures, int32_t CinematicTextureGroups){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MeshComponent.PrestreamTextures");

	FPrestreamTextures parms{};	
	parms.Seconds = Seconds;
	parms.bPrioritizeCharacterTextures = bPrioritizeCharacterTextures;
	parms.CinematicTextureGroups = CinematicTextureGroups;

	ProcessEvent(fn, &parms);
}

bool UMeshComponent::IsMaterialSlotNameValid(struct FName MaterialSlotName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MeshComponent.IsMaterialSlotNameValid");

	FIsMaterialSlotNameValid parms{};	
	parms.MaterialSlotName = MaterialSlotName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UMaterialInterface* UMeshComponent::GetOverlayMaterial(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MeshComponent.GetOverlayMaterial");

	FGetOverlayMaterial parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<struct FName> UMeshComponent::GetMaterialSlotNames(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MeshComponent.GetMaterialSlotNames");

	FGetMaterialSlotNames parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<struct UMaterialInterface*> UMeshComponent::GetMaterials(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MeshComponent.GetMaterials");

	FGetMaterials parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UMeshComponent::GetMaterialIndex(struct FName MaterialSlotName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MeshComponent.GetMaterialIndex");

	FGetMaterialIndex parms{};	
	parms.MaterialSlotName = MaterialSlotName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void USplineComponent::UpdateSpline(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.UpdateSpline");

	FUpdateSpline parms{};	

	ProcessEvent(fn, &parms);
}

void USplineComponent::SetWorldLocationAtSplinePoint(int32_t PointIndex, struct FVector& InLocation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetWorldLocationAtSplinePoint");

	FSetWorldLocationAtSplinePoint parms{};	
	parms.PointIndex = PointIndex;
	parms.InLocation = InLocation;

	ProcessEvent(fn, &parms);
}

void USplineComponent::SetUpVectorAtSplinePoint(int32_t PointIndex, struct FVector& InUpVector, enum class ESplineCoordinateSpace CoordinateSpace, bool bUpdateSpline){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetUpVectorAtSplinePoint");

	FSetUpVectorAtSplinePoint parms{};	
	parms.PointIndex = PointIndex;
	parms.InUpVector = InUpVector;
	parms.CoordinateSpace = CoordinateSpace;
	parms.bUpdateSpline = bUpdateSpline;

	ProcessEvent(fn, &parms);
}

void USplineComponent::SetUnselectedSplineSegmentColor(struct FLinearColor& SegmentColor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetUnselectedSplineSegmentColor");

	FSetUnselectedSplineSegmentColor parms{};	
	parms.SegmentColor = SegmentColor;

	ProcessEvent(fn, &parms);
}

void USplineComponent::SetTangentsAtSplinePoint(int32_t PointIndex, struct FVector& InArriveTangent, struct FVector& InLeaveTangent, enum class ESplineCoordinateSpace CoordinateSpace, bool bUpdateSpline){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetTangentsAtSplinePoint");

	FSetTangentsAtSplinePoint parms{};	
	parms.PointIndex = PointIndex;
	parms.InArriveTangent = InArriveTangent;
	parms.InLeaveTangent = InLeaveTangent;
	parms.CoordinateSpace = CoordinateSpace;
	parms.bUpdateSpline = bUpdateSpline;

	ProcessEvent(fn, &parms);
}

void USplineComponent::SetTangentColor(struct FLinearColor& TangentColor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetTangentColor");

	FSetTangentColor parms{};	
	parms.TangentColor = TangentColor;

	ProcessEvent(fn, &parms);
}

void USplineComponent::SetTangentAtSplinePoint(int32_t PointIndex, struct FVector& InTangent, enum class ESplineCoordinateSpace CoordinateSpace, bool bUpdateSpline){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetTangentAtSplinePoint");

	FSetTangentAtSplinePoint parms{};	
	parms.PointIndex = PointIndex;
	parms.InTangent = InTangent;
	parms.CoordinateSpace = CoordinateSpace;
	parms.bUpdateSpline = bUpdateSpline;

	ProcessEvent(fn, &parms);
}

void USplineComponent::SetSplineWorldPoints(struct TArray<struct FVector>& Points){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetSplineWorldPoints");

	FSetSplineWorldPoints parms{};	
	parms.Points = Points;

	ProcessEvent(fn, &parms);
}

void USplineComponent::SetSplinePointType(int32_t PointIndex, enum class ESplinePointType Type, bool bUpdateSpline){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetSplinePointType");

	FSetSplinePointType parms{};	
	parms.PointIndex = PointIndex;
	parms.Type = Type;
	parms.bUpdateSpline = bUpdateSpline;

	ProcessEvent(fn, &parms);
}

void USplineComponent::SetSplinePoints(struct TArray<struct FVector>& Points, enum class ESplineCoordinateSpace CoordinateSpace, bool bUpdateSpline){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetSplinePoints");

	FSetSplinePoints parms{};	
	parms.Points = Points;
	parms.CoordinateSpace = CoordinateSpace;
	parms.bUpdateSpline = bUpdateSpline;

	ProcessEvent(fn, &parms);
}

void USplineComponent::SetSplineLocalPoints(struct TArray<struct FVector>& Points){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetSplineLocalPoints");

	FSetSplineLocalPoints parms{};	
	parms.Points = Points;

	ProcessEvent(fn, &parms);
}

void USplineComponent::SetSelectedSplineSegmentColor(struct FLinearColor& SegmentColor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetSelectedSplineSegmentColor");

	FSetSelectedSplineSegmentColor parms{};	
	parms.SegmentColor = SegmentColor;

	ProcessEvent(fn, &parms);
}

void USplineComponent::SetScaleAtSplinePoint(int32_t PointIndex, struct FVector& InScaleVector, bool bUpdateSpline){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetScaleAtSplinePoint");

	FSetScaleAtSplinePoint parms{};	
	parms.PointIndex = PointIndex;
	parms.InScaleVector = InScaleVector;
	parms.bUpdateSpline = bUpdateSpline;

	ProcessEvent(fn, &parms);
}

void USplineComponent::SetRotationAtSplinePoint(int32_t PointIndex, struct FRotator& InRotation, enum class ESplineCoordinateSpace CoordinateSpace, bool bUpdateSpline){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetRotationAtSplinePoint");

	FSetRotationAtSplinePoint parms{};	
	parms.PointIndex = PointIndex;
	parms.InRotation = InRotation;
	parms.CoordinateSpace = CoordinateSpace;
	parms.bUpdateSpline = bUpdateSpline;

	ProcessEvent(fn, &parms);
}

void USplineComponent::SetLocationAtSplinePoint(int32_t PointIndex, struct FVector& InLocation, enum class ESplineCoordinateSpace CoordinateSpace, bool bUpdateSpline){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetLocationAtSplinePoint");

	FSetLocationAtSplinePoint parms{};	
	parms.PointIndex = PointIndex;
	parms.InLocation = InLocation;
	parms.CoordinateSpace = CoordinateSpace;
	parms.bUpdateSpline = bUpdateSpline;

	ProcessEvent(fn, &parms);
}

void USplineComponent::SetDrawDebug(bool bShow){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetDrawDebug");

	FSetDrawDebug parms{};	
	parms.bShow = bShow;

	ProcessEvent(fn, &parms);
}

void USplineComponent::SetDefaultUpVector(struct FVector& UpVector, enum class ESplineCoordinateSpace CoordinateSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetDefaultUpVector");

	FSetDefaultUpVector parms{};	
	parms.UpVector = UpVector;
	parms.CoordinateSpace = CoordinateSpace;

	ProcessEvent(fn, &parms);
}

void USplineComponent::SetClosedLoopAtPosition(bool bInClosedLoop, float Key, bool bUpdateSpline){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetClosedLoopAtPosition");

	FSetClosedLoopAtPosition parms{};	
	parms.bInClosedLoop = bInClosedLoop;
	parms.Key = Key;
	parms.bUpdateSpline = bUpdateSpline;

	ProcessEvent(fn, &parms);
}

void USplineComponent::SetClosedLoop(bool bInClosedLoop, bool bUpdateSpline){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetClosedLoop");

	FSetClosedLoop parms{};	
	parms.bInClosedLoop = bInClosedLoop;
	parms.bUpdateSpline = bUpdateSpline;

	ProcessEvent(fn, &parms);
}

void USplineComponent::RemoveSplinePoint(int32_t Index, bool bUpdateSpline){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.RemoveSplinePoint");

	FRemoveSplinePoint parms{};	
	parms.Index = Index;
	parms.bUpdateSpline = bUpdateSpline;

	ProcessEvent(fn, &parms);
}

bool USplineComponent::IsClosedLoop(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.IsClosedLoop");

	FIsClosedLoop parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineComponent::GetWorldTangentAtDistanceAlongSpline(float Distance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetWorldTangentAtDistanceAlongSpline");

	FGetWorldTangentAtDistanceAlongSpline parms{};	
	parms.Distance = Distance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator USplineComponent::GetWorldRotationAtTime(float Time, bool bUseConstantVelocity){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetWorldRotationAtTime");

	FGetWorldRotationAtTime parms{};	
	parms.Time = Time;
	parms.bUseConstantVelocity = bUseConstantVelocity;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator USplineComponent::GetWorldRotationAtDistanceAlongSpline(float Distance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetWorldRotationAtDistanceAlongSpline");

	FGetWorldRotationAtDistanceAlongSpline parms{};	
	parms.Distance = Distance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineComponent::GetWorldLocationAtTime(float Time, bool bUseConstantVelocity){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetWorldLocationAtTime");

	FGetWorldLocationAtTime parms{};	
	parms.Time = Time;
	parms.bUseConstantVelocity = bUseConstantVelocity;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineComponent::GetWorldLocationAtSplinePoint(int32_t PointIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetWorldLocationAtSplinePoint");

	FGetWorldLocationAtSplinePoint parms{};	
	parms.PointIndex = PointIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineComponent::GetWorldLocationAtDistanceAlongSpline(float Distance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetWorldLocationAtDistanceAlongSpline");

	FGetWorldLocationAtDistanceAlongSpline parms{};	
	parms.Distance = Distance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineComponent::GetWorldDirectionAtTime(float Time, bool bUseConstantVelocity){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetWorldDirectionAtTime");

	FGetWorldDirectionAtTime parms{};	
	parms.Time = Time;
	parms.bUseConstantVelocity = bUseConstantVelocity;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineComponent::GetWorldDirectionAtDistanceAlongSpline(float Distance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetWorldDirectionAtDistanceAlongSpline");

	FGetWorldDirectionAtDistanceAlongSpline parms{};	
	parms.Distance = Distance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineComponent::GetVectorPropertyAtSplinePoint(int32_t Index, struct FName PropertyName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetVectorPropertyAtSplinePoint");

	FGetVectorPropertyAtSplinePoint parms{};	
	parms.Index = Index;
	parms.PropertyName = PropertyName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineComponent::GetVectorPropertyAtSplineInputKey(float InKey, struct FName PropertyName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetVectorPropertyAtSplineInputKey");

	FGetVectorPropertyAtSplineInputKey parms{};	
	parms.InKey = InKey;
	parms.PropertyName = PropertyName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineComponent::GetUpVectorAtTime(float Time, enum class ESplineCoordinateSpace CoordinateSpace, bool bUseConstantVelocity){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetUpVectorAtTime");

	FGetUpVectorAtTime parms{};	
	parms.Time = Time;
	parms.CoordinateSpace = CoordinateSpace;
	parms.bUseConstantVelocity = bUseConstantVelocity;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineComponent::GetUpVectorAtSplinePoint(int32_t PointIndex, enum class ESplineCoordinateSpace CoordinateSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetUpVectorAtSplinePoint");

	FGetUpVectorAtSplinePoint parms{};	
	parms.PointIndex = PointIndex;
	parms.CoordinateSpace = CoordinateSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineComponent::GetUpVectorAtSplineInputKey(float InKey, enum class ESplineCoordinateSpace CoordinateSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetUpVectorAtSplineInputKey");

	FGetUpVectorAtSplineInputKey parms{};	
	parms.InKey = InKey;
	parms.CoordinateSpace = CoordinateSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineComponent::GetUpVectorAtDistanceAlongSpline(float Distance, enum class ESplineCoordinateSpace CoordinateSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetUpVectorAtDistanceAlongSpline");

	FGetUpVectorAtDistanceAlongSpline parms{};	
	parms.Distance = Distance;
	parms.CoordinateSpace = CoordinateSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTransform USplineComponent::GetTransformAtTime(float Time, enum class ESplineCoordinateSpace CoordinateSpace, bool bUseConstantVelocity, bool bUseScale){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetTransformAtTime");

	FGetTransformAtTime parms{};	
	parms.Time = Time;
	parms.CoordinateSpace = CoordinateSpace;
	parms.bUseConstantVelocity = bUseConstantVelocity;
	parms.bUseScale = bUseScale;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTransform USplineComponent::GetTransformAtSplinePoint(int32_t PointIndex, enum class ESplineCoordinateSpace CoordinateSpace, bool bUseScale){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetTransformAtSplinePoint");

	FGetTransformAtSplinePoint parms{};	
	parms.PointIndex = PointIndex;
	parms.CoordinateSpace = CoordinateSpace;
	parms.bUseScale = bUseScale;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTransform USplineComponent::GetTransformAtSplineInputKey(float InKey, enum class ESplineCoordinateSpace CoordinateSpace, bool bUseScale){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetTransformAtSplineInputKey");

	FGetTransformAtSplineInputKey parms{};	
	parms.InKey = InKey;
	parms.CoordinateSpace = CoordinateSpace;
	parms.bUseScale = bUseScale;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTransform USplineComponent::GetTransformAtDistanceAlongSpline(float Distance, enum class ESplineCoordinateSpace CoordinateSpace, bool bUseScale){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetTransformAtDistanceAlongSpline");

	FGetTransformAtDistanceAlongSpline parms{};	
	parms.Distance = Distance;
	parms.CoordinateSpace = CoordinateSpace;
	parms.bUseScale = bUseScale;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float USplineComponent::GetTimeAtDistanceAlongSpline(float Distance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetTimeAtDistanceAlongSpline");

	FGetTimeAtDistanceAlongSpline parms{};	
	parms.Distance = Distance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineComponent::GetTangentAtTime(float Time, enum class ESplineCoordinateSpace CoordinateSpace, bool bUseConstantVelocity){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetTangentAtTime");

	FGetTangentAtTime parms{};	
	parms.Time = Time;
	parms.CoordinateSpace = CoordinateSpace;
	parms.bUseConstantVelocity = bUseConstantVelocity;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineComponent::GetTangentAtSplinePoint(int32_t PointIndex, enum class ESplineCoordinateSpace CoordinateSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetTangentAtSplinePoint");

	FGetTangentAtSplinePoint parms{};	
	parms.PointIndex = PointIndex;
	parms.CoordinateSpace = CoordinateSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineComponent::GetTangentAtSplineInputKey(float InKey, enum class ESplineCoordinateSpace CoordinateSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetTangentAtSplineInputKey");

	FGetTangentAtSplineInputKey parms{};	
	parms.InKey = InKey;
	parms.CoordinateSpace = CoordinateSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineComponent::GetTangentAtDistanceAlongSpline(float Distance, enum class ESplineCoordinateSpace CoordinateSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetTangentAtDistanceAlongSpline");

	FGetTangentAtDistanceAlongSpline parms{};	
	parms.Distance = Distance;
	parms.CoordinateSpace = CoordinateSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

enum class ESplinePointType USplineComponent::GetSplinePointType(int32_t PointIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetSplinePointType");

	FGetSplinePointType parms{};	
	parms.PointIndex = PointIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float USplineComponent::GetSplineLength(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetSplineLength");

	FGetSplineLength parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineComponent::GetScaleAtTime(float Time, bool bUseConstantVelocity){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetScaleAtTime");

	FGetScaleAtTime parms{};	
	parms.Time = Time;
	parms.bUseConstantVelocity = bUseConstantVelocity;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineComponent::GetScaleAtSplinePoint(int32_t PointIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetScaleAtSplinePoint");

	FGetScaleAtSplinePoint parms{};	
	parms.PointIndex = PointIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineComponent::GetScaleAtSplineInputKey(float InKey){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetScaleAtSplineInputKey");

	FGetScaleAtSplineInputKey parms{};	
	parms.InKey = InKey;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineComponent::GetScaleAtDistanceAlongSpline(float Distance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetScaleAtDistanceAlongSpline");

	FGetScaleAtDistanceAlongSpline parms{};	
	parms.Distance = Distance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator USplineComponent::GetRotationAtTime(float Time, enum class ESplineCoordinateSpace CoordinateSpace, bool bUseConstantVelocity){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRotationAtTime");

	FGetRotationAtTime parms{};	
	parms.Time = Time;
	parms.CoordinateSpace = CoordinateSpace;
	parms.bUseConstantVelocity = bUseConstantVelocity;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator USplineComponent::GetRotationAtSplinePoint(int32_t PointIndex, enum class ESplineCoordinateSpace CoordinateSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRotationAtSplinePoint");

	FGetRotationAtSplinePoint parms{};	
	parms.PointIndex = PointIndex;
	parms.CoordinateSpace = CoordinateSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator USplineComponent::GetRotationAtSplineInputKey(float InKey, enum class ESplineCoordinateSpace CoordinateSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRotationAtSplineInputKey");

	FGetRotationAtSplineInputKey parms{};	
	parms.InKey = InKey;
	parms.CoordinateSpace = CoordinateSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator USplineComponent::GetRotationAtDistanceAlongSpline(float Distance, enum class ESplineCoordinateSpace CoordinateSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRotationAtDistanceAlongSpline");

	FGetRotationAtDistanceAlongSpline parms{};	
	parms.Distance = Distance;
	parms.CoordinateSpace = CoordinateSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float USplineComponent::GetRollAtTime(float Time, enum class ESplineCoordinateSpace CoordinateSpace, bool bUseConstantVelocity){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRollAtTime");

	FGetRollAtTime parms{};	
	parms.Time = Time;
	parms.CoordinateSpace = CoordinateSpace;
	parms.bUseConstantVelocity = bUseConstantVelocity;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float USplineComponent::GetRollAtSplinePoint(int32_t PointIndex, enum class ESplineCoordinateSpace CoordinateSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRollAtSplinePoint");

	FGetRollAtSplinePoint parms{};	
	parms.PointIndex = PointIndex;
	parms.CoordinateSpace = CoordinateSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float USplineComponent::GetRollAtSplineInputKey(float InKey, enum class ESplineCoordinateSpace CoordinateSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRollAtSplineInputKey");

	FGetRollAtSplineInputKey parms{};	
	parms.InKey = InKey;
	parms.CoordinateSpace = CoordinateSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float USplineComponent::GetRollAtDistanceAlongSpline(float Distance, enum class ESplineCoordinateSpace CoordinateSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRollAtDistanceAlongSpline");

	FGetRollAtDistanceAlongSpline parms{};	
	parms.Distance = Distance;
	parms.CoordinateSpace = CoordinateSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineComponent::GetRightVectorAtTime(float Time, enum class ESplineCoordinateSpace CoordinateSpace, bool bUseConstantVelocity){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRightVectorAtTime");

	FGetRightVectorAtTime parms{};	
	parms.Time = Time;
	parms.CoordinateSpace = CoordinateSpace;
	parms.bUseConstantVelocity = bUseConstantVelocity;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineComponent::GetRightVectorAtSplinePoint(int32_t PointIndex, enum class ESplineCoordinateSpace CoordinateSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRightVectorAtSplinePoint");

	FGetRightVectorAtSplinePoint parms{};	
	parms.PointIndex = PointIndex;
	parms.CoordinateSpace = CoordinateSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineComponent::GetRightVectorAtSplineInputKey(float InKey, enum class ESplineCoordinateSpace CoordinateSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRightVectorAtSplineInputKey");

	FGetRightVectorAtSplineInputKey parms{};	
	parms.InKey = InKey;
	parms.CoordinateSpace = CoordinateSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineComponent::GetRightVectorAtDistanceAlongSpline(float Distance, enum class ESplineCoordinateSpace CoordinateSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRightVectorAtDistanceAlongSpline");

	FGetRightVectorAtDistanceAlongSpline parms{};	
	parms.Distance = Distance;
	parms.CoordinateSpace = CoordinateSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t USplineComponent::GetNumberOfSplineSegments(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetNumberOfSplineSegments");

	FGetNumberOfSplineSegments parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t USplineComponent::GetNumberOfSplinePoints(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetNumberOfSplinePoints");

	FGetNumberOfSplinePoints parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineComponent::GetLocationAtTime(float Time, enum class ESplineCoordinateSpace CoordinateSpace, bool bUseConstantVelocity){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetLocationAtTime");

	FGetLocationAtTime parms{};	
	parms.Time = Time;
	parms.CoordinateSpace = CoordinateSpace;
	parms.bUseConstantVelocity = bUseConstantVelocity;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineComponent::GetLocationAtSplinePoint(int32_t PointIndex, enum class ESplineCoordinateSpace CoordinateSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetLocationAtSplinePoint");

	FGetLocationAtSplinePoint parms{};	
	parms.PointIndex = PointIndex;
	parms.CoordinateSpace = CoordinateSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineComponent::GetLocationAtSplineInputKey(float InKey, enum class ESplineCoordinateSpace CoordinateSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetLocationAtSplineInputKey");

	FGetLocationAtSplineInputKey parms{};	
	parms.InKey = InKey;
	parms.CoordinateSpace = CoordinateSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineComponent::GetLocationAtDistanceAlongSpline(float Distance, enum class ESplineCoordinateSpace CoordinateSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetLocationAtDistanceAlongSpline");

	FGetLocationAtDistanceAlongSpline parms{};	
	parms.Distance = Distance;
	parms.CoordinateSpace = CoordinateSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void USplineComponent::GetLocationAndTangentAtSplinePoint(int32_t PointIndex, struct FVector& Location, struct FVector& Tangent, enum class ESplineCoordinateSpace CoordinateSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetLocationAndTangentAtSplinePoint");

	FGetLocationAndTangentAtSplinePoint parms{};	
	parms.PointIndex = PointIndex;
	parms.Location = Location;
	parms.Tangent = Tangent;
	parms.CoordinateSpace = CoordinateSpace;

	ProcessEvent(fn, &parms);
}

void USplineComponent::GetLocalLocationAndTangentAtSplinePoint(int32_t PointIndex, struct FVector& LocalLocation, struct FVector& LocalTangent){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetLocalLocationAndTangentAtSplinePoint");

	FGetLocalLocationAndTangentAtSplinePoint parms{};	
	parms.PointIndex = PointIndex;
	parms.LocalLocation = LocalLocation;
	parms.LocalTangent = LocalTangent;

	ProcessEvent(fn, &parms);
}

struct FVector USplineComponent::GetLeaveTangentAtSplinePoint(int32_t PointIndex, enum class ESplineCoordinateSpace CoordinateSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetLeaveTangentAtSplinePoint");

	FGetLeaveTangentAtSplinePoint parms{};	
	parms.PointIndex = PointIndex;
	parms.CoordinateSpace = CoordinateSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float USplineComponent::GetInputKeyValueAtDistanceAlongSpline(float Distance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetInputKeyValueAtDistanceAlongSpline");

	FGetInputKeyValueAtDistanceAlongSpline parms{};	
	parms.Distance = Distance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float USplineComponent::GetInputKeyAtDistanceAlongSpline(float Distance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetInputKeyAtDistanceAlongSpline");

	FGetInputKeyAtDistanceAlongSpline parms{};	
	parms.Distance = Distance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float USplineComponent::GetFloatPropertyAtSplinePoint(int32_t Index, struct FName PropertyName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetFloatPropertyAtSplinePoint");

	FGetFloatPropertyAtSplinePoint parms{};	
	parms.Index = Index;
	parms.PropertyName = PropertyName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float USplineComponent::GetFloatPropertyAtSplineInputKey(float InKey, struct FName PropertyName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetFloatPropertyAtSplineInputKey");

	FGetFloatPropertyAtSplineInputKey parms{};	
	parms.InKey = InKey;
	parms.PropertyName = PropertyName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float USplineComponent::GetDistanceAlongSplineAtSplinePoint(int32_t PointIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetDistanceAlongSplineAtSplinePoint");

	FGetDistanceAlongSplineAtSplinePoint parms{};	
	parms.PointIndex = PointIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float USplineComponent::GetDistanceAlongSplineAtSplineInputKey(float InKey){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetDistanceAlongSplineAtSplineInputKey");

	FGetDistanceAlongSplineAtSplineInputKey parms{};	
	parms.InKey = InKey;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineComponent::GetDirectionAtTime(float Time, enum class ESplineCoordinateSpace CoordinateSpace, bool bUseConstantVelocity){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetDirectionAtTime");

	FGetDirectionAtTime parms{};	
	parms.Time = Time;
	parms.CoordinateSpace = CoordinateSpace;
	parms.bUseConstantVelocity = bUseConstantVelocity;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineComponent::GetDirectionAtSplinePoint(int32_t PointIndex, enum class ESplineCoordinateSpace CoordinateSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetDirectionAtSplinePoint");

	FGetDirectionAtSplinePoint parms{};	
	parms.PointIndex = PointIndex;
	parms.CoordinateSpace = CoordinateSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineComponent::GetDirectionAtSplineInputKey(float InKey, enum class ESplineCoordinateSpace CoordinateSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetDirectionAtSplineInputKey");

	FGetDirectionAtSplineInputKey parms{};	
	parms.InKey = InKey;
	parms.CoordinateSpace = CoordinateSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineComponent::GetDirectionAtDistanceAlongSpline(float Distance, enum class ESplineCoordinateSpace CoordinateSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetDirectionAtDistanceAlongSpline");

	FGetDirectionAtDistanceAlongSpline parms{};	
	parms.Distance = Distance;
	parms.CoordinateSpace = CoordinateSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineComponent::GetDefaultUpVector(enum class ESplineCoordinateSpace CoordinateSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetDefaultUpVector");

	FGetDefaultUpVector parms{};	
	parms.CoordinateSpace = CoordinateSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineComponent::GetArriveTangentAtSplinePoint(int32_t PointIndex, enum class ESplineCoordinateSpace CoordinateSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetArriveTangentAtSplinePoint");

	FGetArriveTangentAtSplinePoint parms{};	
	parms.PointIndex = PointIndex;
	parms.CoordinateSpace = CoordinateSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineComponent::FindUpVectorClosestToWorldLocation(struct FVector& WorldLocation, enum class ESplineCoordinateSpace CoordinateSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.FindUpVectorClosestToWorldLocation");

	FFindUpVectorClosestToWorldLocation parms{};	
	parms.WorldLocation = WorldLocation;
	parms.CoordinateSpace = CoordinateSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTransform USplineComponent::FindTransformClosestToWorldLocation(struct FVector& WorldLocation, enum class ESplineCoordinateSpace CoordinateSpace, bool bUseScale){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.FindTransformClosestToWorldLocation");

	FFindTransformClosestToWorldLocation parms{};	
	parms.WorldLocation = WorldLocation;
	parms.CoordinateSpace = CoordinateSpace;
	parms.bUseScale = bUseScale;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineComponent::FindTangentClosestToWorldLocation(struct FVector& WorldLocation, enum class ESplineCoordinateSpace CoordinateSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.FindTangentClosestToWorldLocation");

	FFindTangentClosestToWorldLocation parms{};	
	parms.WorldLocation = WorldLocation;
	parms.CoordinateSpace = CoordinateSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineComponent::FindScaleClosestToWorldLocation(struct FVector& WorldLocation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.FindScaleClosestToWorldLocation");

	FFindScaleClosestToWorldLocation parms{};	
	parms.WorldLocation = WorldLocation;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator USplineComponent::FindRotationClosestToWorldLocation(struct FVector& WorldLocation, enum class ESplineCoordinateSpace CoordinateSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.FindRotationClosestToWorldLocation");

	FFindRotationClosestToWorldLocation parms{};	
	parms.WorldLocation = WorldLocation;
	parms.CoordinateSpace = CoordinateSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float USplineComponent::FindRollClosestToWorldLocation(struct FVector& WorldLocation, enum class ESplineCoordinateSpace CoordinateSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.FindRollClosestToWorldLocation");

	FFindRollClosestToWorldLocation parms{};	
	parms.WorldLocation = WorldLocation;
	parms.CoordinateSpace = CoordinateSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineComponent::FindRightVectorClosestToWorldLocation(struct FVector& WorldLocation, enum class ESplineCoordinateSpace CoordinateSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.FindRightVectorClosestToWorldLocation");

	FFindRightVectorClosestToWorldLocation parms{};	
	parms.WorldLocation = WorldLocation;
	parms.CoordinateSpace = CoordinateSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineComponent::FindLocationClosestToWorldLocation(struct FVector& WorldLocation, enum class ESplineCoordinateSpace CoordinateSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.FindLocationClosestToWorldLocation");

	FFindLocationClosestToWorldLocation parms{};	
	parms.WorldLocation = WorldLocation;
	parms.CoordinateSpace = CoordinateSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float USplineComponent::FindInputKeyClosestToWorldLocation(struct FVector& WorldLocation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.FindInputKeyClosestToWorldLocation");

	FFindInputKeyClosestToWorldLocation parms{};	
	parms.WorldLocation = WorldLocation;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineComponent::FindDirectionClosestToWorldLocation(struct FVector& WorldLocation, enum class ESplineCoordinateSpace CoordinateSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.FindDirectionClosestToWorldLocation");

	FFindDirectionClosestToWorldLocation parms{};	
	parms.WorldLocation = WorldLocation;
	parms.CoordinateSpace = CoordinateSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool USplineComponent::DivideSplineIntoPolylineRecursiveWithDistances(float StartDistanceAlongSpline, float EndDistanceAlongSpline, enum class ESplineCoordinateSpace CoordinateSpace, float MaxSquareDistanceFromSpline, struct TArray<struct FVector>& OutPoints, struct TArray<double>& OutDistancesAlongSpline){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.DivideSplineIntoPolylineRecursiveWithDistances");

	FDivideSplineIntoPolylineRecursiveWithDistances parms{};	
	parms.StartDistanceAlongSpline = StartDistanceAlongSpline;
	parms.EndDistanceAlongSpline = EndDistanceAlongSpline;
	parms.CoordinateSpace = CoordinateSpace;
	parms.MaxSquareDistanceFromSpline = MaxSquareDistanceFromSpline;
	parms.OutPoints = OutPoints;
	parms.OutDistancesAlongSpline = OutDistancesAlongSpline;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool USplineComponent::DivideSplineIntoPolylineRecursive(float StartDistanceAlongSpline, float EndDistanceAlongSpline, enum class ESplineCoordinateSpace CoordinateSpace, float MaxSquareDistanceFromSpline, struct TArray<struct FVector>& OutPoints){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.DivideSplineIntoPolylineRecursive");

	FDivideSplineIntoPolylineRecursive parms{};	
	parms.StartDistanceAlongSpline = StartDistanceAlongSpline;
	parms.EndDistanceAlongSpline = EndDistanceAlongSpline;
	parms.CoordinateSpace = CoordinateSpace;
	parms.MaxSquareDistanceFromSpline = MaxSquareDistanceFromSpline;
	parms.OutPoints = OutPoints;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool USplineComponent::ConvertSplineToPolyLine(enum class ESplineCoordinateSpace CoordinateSpace, float MaxSquareDistanceFromSpline, struct TArray<struct FVector>& OutPoints){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.ConvertSplineToPolyLine");

	FConvertSplineToPolyLine parms{};	
	parms.CoordinateSpace = CoordinateSpace;
	parms.MaxSquareDistanceFromSpline = MaxSquareDistanceFromSpline;
	parms.OutPoints = OutPoints;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool USplineComponent::ConvertSplineSegmentToPolyLine(int32_t SplinePointStartIndex, enum class ESplineCoordinateSpace CoordinateSpace, float MaxSquareDistanceFromSpline, struct TArray<struct FVector>& OutPoints){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.ConvertSplineSegmentToPolyLine");

	FConvertSplineSegmentToPolyLine parms{};	
	parms.SplinePointStartIndex = SplinePointStartIndex;
	parms.CoordinateSpace = CoordinateSpace;
	parms.MaxSquareDistanceFromSpline = MaxSquareDistanceFromSpline;
	parms.OutPoints = OutPoints;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void USplineComponent::ClearSplinePoints(bool bUpdateSpline){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.ClearSplinePoints");

	FClearSplinePoints parms{};	
	parms.bUpdateSpline = bUpdateSpline;

	ProcessEvent(fn, &parms);
}

void USplineComponent::AddSplineWorldPoint(struct FVector& Position){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.AddSplineWorldPoint");

	FAddSplineWorldPoint parms{};	
	parms.Position = Position;

	ProcessEvent(fn, &parms);
}

void USplineComponent::AddSplinePointAtIndex(struct FVector& Position, int32_t Index, enum class ESplineCoordinateSpace CoordinateSpace, bool bUpdateSpline){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.AddSplinePointAtIndex");

	FAddSplinePointAtIndex parms{};	
	parms.Position = Position;
	parms.Index = Index;
	parms.CoordinateSpace = CoordinateSpace;
	parms.bUpdateSpline = bUpdateSpline;

	ProcessEvent(fn, &parms);
}

void USplineComponent::AddSplinePoint(struct FVector& Position, enum class ESplineCoordinateSpace CoordinateSpace, bool bUpdateSpline){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.AddSplinePoint");

	FAddSplinePoint parms{};	
	parms.Position = Position;
	parms.CoordinateSpace = CoordinateSpace;
	parms.bUpdateSpline = bUpdateSpline;

	ProcessEvent(fn, &parms);
}

void USplineComponent::AddSplineLocalPoint(struct FVector& Position){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.AddSplineLocalPoint");

	FAddSplineLocalPoint parms{};	
	parms.Position = Position;

	ProcessEvent(fn, &parms);
}

void USplineComponent::AddPoints(struct TArray<struct FSplinePoint>& Points, bool bUpdateSpline){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.AddPoints");

	FAddPoints parms{};	
	parms.Points = Points;
	parms.bUpdateSpline = bUpdateSpline;

	ProcessEvent(fn, &parms);
}

void USplineComponent::AddPoint(struct FSplinePoint& Point, bool bUpdateSpline){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineComponent.AddPoint");

	FAddPoint parms{};	
	parms.Point = Point;
	parms.bUpdateSpline = bUpdateSpline;

	ProcessEvent(fn, &parms);
}

void UBoxComponent::SetLineThickness(float Thickness){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BoxComponent.SetLineThickness");

	FSetLineThickness parms{};	
	parms.Thickness = Thickness;

	ProcessEvent(fn, &parms);
}

void UBoxComponent::SetBoxExtent(struct FVector InBoxExtent, bool bUpdateOverlaps){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BoxComponent.SetBoxExtent");

	FSetBoxExtent parms{};	
	parms.InBoxExtent = InBoxExtent;
	parms.bUpdateOverlaps = bUpdateOverlaps;

	ProcessEvent(fn, &parms);
}

struct FVector UBoxComponent::GetUnscaledBoxExtent(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BoxComponent.GetUnscaledBoxExtent");

	FGetUnscaledBoxExtent parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UBoxComponent::GetScaledBoxExtent(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BoxComponent.GetScaledBoxExtent");

	FGetScaledBoxExtent parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void AGameModeBase::StartPlay(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameModeBase.StartPlay");

	FStartPlay parms{};	

	ProcessEvent(fn, &parms);
}

struct APawn* AGameModeBase::SpawnDefaultPawnFor(struct AController* NewPlayer, struct AActor* StartSpot){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameModeBase.SpawnDefaultPawnFor");

	FSpawnDefaultPawnFor parms{};	
	parms.NewPlayer = NewPlayer;
	parms.StartSpot = StartSpot;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct APawn* AGameModeBase::SpawnDefaultPawnAtTransform(struct AController* NewPlayer, struct FTransform& SpawnTransform){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameModeBase.SpawnDefaultPawnAtTransform");

	FSpawnDefaultPawnAtTransform parms{};	
	parms.NewPlayer = NewPlayer;
	parms.SpawnTransform = SpawnTransform;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool AGameModeBase::ShouldReset(struct AActor* ActorToReset){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameModeBase.ShouldReset");

	FShouldReset parms{};	
	parms.ActorToReset = ActorToReset;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void AGameModeBase::ReturnToMainMenuHost(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameModeBase.ReturnToMainMenuHost");

	FReturnToMainMenuHost parms{};	

	ProcessEvent(fn, &parms);
}

void AGameModeBase::RestartPlayerAtTransform(struct AController* NewPlayer, struct FTransform& SpawnTransform){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameModeBase.RestartPlayerAtTransform");

	FRestartPlayerAtTransform parms{};	
	parms.NewPlayer = NewPlayer;
	parms.SpawnTransform = SpawnTransform;

	ProcessEvent(fn, &parms);
}

void AGameModeBase::RestartPlayerAtPlayerStart(struct AController* NewPlayer, struct AActor* StartSpot){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameModeBase.RestartPlayerAtPlayerStart");

	FRestartPlayerAtPlayerStart parms{};	
	parms.NewPlayer = NewPlayer;
	parms.StartSpot = StartSpot;

	ProcessEvent(fn, &parms);
}

void AGameModeBase::RestartPlayer(struct AController* NewPlayer){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameModeBase.RestartPlayer");

	FRestartPlayer parms{};	
	parms.NewPlayer = NewPlayer;

	ProcessEvent(fn, &parms);
}

void AGameModeBase::ResetLevel(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameModeBase.ResetLevel");

	FResetLevel parms{};	

	ProcessEvent(fn, &parms);
}

bool AGameModeBase::PlayerCanRestart(struct APlayerController* Player){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameModeBase.PlayerCanRestart");

	FPlayerCanRestart parms{};	
	parms.Player = Player;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool AGameModeBase::MustSpectate(struct APlayerController* NewPlayerController){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameModeBase.MustSpectate");

	FMustSpectate parms{};	
	parms.NewPlayerController = NewPlayerController;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void AGameModeBase::K2_PostLogin(struct APlayerController* NewPlayer){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameModeBase.K2_PostLogin");

	FK2_PostLogin parms{};	
	parms.NewPlayer = NewPlayer;

	ProcessEvent(fn, &parms);
}

void AGameModeBase::K2_OnSwapPlayerControllers(struct APlayerController* OldPC, struct APlayerController* NewPC){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameModeBase.K2_OnSwapPlayerControllers");

	FK2_OnSwapPlayerControllers parms{};	
	parms.OldPC = OldPC;
	parms.NewPC = NewPC;

	ProcessEvent(fn, &parms);
}

void AGameModeBase::K2_OnRestartPlayer(struct AController* NewPlayer){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameModeBase.K2_OnRestartPlayer");

	FK2_OnRestartPlayer parms{};	
	parms.NewPlayer = NewPlayer;

	ProcessEvent(fn, &parms);
}

void AGameModeBase::K2_OnLogout(struct AController* ExitingController){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameModeBase.K2_OnLogout");

	FK2_OnLogout parms{};	
	parms.ExitingController = ExitingController;

	ProcessEvent(fn, &parms);
}

void AGameModeBase::K2_OnChangeName(struct AController* Other, struct FString NewName, bool bNameChange){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameModeBase.K2_OnChangeName");

	FK2_OnChangeName parms{};	
	parms.Other = Other;
	parms.NewName = NewName;
	parms.bNameChange = bNameChange;

	ProcessEvent(fn, &parms);
}

struct AActor* AGameModeBase::K2_FindPlayerStart(struct AController* Player, struct FString IncomingName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameModeBase.K2_FindPlayerStart");

	FK2_FindPlayerStart parms{};	
	parms.Player = Player;
	parms.IncomingName = IncomingName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void AGameModeBase::InitStartSpot(struct AActor* StartSpot, struct AController* NewPlayer){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameModeBase.InitStartSpot");

	FInitStartSpot parms{};	
	parms.StartSpot = StartSpot;
	parms.NewPlayer = NewPlayer;

	ProcessEvent(fn, &parms);
}

void AGameModeBase::InitializeHUDForPlayer(struct APlayerController* NewPlayer){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameModeBase.InitializeHUDForPlayer");

	FInitializeHUDForPlayer parms{};	
	parms.NewPlayer = NewPlayer;

	ProcessEvent(fn, &parms);
}

bool AGameModeBase::HasMatchStarted(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameModeBase.HasMatchStarted");

	FHasMatchStarted parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool AGameModeBase::HasMatchEnded(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameModeBase.HasMatchEnded");

	FHasMatchEnded parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void AGameModeBase::HandleStartingNewPlayer(struct APlayerController* NewPlayer){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameModeBase.HandleStartingNewPlayer");

	FHandleStartingNewPlayer parms{};	
	parms.NewPlayer = NewPlayer;

	ProcessEvent(fn, &parms);
}

int32_t AGameModeBase::GetNumSpectators(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameModeBase.GetNumSpectators");

	FGetNumSpectators parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t AGameModeBase::GetNumPlayers(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameModeBase.GetNumPlayers");

	FGetNumPlayers parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

UObject* AGameModeBase::GetDefaultPawnClassForController(struct AController* InController){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameModeBase.GetDefaultPawnClassForController");

	FGetDefaultPawnClassForController parms{};	
	parms.InController = InController;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct AActor* AGameModeBase::FindPlayerStart(struct AController* Player, struct FString IncomingName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameModeBase.FindPlayerStart");

	FFindPlayerStart parms{};	
	parms.Player = Player;
	parms.IncomingName = IncomingName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct AActor* AGameModeBase::ChoosePlayerStart(struct AController* Player){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameModeBase.ChoosePlayerStart");

	FChoosePlayerStart parms{};	
	parms.Player = Player;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void AGameModeBase::ChangeName(struct AController* Controller, struct FString NewName, bool bNameChange){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameModeBase.ChangeName");

	FChangeName parms{};	
	parms.Controller = Controller;
	parms.NewName = NewName;
	parms.bNameChange = bNameChange;

	ProcessEvent(fn, &parms);
}

bool AGameModeBase::CanSpectate(struct APlayerController* Viewer, struct APlayerState* ViewTarget){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameModeBase.CanSpectate");

	FCanSpectate parms{};	
	parms.Viewer = Viewer;
	parms.ViewTarget = ViewTarget;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FLinearColor UMaterialInstanceConstant::K2_GetVectorParameterValue(struct FName ParameterName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MaterialInstanceConstant.K2_GetVectorParameterValue");

	FK2_GetVectorParameterValue parms{};	
	parms.ParameterName = ParameterName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UTexture* UMaterialInstanceConstant::K2_GetTextureParameterValue(struct FName ParameterName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MaterialInstanceConstant.K2_GetTextureParameterValue");

	FK2_GetTextureParameterValue parms{};	
	parms.ParameterName = ParameterName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UMaterialInstanceConstant::K2_GetScalarParameterValue(struct FName ParameterName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MaterialInstanceConstant.K2_GetScalarParameterValue");

	FK2_GetScalarParameterValue parms{};	
	parms.ParameterName = ParameterName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct AWorldSettings* UWorld::K2_GetWorldSettings(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.World.K2_GetWorldSettings");

	FK2_GetWorldSettings parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UWorld::HandleTimelineScrubbed(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.World.HandleTimelineScrubbed");

	FHandleTimelineScrubbed parms{};	

	ProcessEvent(fn, &parms);
}

struct UAsyncActionLoadPrimaryAssetList* UAsyncActionLoadPrimaryAssetList::AsyncLoadPrimaryAssetList(struct UObject* WorldContextObject, struct TArray<struct FPrimaryAssetId>& PrimaryAssetList, struct TArray<struct FName>& LoadBundles){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AsyncActionLoadPrimaryAssetList.AsyncLoadPrimaryAssetList");

	FAsyncLoadPrimaryAssetList parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.PrimaryAssetList = PrimaryAssetList;
	parms.LoadBundles = LoadBundles;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int64_t UTexture::Blueprint_GetMemorySize(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Texture.Blueprint_GetMemorySize");

	FBlueprint_GetMemorySize parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UInputSettings::SaveKeyMappings(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InputSettings.SaveKeyMappings");

	FSaveKeyMappings parms{};	

	ProcessEvent(fn, &parms);
}

void UInputSettings::RemoveAxisMapping(struct FInputAxisKeyMapping& KeyMapping, bool bForceRebuildKeymaps){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InputSettings.RemoveAxisMapping");

	FRemoveAxisMapping parms{};	
	parms.KeyMapping = KeyMapping;
	parms.bForceRebuildKeymaps = bForceRebuildKeymaps;

	ProcessEvent(fn, &parms);
}

void UInputSettings::RemoveActionMapping(struct FInputActionKeyMapping& KeyMapping, bool bForceRebuildKeymaps){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InputSettings.RemoveActionMapping");

	FRemoveActionMapping parms{};	
	parms.KeyMapping = KeyMapping;
	parms.bForceRebuildKeymaps = bForceRebuildKeymaps;

	ProcessEvent(fn, &parms);
}

struct UInputSettings* UInputSettings::GetInputSettings(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InputSettings.GetInputSettings");

	FGetInputSettings parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UInputSettings::GetAxisNames(struct TArray<struct FName>& AxisNames){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InputSettings.GetAxisNames");

	FGetAxisNames parms{};	
	parms.AxisNames = AxisNames;

	ProcessEvent(fn, &parms);
}

void UInputSettings::GetAxisMappingByName(struct FName InAxisName, struct TArray<struct FInputAxisKeyMapping>& OutMappings){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InputSettings.GetAxisMappingByName");

	FGetAxisMappingByName parms{};	
	parms.InAxisName = InAxisName;
	parms.OutMappings = OutMappings;

	ProcessEvent(fn, &parms);
}

void UInputSettings::GetActionNames(struct TArray<struct FName>& ActionNames){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InputSettings.GetActionNames");

	FGetActionNames parms{};	
	parms.ActionNames = ActionNames;

	ProcessEvent(fn, &parms);
}

void UInputSettings::GetActionMappingByName(struct FName InActionName, struct TArray<struct FInputActionKeyMapping>& OutMappings){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InputSettings.GetActionMappingByName");

	FGetActionMappingByName parms{};	
	parms.InActionName = InActionName;
	parms.OutMappings = OutMappings;

	ProcessEvent(fn, &parms);
}

void UInputSettings::ForceRebuildKeymaps(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InputSettings.ForceRebuildKeymaps");

	FForceRebuildKeymaps parms{};	

	ProcessEvent(fn, &parms);
}

void UInputSettings::AddAxisMapping(struct FInputAxisKeyMapping& KeyMapping, bool bForceRebuildKeymaps){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InputSettings.AddAxisMapping");

	FAddAxisMapping parms{};	
	parms.KeyMapping = KeyMapping;
	parms.bForceRebuildKeymaps = bForceRebuildKeymaps;

	ProcessEvent(fn, &parms);
}

void UInputSettings::AddActionMapping(struct FInputActionKeyMapping& KeyMapping, bool bForceRebuildKeymaps){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InputSettings.AddActionMapping");

	FAddActionMapping parms{};	
	parms.KeyMapping = KeyMapping;
	parms.bForceRebuildKeymaps = bForceRebuildKeymaps;

	ProcessEvent(fn, &parms);
}

void UProjectileMovementComponent::StopSimulating(struct FHitResult& HitResult){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ProjectileMovementComponent.StopSimulating");

	FStopSimulating parms{};	
	parms.HitResult = HitResult;

	ProcessEvent(fn, &parms);
}

void UProjectileMovementComponent::SetVelocityInLocalSpace(struct FVector NewVelocity){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ProjectileMovementComponent.SetVelocityInLocalSpace");

	FSetVelocityInLocalSpace parms{};	
	parms.NewVelocity = NewVelocity;

	ProcessEvent(fn, &parms);
}

void UProjectileMovementComponent::SetInterpolatedComponent(struct USceneComponent* Component){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ProjectileMovementComponent.SetInterpolatedComponent");

	FSetInterpolatedComponent parms{};	
	parms.Component = Component;

	ProcessEvent(fn, &parms);
}

void UProjectileMovementComponent::ResetInterpolation(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ProjectileMovementComponent.ResetInterpolation");

	FResetInterpolation parms{};	

	ProcessEvent(fn, &parms);
}

void UProjectileMovementComponent::OnProjectileStopDelegate__DelegateSignature(struct FHitResult& ImpactResult){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("DelegateFunction Engine.ProjectileMovementComponent.OnProjectileStopDelegate__DelegateSignature");

	FOnProjectileStopDelegate__DelegateSignature parms{};	
	parms.ImpactResult = ImpactResult;

	ProcessEvent(fn, &parms);
}

void UProjectileMovementComponent::OnProjectileBounceDelegate__DelegateSignature(struct FHitResult& ImpactResult, struct FVector& ImpactVelocity){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("DelegateFunction Engine.ProjectileMovementComponent.OnProjectileBounceDelegate__DelegateSignature");

	FOnProjectileBounceDelegate__DelegateSignature parms{};	
	parms.ImpactResult = ImpactResult;
	parms.ImpactVelocity = ImpactVelocity;

	ProcessEvent(fn, &parms);
}

void UProjectileMovementComponent::MoveInterpolationTarget(struct FVector& NewLocation, struct FRotator& NewRotation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ProjectileMovementComponent.MoveInterpolationTarget");

	FMoveInterpolationTarget parms{};	
	parms.NewLocation = NewLocation;
	parms.NewRotation = NewRotation;

	ProcessEvent(fn, &parms);
}

struct FVector UProjectileMovementComponent::LimitVelocity(struct FVector NewVelocity){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ProjectileMovementComponent.LimitVelocity");

	FLimitVelocity parms{};	
	parms.NewVelocity = NewVelocity;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UProjectileMovementComponent::IsVelocityUnderSimulationThreshold(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ProjectileMovementComponent.IsVelocityUnderSimulationThreshold");

	FIsVelocityUnderSimulationThreshold parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UProjectileMovementComponent::IsInterpolationComplete(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ProjectileMovementComponent.IsInterpolationComplete");

	FIsInterpolationComplete parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void USkinnedMeshComponent::UnloadSkinWeightProfile(struct FName InProfileName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.UnloadSkinWeightProfile");

	FUnloadSkinWeightProfile parms{};	
	parms.InProfileName = InProfileName;

	ProcessEvent(fn, &parms);
}

void USkinnedMeshComponent::UnHideBoneByName(struct FName BoneName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.UnHideBoneByName");

	FUnHideBoneByName parms{};	
	parms.BoneName = BoneName;

	ProcessEvent(fn, &parms);
}

void USkinnedMeshComponent::TransformToBoneSpace(struct FName BoneName, struct FVector InPosition, struct FRotator InRotation, struct FVector& OutPosition, struct FRotator& OutRotation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.TransformToBoneSpace");

	FTransformToBoneSpace parms{};	
	parms.BoneName = BoneName;
	parms.InPosition = InPosition;
	parms.InRotation = InRotation;
	parms.OutPosition = OutPosition;
	parms.OutRotation = OutRotation;

	ProcessEvent(fn, &parms);
}

void USkinnedMeshComponent::TransformFromBoneSpace(struct FName BoneName, struct FVector InPosition, struct FRotator InRotation, struct FVector& OutPosition, struct FRotator& OutRotation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.TransformFromBoneSpace");

	FTransformFromBoneSpace parms{};	
	parms.BoneName = BoneName;
	parms.InPosition = InPosition;
	parms.InRotation = InRotation;
	parms.OutPosition = OutPosition;
	parms.OutRotation = OutRotation;

	ProcessEvent(fn, &parms);
}

void USkinnedMeshComponent::ShowMaterialSection(int32_t MaterialID, int32_t SectionIndex, bool bShow, int32_t LODIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.ShowMaterialSection");

	FShowMaterialSection parms{};	
	parms.MaterialID = MaterialID;
	parms.SectionIndex = SectionIndex;
	parms.bShow = bShow;
	parms.LODIndex = LODIndex;

	ProcessEvent(fn, &parms);
}

void USkinnedMeshComponent::ShowAllMaterialSections(int32_t LODIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.ShowAllMaterialSections");

	FShowAllMaterialSections parms{};	
	parms.LODIndex = LODIndex;

	ProcessEvent(fn, &parms);
}

void USkinnedMeshComponent::SetVertexOffsetUsage(int32_t LODIndex, int32_t Usage){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetVertexOffsetUsage");

	FSetVertexOffsetUsage parms{};	
	parms.LODIndex = LODIndex;
	parms.Usage = Usage;

	ProcessEvent(fn, &parms);
}

void USkinnedMeshComponent::SetVertexColorOverride_LinearColor(int32_t LODIndex, struct TArray<struct FLinearColor>& VertexColors){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetVertexColorOverride_LinearColor");

	FSetVertexColorOverride_LinearColor parms{};	
	parms.LODIndex = LODIndex;
	parms.VertexColors = VertexColors;

	ProcessEvent(fn, &parms);
}

bool USkinnedMeshComponent::SetSkinWeightProfile(struct FName InProfileName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetSkinWeightProfile");

	FSetSkinWeightProfile parms{};	
	parms.InProfileName = InProfileName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void USkinnedMeshComponent::SetSkinWeightOverride(int32_t LODIndex, struct TArray<struct FSkelMeshSkinWeightInfo>& SkinWeights){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetSkinWeightOverride");

	FSetSkinWeightOverride parms{};	
	parms.LODIndex = LODIndex;
	parms.SkinWeights = SkinWeights;

	ProcessEvent(fn, &parms);
}

void USkinnedMeshComponent::SetSkinnedAssetAndUpdate(struct USkinnedAsset* NewMesh, bool bReinitPose){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetSkinnedAssetAndUpdate");

	FSetSkinnedAssetAndUpdate parms{};	
	parms.NewMesh = NewMesh;
	parms.bReinitPose = bReinitPose;

	ProcessEvent(fn, &parms);
}

void USkinnedMeshComponent::SetRenderStatic(bool bNewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetRenderStatic");

	FSetRenderStatic parms{};	
	parms.bNewValue = bNewValue;

	ProcessEvent(fn, &parms);
}

void USkinnedMeshComponent::SetPreSkinningOffsets(int32_t LODIndex, struct TArray<struct FVector> Offsets){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetPreSkinningOffsets");

	FSetPreSkinningOffsets parms{};	
	parms.LODIndex = LODIndex;
	parms.Offsets = Offsets;

	ProcessEvent(fn, &parms);
}

void USkinnedMeshComponent::SetPostSkinningOffsets(int32_t LODIndex, struct TArray<struct FVector> Offsets){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetPostSkinningOffsets");

	FSetPostSkinningOffsets parms{};	
	parms.LODIndex = LODIndex;
	parms.Offsets = Offsets;

	ProcessEvent(fn, &parms);
}

void USkinnedMeshComponent::SetPhysicsAsset(struct UPhysicsAsset* NewPhysicsAsset, bool bForceReInit){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetPhysicsAsset");

	FSetPhysicsAsset parms{};	
	parms.NewPhysicsAsset = NewPhysicsAsset;
	parms.bForceReInit = bForceReInit;

	ProcessEvent(fn, &parms);
}

void USkinnedMeshComponent::SetMinLOD(int32_t InNewMinLOD){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetMinLOD");

	FSetMinLOD parms{};	
	parms.InNewMinLOD = InNewMinLOD;

	ProcessEvent(fn, &parms);
}

void USkinnedMeshComponent::SetMeshDeformer(struct UMeshDeformer* InMeshDeformer){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetMeshDeformer");

	FSetMeshDeformer parms{};	
	parms.InMeshDeformer = InMeshDeformer;

	ProcessEvent(fn, &parms);
}

void USkinnedMeshComponent::SetLeaderPoseComponent(struct USkinnedMeshComponent* NewLeaderBoneComponent, bool bForceUpdate, bool bInFollowerShouldTickPose){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetLeaderPoseComponent");

	FSetLeaderPoseComponent parms{};	
	parms.NewLeaderBoneComponent = NewLeaderBoneComponent;
	parms.bForceUpdate = bForceUpdate;
	parms.bInFollowerShouldTickPose = bInFollowerShouldTickPose;

	ProcessEvent(fn, &parms);
}

void USkinnedMeshComponent::SetForcedLOD(int32_t InNewForcedLOD){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetForcedLOD");

	FSetForcedLOD parms{};	
	parms.InNewForcedLOD = InNewForcedLOD;

	ProcessEvent(fn, &parms);
}

void USkinnedMeshComponent::SetCastCapsuleIndirectShadow(bool bNewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetCastCapsuleIndirectShadow");

	FSetCastCapsuleIndirectShadow parms{};	
	parms.bNewValue = bNewValue;

	ProcessEvent(fn, &parms);
}

void USkinnedMeshComponent::SetCastCapsuleDirectShadow(bool bNewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetCastCapsuleDirectShadow");

	FSetCastCapsuleDirectShadow parms{};	
	parms.bNewValue = bNewValue;

	ProcessEvent(fn, &parms);
}

void USkinnedMeshComponent::SetCapsuleIndirectShadowMinVisibility(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetCapsuleIndirectShadowMinVisibility");

	FSetCapsuleIndirectShadowMinVisibility parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

bool USkinnedMeshComponent::IsUsingSkinWeightProfile(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.IsUsingSkinWeightProfile");

	FIsUsingSkinWeightProfile parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool USkinnedMeshComponent::IsMaterialSectionShown(int32_t MaterialID, int32_t LODIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.IsMaterialSectionShown");

	FIsMaterialSectionShown parms{};	
	parms.MaterialID = MaterialID;
	parms.LODIndex = LODIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool USkinnedMeshComponent::IsBoneHiddenByName(struct FName BoneName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.IsBoneHiddenByName");

	FIsBoneHiddenByName parms{};	
	parms.BoneName = BoneName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void USkinnedMeshComponent::HideBoneByName(struct FName BoneName, enum class EPhysBodyOp PhysBodyOption){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.HideBoneByName");

	FHideBoneByName parms{};	
	parms.BoneName = BoneName;
	parms.PhysBodyOption = PhysBodyOption;

	ProcessEvent(fn, &parms);
}

int32_t USkinnedMeshComponent::GetVertexOffsetUsage(int32_t LODIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetVertexOffsetUsage");

	FGetVertexOffsetUsage parms{};	
	parms.LODIndex = LODIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool USkinnedMeshComponent::GetTwistAndSwingAngleOfDeltaRotationFromRefPose(struct FName BoneName, float& OutTwistAngle, float& OutSwingAngle){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetTwistAndSwingAngleOfDeltaRotationFromRefPose");

	FGetTwistAndSwingAngleOfDeltaRotationFromRefPose parms{};	
	parms.BoneName = BoneName;
	parms.OutTwistAngle = OutTwistAngle;
	parms.OutSwingAngle = OutSwingAngle;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FName USkinnedMeshComponent::GetSocketBoneName(struct FName InSocketName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetSocketBoneName");

	FGetSocketBoneName parms{};	
	parms.InSocketName = InSocketName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct USkinnedAsset* USkinnedMeshComponent::GetSkinnedAsset(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetSkinnedAsset");

	FGetSkinnedAsset parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct USkeletalMesh* USkinnedMeshComponent::GetSkeletalMesh_DEPRECATED(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetSkeletalMesh_DEPRECATED");

	FGetSkeletalMesh_DEPRECATED parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTransform USkinnedMeshComponent::GetRefPoseTransform(int32_t BoneIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetRefPoseTransform");

	FGetRefPoseTransform parms{};	
	parms.BoneIndex = BoneIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USkinnedMeshComponent::GetRefPosePosition(int32_t BoneIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetRefPosePosition");

	FGetRefPosePosition parms{};	
	parms.BoneIndex = BoneIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t USkinnedMeshComponent::GetPredictedLODLevel(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetPredictedLODLevel");

	FGetPredictedLODLevel parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FName USkinnedMeshComponent::GetParentBone(struct FName BoneName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetParentBone");

	FGetParentBone parms{};	
	parms.BoneName = BoneName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t USkinnedMeshComponent::GetNumLODs(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetNumLODs");

	FGetNumLODs parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t USkinnedMeshComponent::GetNumBones(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetNumBones");

	FGetNumBones parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t USkinnedMeshComponent::GetForcedLOD(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetForcedLOD");

	FGetForcedLOD parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTransform USkinnedMeshComponent::GetDeltaTransformFromRefPose(struct FName BoneName, struct FName BaseName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetDeltaTransformFromRefPose");

	FGetDeltaTransformFromRefPose parms{};	
	parms.BoneName = BoneName;
	parms.BaseName = BaseName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FName USkinnedMeshComponent::GetCurrentSkinWeightProfileName(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetCurrentSkinWeightProfileName");

	FGetCurrentSkinWeightProfileName parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FName USkinnedMeshComponent::GetBoneName(int32_t BoneIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetBoneName");

	FGetBoneName parms{};	
	parms.BoneIndex = BoneIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t USkinnedMeshComponent::GetBoneIndex(struct FName BoneName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetBoneIndex");

	FGetBoneIndex parms{};	
	parms.BoneName = BoneName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FName USkinnedMeshComponent::FindClosestBone_K2(struct FVector TestLocation, struct FVector& BoneLocation, float IgnoreScale, bool bRequirePhysicsAsset){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.FindClosestBone_K2");

	FFindClosestBone_K2 parms{};	
	parms.TestLocation = TestLocation;
	parms.BoneLocation = BoneLocation;
	parms.IgnoreScale = IgnoreScale;
	parms.bRequirePhysicsAsset = bRequirePhysicsAsset;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void USkinnedMeshComponent::ClearVertexColorOverride(int32_t LODIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.ClearVertexColorOverride");

	FClearVertexColorOverride parms{};	
	parms.LODIndex = LODIndex;

	ProcessEvent(fn, &parms);
}

void USkinnedMeshComponent::ClearSkinWeightProfile(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.ClearSkinWeightProfile");

	FClearSkinWeightProfile parms{};	

	ProcessEvent(fn, &parms);
}

void USkinnedMeshComponent::ClearSkinWeightOverride(int32_t LODIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.ClearSkinWeightOverride");

	FClearSkinWeightOverride parms{};	
	parms.LODIndex = LODIndex;

	ProcessEvent(fn, &parms);
}

bool USkinnedMeshComponent::BoneIsChildOf(struct FName BoneName, struct FName ParentBoneName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.BoneIsChildOf");

	FBoneIsChildOf parms{};	
	parms.BoneName = BoneName;
	parms.ParentBoneName = ParentBoneName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAvoidanceManager::RegisterMovementComponent(struct UMovementComponent* MovementComp, float AvoidanceWeight){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AvoidanceManager.RegisterMovementComponent");

	FRegisterMovementComponent parms{};	
	parms.MovementComp = MovementComp;
	parms.AvoidanceWeight = AvoidanceWeight;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UAvoidanceManager::GetObjectCount(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AvoidanceManager.GetObjectCount");

	FGetObjectCount parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UAvoidanceManager::GetNewAvoidanceUID(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AvoidanceManager.GetNewAvoidanceUID");

	FGetNewAvoidanceUID parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UAvoidanceManager::GetAvoidanceVelocityForComponent(struct UMovementComponent* MovementComp){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AvoidanceManager.GetAvoidanceVelocityForComponent");

	FGetAvoidanceVelocityForComponent parms{};	
	parms.MovementComp = MovementComp;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void URuntimeVirtualTextureComponent::Invalidate(struct FBoxSphereBounds& WorldBounds){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.RuntimeVirtualTextureComponent.Invalidate");

	FInvalidate parms{};	
	parms.WorldBounds = WorldBounds;

	ProcessEvent(fn, &parms);
}

bool UInputComponent::WasControllerKeyJustReleased(struct FKey Key){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InputComponent.WasControllerKeyJustReleased");

	FWasControllerKeyJustReleased parms{};	
	parms.Key = Key;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UInputComponent::WasControllerKeyJustPressed(struct FKey Key){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InputComponent.WasControllerKeyJustPressed");

	FWasControllerKeyJustPressed parms{};	
	parms.Key = Key;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UInputComponent::OnInputOwnerEndPlayed(struct AActor* InOwner, enum class EEndPlayReason EndPlayReason){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InputComponent.OnInputOwnerEndPlayed");

	FOnInputOwnerEndPlayed parms{};	
	parms.InOwner = InOwner;
	parms.EndPlayReason = EndPlayReason;

	ProcessEvent(fn, &parms);
}

bool UInputComponent::IsControllerKeyDown(struct FKey Key){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InputComponent.IsControllerKeyDown");

	FIsControllerKeyDown parms{};	
	parms.Key = Key;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UInputComponent::GetTouchState(int32_t FingerIndex, float& LocationX, float& LocationY, bool& bIsCurrentlyPressed){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InputComponent.GetTouchState");

	FGetTouchState parms{};	
	parms.FingerIndex = FingerIndex;
	parms.LocationX = LocationX;
	parms.LocationY = LocationY;
	parms.bIsCurrentlyPressed = bIsCurrentlyPressed;

	ProcessEvent(fn, &parms);
}

struct FVector UInputComponent::GetControllerVectorKeyState(struct FKey Key){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InputComponent.GetControllerVectorKeyState");

	FGetControllerVectorKeyState parms{};	
	parms.Key = Key;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UInputComponent::GetControllerMouseDelta(float& DeltaX, float& DeltaY){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InputComponent.GetControllerMouseDelta");

	FGetControllerMouseDelta parms{};	
	parms.DeltaX = DeltaX;
	parms.DeltaY = DeltaY;

	ProcessEvent(fn, &parms);
}

float UInputComponent::GetControllerKeyTimeDown(struct FKey Key){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InputComponent.GetControllerKeyTimeDown");

	FGetControllerKeyTimeDown parms{};	
	parms.Key = Key;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UInputComponent::GetControllerAnalogStickState(enum class EControllerAnalogStick WhichStick, float& StickX, float& StickY){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InputComponent.GetControllerAnalogStickState");

	FGetControllerAnalogStickState parms{};	
	parms.WhichStick = WhichStick;
	parms.StickX = StickX;
	parms.StickY = StickY;

	ProcessEvent(fn, &parms);
}

float UInputComponent::GetControllerAnalogKeyState(struct FKey Key){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InputComponent.GetControllerAnalogKeyState");

	FGetControllerAnalogKeyState parms{};	
	parms.Key = Key;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UMaterialInterface::SetForceMipLevelsToBeResident(bool OverrideForceMiplevelsToBeResident, bool bForceMiplevelsToBeResidentValue, float ForceDuration, int32_t CinematicTextureGroups, bool bFastResponse){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MaterialInterface.SetForceMipLevelsToBeResident");

	FSetForceMipLevelsToBeResident parms{};	
	parms.OverrideForceMiplevelsToBeResident = OverrideForceMiplevelsToBeResident;
	parms.bForceMiplevelsToBeResidentValue = bForceMiplevelsToBeResidentValue;
	parms.ForceDuration = ForceDuration;
	parms.CinematicTextureGroups = CinematicTextureGroups;
	parms.bFastResponse = bFastResponse;

	ProcessEvent(fn, &parms);
}

struct UPhysicalMaterialMask* UMaterialInterface::GetPhysicalMaterialMask(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MaterialInterface.GetPhysicalMaterialMask");

	FGetPhysicalMaterialMask parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UPhysicalMaterial* UMaterialInterface::GetPhysicalMaterialFromMap(int32_t Index){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MaterialInterface.GetPhysicalMaterialFromMap");

	FGetPhysicalMaterialFromMap parms{};	
	parms.Index = Index;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UPhysicalMaterial* UMaterialInterface::GetPhysicalMaterial(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MaterialInterface.GetPhysicalMaterial");

	FGetPhysicalMaterial parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FMaterialParameterInfo UMaterialInterface::GetParameterInfo(enum class EMaterialParameterAssociation Association, struct FName ParameterName, struct UMaterialFunctionInterface* LayerFunction){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MaterialInterface.GetParameterInfo");

	FGetParameterInfo parms{};	
	parms.Association = Association;
	parms.ParameterName = ParameterName;
	parms.LayerFunction = LayerFunction;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

enum class EBlendMode UMaterialInterface::GetBlendMode(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MaterialInterface.GetBlendMode");

	FGetBlendMode parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UMaterial* UMaterialInterface::GetBaseMaterial(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MaterialInterface.GetBaseMaterial");

	FGetBaseMaterial parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTimecode UTimecodeProvider::GetTimecode(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TimecodeProvider.GetTimecode");

	FGetTimecode parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

uint8_t UTimecodeProvider::GetSynchronizationState(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TimecodeProvider.GetSynchronizationState");

	FGetSynchronizationState parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FQualifiedFrameTime UTimecodeProvider::GetQualifiedFrameTime(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TimecodeProvider.GetQualifiedFrameTime");

	FGetQualifiedFrameTime parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FFrameRate UTimecodeProvider::GetFrameRate(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TimecodeProvider.GetFrameRate");

	FGetFrameRate parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTimecode UTimecodeProvider::GetDelayedTimecode(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TimecodeProvider.GetDelayedTimecode");

	FGetDelayedTimecode parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FQualifiedFrameTime UTimecodeProvider::GetDelayedQualifiedFrameTime(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TimecodeProvider.GetDelayedQualifiedFrameTime");

	FGetDelayedQualifiedFrameTime parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UTimecodeProvider::FetchTimecode(struct FQualifiedFrameTime& OutFrameTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TimecodeProvider.FetchTimecode");

	FFetchTimecode parms{};	
	parms.OutFrameTime = OutFrameTime;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UTimecodeProvider::FetchAndUpdate(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TimecodeProvider.FetchAndUpdate");

	FFetchAndUpdate parms{};	

	ProcessEvent(fn, &parms);
}

void AWorldSettings::OnRep_WorldGravityZ(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.WorldSettings.OnRep_WorldGravityZ");

	FOnRep_WorldGravityZ parms{};	

	ProcessEvent(fn, &parms);
}

void UGameViewportClient::SSSwapControllers(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameViewportClient.SSSwapControllers");

	FSSSwapControllers parms{};	

	ProcessEvent(fn, &parms);
}

void UGameViewportClient::ShowTitleSafeArea(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameViewportClient.ShowTitleSafeArea");

	FShowTitleSafeArea parms{};	

	ProcessEvent(fn, &parms);
}

void UGameViewportClient::SetConsoleTarget(int32_t PlayerIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameViewportClient.SetConsoleTarget");

	FSetConsoleTarget parms{};	
	parms.PlayerIndex = PlayerIndex;

	ProcessEvent(fn, &parms);
}

void UGameInstance::ReceiveShutdown(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameInstance.ReceiveShutdown");

	FReceiveShutdown parms{};	

	ProcessEvent(fn, &parms);
}

void UGameInstance::ReceiveInit(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameInstance.ReceiveInit");

	FReceiveInit parms{};	

	ProcessEvent(fn, &parms);
}

void UGameInstance::HandleTravelError(enum class ETravelFailure FailureType){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameInstance.HandleTravelError");

	FHandleTravelError parms{};	
	parms.FailureType = FailureType;

	ProcessEvent(fn, &parms);
}

void UGameInstance::HandleNetworkError(enum class ENetworkFailure FailureType, bool bIsServer){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameInstance.HandleNetworkError");

	FHandleNetworkError parms{};	
	parms.FailureType = FailureType;
	parms.bIsServer = bIsServer;

	ProcessEvent(fn, &parms);
}

void UGameInstance::DebugRemovePlayer(int32_t ControllerId){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameInstance.DebugRemovePlayer");

	FDebugRemovePlayer parms{};	
	parms.ControllerId = ControllerId;

	ProcessEvent(fn, &parms);
}

void UGameInstance::DebugCreatePlayer(int32_t ControllerId){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameInstance.DebugCreatePlayer");

	FDebugCreatePlayer parms{};	
	parms.ControllerId = ControllerId;

	ProcessEvent(fn, &parms);
}

void ALODActor::OnSubActorEndPlay(struct AActor* Actor, enum class EEndPlayReason Reason){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LODActor.OnSubActorEndPlay");

	FOnSubActorEndPlay parms{};	
	parms.Actor = Actor;
	parms.Reason = Reason;

	ProcessEvent(fn, &parms);
}

void UBlueprintPlatformLibrary::SetAllowedDeviceOrientation(enum class EScreenOrientation NewAllowedDeviceOrientation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPlatformLibrary.SetAllowedDeviceOrientation");

	FSetAllowedDeviceOrientation parms{};	
	parms.NewAllowedDeviceOrientation = NewAllowedDeviceOrientation;

	ProcessEvent(fn, &parms);
}

int32_t UBlueprintPlatformLibrary::ScheduleLocalNotificationFromNow(int32_t inSecondsFromNow, struct FText& Title, struct FText& Body, struct FText& Action, struct FString ActivationEvent){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPlatformLibrary.ScheduleLocalNotificationFromNow");

	FScheduleLocalNotificationFromNow parms{};	
	parms.inSecondsFromNow = inSecondsFromNow;
	parms.Title = Title;
	parms.Body = Body;
	parms.Action = Action;
	parms.ActivationEvent = ActivationEvent;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UBlueprintPlatformLibrary::ScheduleLocalNotificationBadgeFromNow(int32_t inSecondsFromNow, struct FString ActivationEvent){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPlatformLibrary.ScheduleLocalNotificationBadgeFromNow");

	FScheduleLocalNotificationBadgeFromNow parms{};	
	parms.inSecondsFromNow = inSecondsFromNow;
	parms.ActivationEvent = ActivationEvent;

	ProcessEvent(fn, &parms);
}

int32_t UBlueprintPlatformLibrary::ScheduleLocalNotificationBadgeAtTime(struct FDateTime& FireDateTime, bool LocalTime, struct FString ActivationEvent){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPlatformLibrary.ScheduleLocalNotificationBadgeAtTime");

	FScheduleLocalNotificationBadgeAtTime parms{};	
	parms.FireDateTime = FireDateTime;
	parms.LocalTime = LocalTime;
	parms.ActivationEvent = ActivationEvent;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UBlueprintPlatformLibrary::ScheduleLocalNotificationAtTime(struct FDateTime& FireDateTime, bool LocalTime, struct FText& Title, struct FText& Body, struct FText& Action, struct FString ActivationEvent){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPlatformLibrary.ScheduleLocalNotificationAtTime");

	FScheduleLocalNotificationAtTime parms{};	
	parms.FireDateTime = FireDateTime;
	parms.LocalTime = LocalTime;
	parms.Title = Title;
	parms.Body = Body;
	parms.Action = Action;
	parms.ActivationEvent = ActivationEvent;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UBlueprintPlatformLibrary::GetLaunchNotification(bool& NotificationLaunchedApp, struct FString& ActivationEvent, int32_t& FireDate){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPlatformLibrary.GetLaunchNotification");

	FGetLaunchNotification parms{};	
	parms.NotificationLaunchedApp = NotificationLaunchedApp;
	parms.ActivationEvent = ActivationEvent;
	parms.FireDate = FireDate;

	ProcessEvent(fn, &parms);
}

enum class EScreenOrientation UBlueprintPlatformLibrary::GetDeviceOrientation(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPlatformLibrary.GetDeviceOrientation");

	FGetDeviceOrientation parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

enum class EScreenOrientation UBlueprintPlatformLibrary::GetAllowedDeviceOrientation(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPlatformLibrary.GetAllowedDeviceOrientation");

	FGetAllowedDeviceOrientation parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UBlueprintPlatformLibrary::ClearAllLocalNotifications(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPlatformLibrary.ClearAllLocalNotifications");

	FClearAllLocalNotifications parms{};	

	ProcessEvent(fn, &parms);
}

void UBlueprintPlatformLibrary::CancelLocalNotificationById(int32_t NotificationId){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPlatformLibrary.CancelLocalNotificationById");

	FCancelLocalNotificationById parms{};	
	parms.NotificationId = NotificationId;

	ProcessEvent(fn, &parms);
}

void UBlueprintPlatformLibrary::CancelLocalNotification(struct FString ActivationEvent){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPlatformLibrary.CancelLocalNotification");

	FCancelLocalNotification parms{};	
	parms.ActivationEvent = ActivationEvent;

	ProcessEvent(fn, &parms);
}

bool UAnimInstance::WasAnimNotifyTriggeredInStateMachine(int32_t MachineIndex, UAnimNotify* AnimNotifyType){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.WasAnimNotifyTriggeredInStateMachine");

	FWasAnimNotifyTriggeredInStateMachine parms{};	
	parms.MachineIndex = MachineIndex;
	parms.AnimNotifyType = AnimNotifyType;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimInstance::WasAnimNotifyTriggeredInSourceState(int32_t MachineIndex, int32_t StateIndex, UAnimNotify* AnimNotifyType){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.WasAnimNotifyTriggeredInSourceState");

	FWasAnimNotifyTriggeredInSourceState parms{};	
	parms.MachineIndex = MachineIndex;
	parms.StateIndex = StateIndex;
	parms.AnimNotifyType = AnimNotifyType;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimInstance::WasAnimNotifyTriggeredInAnyState(UAnimNotify* AnimNotifyType){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.WasAnimNotifyTriggeredInAnyState");

	FWasAnimNotifyTriggeredInAnyState parms{};	
	parms.AnimNotifyType = AnimNotifyType;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimInstance::WasAnimNotifyStateActiveInStateMachine(int32_t MachineIndex, UAnimNotifyState* AnimNotifyStateType){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.WasAnimNotifyStateActiveInStateMachine");

	FWasAnimNotifyStateActiveInStateMachine parms{};	
	parms.MachineIndex = MachineIndex;
	parms.AnimNotifyStateType = AnimNotifyStateType;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimInstance::WasAnimNotifyStateActiveInSourceState(int32_t MachineIndex, int32_t StateIndex, UAnimNotifyState* AnimNotifyStateType){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.WasAnimNotifyStateActiveInSourceState");

	FWasAnimNotifyStateActiveInSourceState parms{};	
	parms.MachineIndex = MachineIndex;
	parms.StateIndex = StateIndex;
	parms.AnimNotifyStateType = AnimNotifyStateType;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimInstance::WasAnimNotifyStateActiveInAnyState(UAnimNotifyState* AnimNotifyStateType){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.WasAnimNotifyStateActiveInAnyState");

	FWasAnimNotifyStateActiveInAnyState parms{};	
	parms.AnimNotifyStateType = AnimNotifyStateType;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimInstance::WasAnimNotifyNameTriggeredInStateMachine(int32_t MachineIndex, struct FName NotifyName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.WasAnimNotifyNameTriggeredInStateMachine");

	FWasAnimNotifyNameTriggeredInStateMachine parms{};	
	parms.MachineIndex = MachineIndex;
	parms.NotifyName = NotifyName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimInstance::WasAnimNotifyNameTriggeredInSourceState(int32_t MachineIndex, int32_t StateIndex, struct FName NotifyName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.WasAnimNotifyNameTriggeredInSourceState");

	FWasAnimNotifyNameTriggeredInSourceState parms{};	
	parms.MachineIndex = MachineIndex;
	parms.StateIndex = StateIndex;
	parms.NotifyName = NotifyName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimInstance::WasAnimNotifyNameTriggeredInAnyState(struct FName NotifyName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.WasAnimNotifyNameTriggeredInAnyState");

	FWasAnimNotifyNameTriggeredInAnyState parms{};	
	parms.NotifyName = NotifyName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UAnimInstance::UnlockAIResources(bool bUnlockMovement, bool UnlockAILogic){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.UnlockAIResources");

	FUnlockAIResources parms{};	
	parms.bUnlockMovement = bUnlockMovement;
	parms.UnlockAILogic = UnlockAILogic;

	ProcessEvent(fn, &parms);
}

void UAnimInstance::UnlinkAnimClassLayers(UAnimInstance* InClass){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.UnlinkAnimClassLayers");

	FUnlinkAnimClassLayers parms{};	
	parms.InClass = InClass;

	ProcessEvent(fn, &parms);
}

struct APawn* UAnimInstance::TryGetPawnOwner(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.TryGetPawnOwner");

	FTryGetPawnOwner parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UAnimInstance::StopSlotAnimation(float InBlendOutTime, struct FName SlotNodeName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.StopSlotAnimation");

	FStopSlotAnimation parms{};	
	parms.InBlendOutTime = InBlendOutTime;
	parms.SlotNodeName = SlotNodeName;

	ProcessEvent(fn, &parms);
}

void UAnimInstance::SnapshotPose(struct FPoseSnapshot& Snapshot){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.SnapshotPose");

	FSnapshotPose parms{};	
	parms.Snapshot = Snapshot;

	ProcessEvent(fn, &parms);
}

void UAnimInstance::SetUseMainInstanceMontageEvaluationData(bool bSet){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.SetUseMainInstanceMontageEvaluationData");

	FSetUseMainInstanceMontageEvaluationData parms{};	
	parms.bSet = bSet;

	ProcessEvent(fn, &parms);
}

void UAnimInstance::SetRootMotionMode(enum class ERootMotionMode Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.SetRootMotionMode");

	FSetRootMotionMode parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UAnimInstance::SetReceiveNotifiesFromLinkedInstances(bool bSet){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.SetReceiveNotifiesFromLinkedInstances");

	FSetReceiveNotifiesFromLinkedInstances parms{};	
	parms.bSet = bSet;

	ProcessEvent(fn, &parms);
}

void UAnimInstance::SetPropagateNotifiesToLinkedInstances(bool bSet){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.SetPropagateNotifiesToLinkedInstances");

	FSetPropagateNotifiesToLinkedInstances parms{};	
	parms.bSet = bSet;

	ProcessEvent(fn, &parms);
}

void UAnimInstance::SetMorphTarget(struct FName MorphTargetName, float Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.SetMorphTarget");

	FSetMorphTarget parms{};	
	parms.MorphTargetName = MorphTargetName;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UAnimInstance::SavePoseSnapshot(struct FName SnapshotName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.SavePoseSnapshot");

	FSavePoseSnapshot parms{};	
	parms.SnapshotName = SnapshotName;

	ProcessEvent(fn, &parms);
}

void UAnimInstance::ResetDynamics(uint8_t InTeleportType){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.ResetDynamics");

	FResetDynamics parms{};	
	parms.InTeleportType = InTeleportType;

	ProcessEvent(fn, &parms);
}

bool UAnimInstance::RequestTransitionEvent(struct FName EventName, double RequestTimeout, uint8_t QueueMode, uint8_t OverwriteMode){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.RequestTransitionEvent");

	FRequestTransitionEvent parms{};	
	parms.EventName = EventName;
	parms.RequestTimeout = RequestTimeout;
	parms.QueueMode = QueueMode;
	parms.OverwriteMode = OverwriteMode;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UAnimInstance::RequestSlotGroupInertialization(struct FName InSlotGroupName, float Duration, struct UBlendProfile* BlendProfile){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.RequestSlotGroupInertialization");

	FRequestSlotGroupInertialization parms{};	
	parms.InSlotGroupName = InSlotGroupName;
	parms.Duration = Duration;
	parms.BlendProfile = BlendProfile;

	ProcessEvent(fn, &parms);
}

void UAnimInstance::RemovePoseSnapshot(struct FName SnapshotName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.RemovePoseSnapshot");

	FRemovePoseSnapshot parms{};	
	parms.SnapshotName = SnapshotName;

	ProcessEvent(fn, &parms);
}

bool UAnimInstance::QueryTransitionEvent(int32_t MachineIndex, int32_t TransitionIndex, struct FName EventName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.QueryTransitionEvent");

	FQueryTransitionEvent parms{};	
	parms.MachineIndex = MachineIndex;
	parms.TransitionIndex = TransitionIndex;
	parms.EventName = EventName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimInstance::QueryAndMarkTransitionEvent(int32_t MachineIndex, int32_t TransitionIndex, struct FName EventName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.QueryAndMarkTransitionEvent");

	FQueryAndMarkTransitionEvent parms{};	
	parms.MachineIndex = MachineIndex;
	parms.TransitionIndex = TransitionIndex;
	parms.EventName = EventName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UAnimMontage* UAnimInstance::PlaySlotAnimationAsDynamicMontage_WithBlendSettings(struct UAnimSequenceBase* Asset, struct FName SlotNodeName, struct FMontageBlendSettings& BlendInSettings, struct FMontageBlendSettings& BlendOutSettings, float InPlayRate, int32_t LoopCount, float BlendOutTriggerTime, float InTimeToStartMontageAt){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.PlaySlotAnimationAsDynamicMontage_WithBlendSettings");

	FPlaySlotAnimationAsDynamicMontage_WithBlendSettings parms{};	
	parms.Asset = Asset;
	parms.SlotNodeName = SlotNodeName;
	parms.BlendInSettings = BlendInSettings;
	parms.BlendOutSettings = BlendOutSettings;
	parms.InPlayRate = InPlayRate;
	parms.LoopCount = LoopCount;
	parms.BlendOutTriggerTime = BlendOutTriggerTime;
	parms.InTimeToStartMontageAt = InTimeToStartMontageAt;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UAnimMontage* UAnimInstance::PlaySlotAnimationAsDynamicMontage_WithBlendArgs(struct UAnimSequenceBase* Asset, struct FName SlotNodeName, struct FAlphaBlendArgs& BlendIn, struct FAlphaBlendArgs& BlendOut, float InPlayRate, int32_t LoopCount, float BlendOutTriggerTime, float InTimeToStartMontageAt){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.PlaySlotAnimationAsDynamicMontage_WithBlendArgs");

	FPlaySlotAnimationAsDynamicMontage_WithBlendArgs parms{};	
	parms.Asset = Asset;
	parms.SlotNodeName = SlotNodeName;
	parms.BlendIn = BlendIn;
	parms.BlendOut = BlendOut;
	parms.InPlayRate = InPlayRate;
	parms.LoopCount = LoopCount;
	parms.BlendOutTriggerTime = BlendOutTriggerTime;
	parms.InTimeToStartMontageAt = InTimeToStartMontageAt;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UAnimMontage* UAnimInstance::PlaySlotAnimationAsDynamicMontage(struct UAnimSequenceBase* Asset, struct FName SlotNodeName, float BlendInTime, float BlendOutTime, float InPlayRate, int32_t LoopCount, float BlendOutTriggerTime, float InTimeToStartMontageAt){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.PlaySlotAnimationAsDynamicMontage");

	FPlaySlotAnimationAsDynamicMontage parms{};	
	parms.Asset = Asset;
	parms.SlotNodeName = SlotNodeName;
	parms.BlendInTime = BlendInTime;
	parms.BlendOutTime = BlendOutTime;
	parms.InPlayRate = InPlayRate;
	parms.LoopCount = LoopCount;
	parms.BlendOutTriggerTime = BlendOutTriggerTime;
	parms.InTimeToStartMontageAt = InTimeToStartMontageAt;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UAnimInstance::MontageSync_StopFollowing(struct UAnimMontage* MontageFollower){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.MontageSync_StopFollowing");

	FMontageSync_StopFollowing parms{};	
	parms.MontageFollower = MontageFollower;

	ProcessEvent(fn, &parms);
}

void UAnimInstance::MontageSync_Follow(struct UAnimMontage* MontageFollower, struct UAnimInstance* OtherAnimInstance, struct UAnimMontage* MontageLeader){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.MontageSync_Follow");

	FMontageSync_Follow parms{};	
	parms.MontageFollower = MontageFollower;
	parms.OtherAnimInstance = OtherAnimInstance;
	parms.MontageLeader = MontageLeader;

	ProcessEvent(fn, &parms);
}

void UAnimInstance::Montage_StopWithBlendSettings(struct FMontageBlendSettings& BlendOutSettings, struct UAnimMontage* Montage){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_StopWithBlendSettings");

	FMontage_StopWithBlendSettings parms{};	
	parms.BlendOutSettings = BlendOutSettings;
	parms.Montage = Montage;

	ProcessEvent(fn, &parms);
}

void UAnimInstance::Montage_StopWithBlendOut(struct FAlphaBlendArgs& BlendOut, struct UAnimMontage* Montage){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_StopWithBlendOut");

	FMontage_StopWithBlendOut parms{};	
	parms.BlendOut = BlendOut;
	parms.Montage = Montage;

	ProcessEvent(fn, &parms);
}

void UAnimInstance::Montage_StopGroupByName(float InBlendOutTime, struct FName GroupName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_StopGroupByName");

	FMontage_StopGroupByName parms{};	
	parms.InBlendOutTime = InBlendOutTime;
	parms.GroupName = GroupName;

	ProcessEvent(fn, &parms);
}

void UAnimInstance::Montage_Stop(float InBlendOutTime, struct UAnimMontage* Montage){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_Stop");

	FMontage_Stop parms{};	
	parms.InBlendOutTime = InBlendOutTime;
	parms.Montage = Montage;

	ProcessEvent(fn, &parms);
}

void UAnimInstance::Montage_SetPosition(struct UAnimMontage* Montage, float NewPosition){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_SetPosition");

	FMontage_SetPosition parms{};	
	parms.Montage = Montage;
	parms.NewPosition = NewPosition;

	ProcessEvent(fn, &parms);
}

void UAnimInstance::Montage_SetPlayRate(struct UAnimMontage* Montage, float NewPlayRate){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_SetPlayRate");

	FMontage_SetPlayRate parms{};	
	parms.Montage = Montage;
	parms.NewPlayRate = NewPlayRate;

	ProcessEvent(fn, &parms);
}

void UAnimInstance::Montage_SetNextSection(struct FName SectionNameToChange, struct FName NextSection, struct UAnimMontage* Montage){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_SetNextSection");

	FMontage_SetNextSection parms{};	
	parms.SectionNameToChange = SectionNameToChange;
	parms.NextSection = NextSection;
	parms.Montage = Montage;

	ProcessEvent(fn, &parms);
}

void UAnimInstance::Montage_Resume(struct UAnimMontage* Montage){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_Resume");

	FMontage_Resume parms{};	
	parms.Montage = Montage;

	ProcessEvent(fn, &parms);
}

float UAnimInstance::Montage_PlayWithBlendSettings(struct UAnimMontage* MontageToPlay, struct FMontageBlendSettings& BlendInSettings, float InPlayRate, uint8_t ReturnValueType, float InTimeToStartMontageAt, bool bStopAllMontages){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_PlayWithBlendSettings");

	FMontage_PlayWithBlendSettings parms{};	
	parms.MontageToPlay = MontageToPlay;
	parms.BlendInSettings = BlendInSettings;
	parms.InPlayRate = InPlayRate;
	parms.ReturnValueType = ReturnValueType;
	parms.InTimeToStartMontageAt = InTimeToStartMontageAt;
	parms.bStopAllMontages = bStopAllMontages;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UAnimInstance::Montage_PlayWithBlendIn(struct UAnimMontage* MontageToPlay, struct FAlphaBlendArgs& BlendIn, float InPlayRate, uint8_t ReturnValueType, float InTimeToStartMontageAt, bool bStopAllMontages){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_PlayWithBlendIn");

	FMontage_PlayWithBlendIn parms{};	
	parms.MontageToPlay = MontageToPlay;
	parms.BlendIn = BlendIn;
	parms.InPlayRate = InPlayRate;
	parms.ReturnValueType = ReturnValueType;
	parms.InTimeToStartMontageAt = InTimeToStartMontageAt;
	parms.bStopAllMontages = bStopAllMontages;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UAnimInstance::Montage_Play(struct UAnimMontage* MontageToPlay, float InPlayRate, uint8_t ReturnValueType, float InTimeToStartMontageAt, bool bStopAllMontages){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_Play");

	FMontage_Play parms{};	
	parms.MontageToPlay = MontageToPlay;
	parms.InPlayRate = InPlayRate;
	parms.ReturnValueType = ReturnValueType;
	parms.InTimeToStartMontageAt = InTimeToStartMontageAt;
	parms.bStopAllMontages = bStopAllMontages;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UAnimInstance::Montage_Pause(struct UAnimMontage* Montage){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_Pause");

	FMontage_Pause parms{};	
	parms.Montage = Montage;

	ProcessEvent(fn, &parms);
}

void UAnimInstance::Montage_JumpToSectionsEnd(struct FName SectionName, struct UAnimMontage* Montage){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_JumpToSectionsEnd");

	FMontage_JumpToSectionsEnd parms{};	
	parms.SectionName = SectionName;
	parms.Montage = Montage;

	ProcessEvent(fn, &parms);
}

void UAnimInstance::Montage_JumpToSection(struct FName SectionName, struct UAnimMontage* Montage){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_JumpToSection");

	FMontage_JumpToSection parms{};	
	parms.SectionName = SectionName;
	parms.Montage = Montage;

	ProcessEvent(fn, &parms);
}

bool UAnimInstance::Montage_IsPlaying(struct UAnimMontage* Montage){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_IsPlaying");

	FMontage_IsPlaying parms{};	
	parms.Montage = Montage;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimInstance::Montage_IsActive(struct UAnimMontage* Montage){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_IsActive");

	FMontage_IsActive parms{};	
	parms.Montage = Montage;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UAnimInstance::Montage_GetPosition(struct UAnimMontage* Montage){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_GetPosition");

	FMontage_GetPosition parms{};	
	parms.Montage = Montage;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UAnimInstance::Montage_GetPlayRate(struct UAnimMontage* Montage){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_GetPlayRate");

	FMontage_GetPlayRate parms{};	
	parms.Montage = Montage;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimInstance::Montage_GetIsStopped(struct UAnimMontage* Montage){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_GetIsStopped");

	FMontage_GetIsStopped parms{};	
	parms.Montage = Montage;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FName UAnimInstance::Montage_GetCurrentSection(struct UAnimMontage* Montage){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_GetCurrentSection");

	FMontage_GetCurrentSection parms{};	
	parms.Montage = Montage;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UAnimInstance::Montage_GetBlendTime(struct UAnimMontage* Montage){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_GetBlendTime");

	FMontage_GetBlendTime parms{};	
	parms.Montage = Montage;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UAnimInstance::LockAIResources(bool bLockMovement, bool LockAILogic){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.LockAIResources");

	FLockAIResources parms{};	
	parms.bLockMovement = bLockMovement;
	parms.LockAILogic = LockAILogic;

	ProcessEvent(fn, &parms);
}

void UAnimInstance::LinkAnimGraphByTag(struct FName InTag, UAnimInstance* InClass){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.LinkAnimGraphByTag");

	FLinkAnimGraphByTag parms{};	
	parms.InTag = InTag;
	parms.InClass = InClass;

	ProcessEvent(fn, &parms);
}

void UAnimInstance::LinkAnimClassLayers(UAnimInstance* InClass){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.LinkAnimClassLayers");

	FLinkAnimClassLayers parms{};	
	parms.InClass = InClass;

	ProcessEvent(fn, &parms);
}

bool UAnimInstance::IsUsingMainInstanceMontageEvaluationData(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.IsUsingMainInstanceMontageEvaluationData");

	FIsUsingMainInstanceMontageEvaluationData parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimInstance::IsSyncGroupBetweenMarkers(struct FName InSyncGroupName, struct FName PreviousMarker, struct FName NextMarker, bool bRespectMarkerOrder){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.IsSyncGroupBetweenMarkers");

	FIsSyncGroupBetweenMarkers parms{};	
	parms.InSyncGroupName = InSyncGroupName;
	parms.PreviousMarker = PreviousMarker;
	parms.NextMarker = NextMarker;
	parms.bRespectMarkerOrder = bRespectMarkerOrder;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimInstance::IsPlayingSlotAnimation(struct UAnimSequenceBase* Asset, struct FName SlotNodeName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.IsPlayingSlotAnimation");

	FIsPlayingSlotAnimation parms{};	
	parms.Asset = Asset;
	parms.SlotNodeName = SlotNodeName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimInstance::IsAnyMontagePlaying(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.IsAnyMontagePlaying");

	FIsAnyMontagePlaying parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimInstance::HasMarkerBeenHitThisFrame(struct FName SyncGroup, struct FName MarkerName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.HasMarkerBeenHitThisFrame");

	FHasMarkerBeenHitThisFrame parms{};	
	parms.SyncGroup = SyncGroup;
	parms.MarkerName = MarkerName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimInstance::GetTimeToClosestMarker(struct FName SyncGroup, struct FName MarkerName, float& OutMarkerTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetTimeToClosestMarker");

	FGetTimeToClosestMarker parms{};	
	parms.SyncGroup = SyncGroup;
	parms.MarkerName = MarkerName;
	parms.OutMarkerTime = OutMarkerTime;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FMarkerSyncAnimPosition UAnimInstance::GetSyncGroupPosition(struct FName InSyncGroupName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetSyncGroupPosition");

	FGetSyncGroupPosition parms{};	
	parms.InSyncGroupName = InSyncGroupName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UAnimInstance::GetRelevantAnimTimeRemainingFraction(int32_t MachineIndex, int32_t StateIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetRelevantAnimTimeRemainingFraction");

	FGetRelevantAnimTimeRemainingFraction parms{};	
	parms.MachineIndex = MachineIndex;
	parms.StateIndex = StateIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UAnimInstance::GetRelevantAnimTimeRemaining(int32_t MachineIndex, int32_t StateIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetRelevantAnimTimeRemaining");

	FGetRelevantAnimTimeRemaining parms{};	
	parms.MachineIndex = MachineIndex;
	parms.StateIndex = StateIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UAnimInstance::GetRelevantAnimTimeFraction(int32_t MachineIndex, int32_t StateIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetRelevantAnimTimeFraction");

	FGetRelevantAnimTimeFraction parms{};	
	parms.MachineIndex = MachineIndex;
	parms.StateIndex = StateIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UAnimInstance::GetRelevantAnimTime(int32_t MachineIndex, int32_t StateIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetRelevantAnimTime");

	FGetRelevantAnimTime parms{};	
	parms.MachineIndex = MachineIndex;
	parms.StateIndex = StateIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UAnimInstance::GetRelevantAnimLength(int32_t MachineIndex, int32_t StateIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetRelevantAnimLength");

	FGetRelevantAnimLength parms{};	
	parms.MachineIndex = MachineIndex;
	parms.StateIndex = StateIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimInstance::GetReceiveNotifiesFromLinkedInstances(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetReceiveNotifiesFromLinkedInstances");

	FGetReceiveNotifiesFromLinkedInstances parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimInstance::GetPropagateNotifiesToLinkedInstances(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetPropagateNotifiesToLinkedInstances");

	FGetPropagateNotifiesToLinkedInstances parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct USkeletalMeshComponent* UAnimInstance::GetOwningComponent(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetOwningComponent");

	FGetOwningComponent parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct AActor* UAnimInstance::GetOwningActor(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetOwningActor");

	FGetOwningActor parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UAnimInstance::GetLinkedAnimLayerInstancesByGroup(struct FName InGroup, struct TArray<struct UAnimInstance*>& OutLinkedInstances){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetLinkedAnimLayerInstancesByGroup");

	FGetLinkedAnimLayerInstancesByGroup parms{};	
	parms.InGroup = InGroup;
	parms.OutLinkedInstances = OutLinkedInstances;

	ProcessEvent(fn, &parms);
}

struct UAnimInstance* UAnimInstance::GetLinkedAnimLayerInstanceByGroupAndClass(struct FName InGroup, UAnimInstance* InClass){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetLinkedAnimLayerInstanceByGroupAndClass");

	FGetLinkedAnimLayerInstanceByGroupAndClass parms{};	
	parms.InGroup = InGroup;
	parms.InClass = InClass;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UAnimInstance* UAnimInstance::GetLinkedAnimLayerInstanceByGroup(struct FName InGroup){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetLinkedAnimLayerInstanceByGroup");

	FGetLinkedAnimLayerInstanceByGroup parms{};	
	parms.InGroup = InGroup;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UAnimInstance* UAnimInstance::GetLinkedAnimLayerInstanceByClass(UAnimInstance* InClass){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetLinkedAnimLayerInstanceByClass");

	FGetLinkedAnimLayerInstanceByClass parms{};	
	parms.InClass = InClass;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UAnimInstance::GetLinkedAnimGraphInstancesByTag(struct FName InTag, struct TArray<struct UAnimInstance*>& OutLinkedInstances){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetLinkedAnimGraphInstancesByTag");

	FGetLinkedAnimGraphInstancesByTag parms{};	
	parms.InTag = InTag;
	parms.OutLinkedInstances = OutLinkedInstances;

	ProcessEvent(fn, &parms);
}

struct UAnimInstance* UAnimInstance::GetLinkedAnimGraphInstanceByTag(struct FName InTag){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetLinkedAnimGraphInstanceByTag");

	FGetLinkedAnimGraphInstanceByTag parms{};	
	parms.InTag = InTag;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UAnimInstance::GetInstanceTransitionTimeElapsedFraction(int32_t MachineIndex, int32_t TransitionIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceTransitionTimeElapsedFraction");

	FGetInstanceTransitionTimeElapsedFraction parms{};	
	parms.MachineIndex = MachineIndex;
	parms.TransitionIndex = TransitionIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UAnimInstance::GetInstanceTransitionTimeElapsed(int32_t MachineIndex, int32_t TransitionIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceTransitionTimeElapsed");

	FGetInstanceTransitionTimeElapsed parms{};	
	parms.MachineIndex = MachineIndex;
	parms.TransitionIndex = TransitionIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UAnimInstance::GetInstanceTransitionCrossfadeDuration(int32_t MachineIndex, int32_t TransitionIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceTransitionCrossfadeDuration");

	FGetInstanceTransitionCrossfadeDuration parms{};	
	parms.MachineIndex = MachineIndex;
	parms.TransitionIndex = TransitionIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UAnimInstance::GetInstanceStateWeight(int32_t MachineIndex, int32_t StateIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceStateWeight");

	FGetInstanceStateWeight parms{};	
	parms.MachineIndex = MachineIndex;
	parms.StateIndex = StateIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UAnimInstance::GetInstanceMachineWeight(int32_t MachineIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceMachineWeight");

	FGetInstanceMachineWeight parms{};	
	parms.MachineIndex = MachineIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UAnimInstance::GetInstanceCurrentStateElapsedTime(int32_t MachineIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceCurrentStateElapsedTime");

	FGetInstanceCurrentStateElapsedTime parms{};	
	parms.MachineIndex = MachineIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UAnimInstance::GetInstanceAssetPlayerTimeFromEndFraction(int32_t AssetPlayerIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceAssetPlayerTimeFromEndFraction");

	FGetInstanceAssetPlayerTimeFromEndFraction parms{};	
	parms.AssetPlayerIndex = AssetPlayerIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UAnimInstance::GetInstanceAssetPlayerTimeFromEnd(int32_t AssetPlayerIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceAssetPlayerTimeFromEnd");

	FGetInstanceAssetPlayerTimeFromEnd parms{};	
	parms.AssetPlayerIndex = AssetPlayerIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UAnimInstance::GetInstanceAssetPlayerTimeFraction(int32_t AssetPlayerIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceAssetPlayerTimeFraction");

	FGetInstanceAssetPlayerTimeFraction parms{};	
	parms.AssetPlayerIndex = AssetPlayerIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UAnimInstance::GetInstanceAssetPlayerTime(int32_t AssetPlayerIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceAssetPlayerTime");

	FGetInstanceAssetPlayerTime parms{};	
	parms.AssetPlayerIndex = AssetPlayerIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UAnimInstance::GetInstanceAssetPlayerLength(int32_t AssetPlayerIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceAssetPlayerLength");

	FGetInstanceAssetPlayerLength parms{};	
	parms.AssetPlayerIndex = AssetPlayerIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UAnimInstance::GetDeltaSeconds(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetDeltaSeconds");

	FGetDeltaSeconds parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimInstance::GetCurveValueWithDefault(struct FName CurveName, float DefaultValue, float& OutValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetCurveValueWithDefault");

	FGetCurveValueWithDefault parms{};	
	parms.CurveName = CurveName;
	parms.DefaultValue = DefaultValue;
	parms.OutValue = OutValue;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UAnimInstance::GetCurveValue(struct FName CurveName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetCurveValue");

	FGetCurveValue parms{};	
	parms.CurveName = CurveName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FName UAnimInstance::GetCurrentStateName(int32_t MachineIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetCurrentStateName");

	FGetCurrentStateName parms{};	
	parms.MachineIndex = MachineIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UAnimMontage* UAnimInstance::GetCurrentActiveMontage(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetCurrentActiveMontage");

	FGetCurrentActiveMontage parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UAnimInstance::GetAllCurveNames(struct TArray<struct FName>& OutNames){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetAllCurveNames");

	FGetAllCurveNames parms{};	
	parms.OutNames = OutNames;

	ProcessEvent(fn, &parms);
}

void UAnimInstance::GetActiveCurveNames(uint8_t CurveType, struct TArray<struct FName>& OutNames){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetActiveCurveNames");

	FGetActiveCurveNames parms{};	
	parms.CurveType = CurveType;
	parms.OutNames = OutNames;

	ProcessEvent(fn, &parms);
}

void UAnimInstance::ClearTransitionEvents(struct FName EventName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.ClearTransitionEvents");

	FClearTransitionEvents parms{};	
	parms.EventName = EventName;

	ProcessEvent(fn, &parms);
}

void UAnimInstance::ClearMorphTargets(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.ClearMorphTargets");

	FClearMorphTargets parms{};	

	ProcessEvent(fn, &parms);
}

void UAnimInstance::ClearAllTransitionEvents(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.ClearAllTransitionEvents");

	FClearAllTransitionEvents parms{};	

	ProcessEvent(fn, &parms);
}

float UAnimInstance::CalculateDirection(struct FVector& Velocity, struct FRotator& BaseRotation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.CalculateDirection");

	FCalculateDirection parms{};	
	parms.Velocity = Velocity;
	parms.BaseRotation = BaseRotation;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UAnimInstance::BlueprintUpdateAnimation(float DeltaTimeX){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.BlueprintUpdateAnimation");

	FBlueprintUpdateAnimation parms{};	
	parms.DeltaTimeX = DeltaTimeX;

	ProcessEvent(fn, &parms);
}

void UAnimInstance::BlueprintThreadSafeUpdateAnimation(float DeltaTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.BlueprintThreadSafeUpdateAnimation");

	FBlueprintThreadSafeUpdateAnimation parms{};	
	parms.DeltaTime = DeltaTime;

	ProcessEvent(fn, &parms);
}

void UAnimInstance::BlueprintPostEvaluateAnimation(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.BlueprintPostEvaluateAnimation");

	FBlueprintPostEvaluateAnimation parms{};	

	ProcessEvent(fn, &parms);
}

void UAnimInstance::BlueprintLinkedAnimationLayersInitialized(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.BlueprintLinkedAnimationLayersInitialized");

	FBlueprintLinkedAnimationLayersInitialized parms{};	

	ProcessEvent(fn, &parms);
}

void UAnimInstance::BlueprintInitializeAnimation(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.BlueprintInitializeAnimation");

	FBlueprintInitializeAnimation parms{};	

	ProcessEvent(fn, &parms);
}

void UAnimInstance::BlueprintBeginPlay(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimInstance.BlueprintBeginPlay");

	FBlueprintBeginPlay parms{};	

	ProcessEvent(fn, &parms);
}

void UCameraShakeBase::SetRootShakePattern(struct UCameraShakePattern* InPattern){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CameraShakeBase.SetRootShakePattern");

	FSetRootShakePattern parms{};	
	parms.InPattern = InPattern;

	ProcessEvent(fn, &parms);
}

struct UCameraShakePattern* UCameraShakeBase::GetRootShakePattern(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CameraShakeBase.GetRootShakePattern");

	FGetRootShakePattern parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UCameraModifier::OnCameraOwnerDestroyed(struct AActor* InOwner){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CameraModifier.OnCameraOwnerDestroyed");

	FOnCameraOwnerDestroyed parms{};	
	parms.InOwner = InOwner;

	ProcessEvent(fn, &parms);
}

bool UCameraModifier::IsDisabled(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CameraModifier.IsDisabled");

	FIsDisabled parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct AActor* UCameraModifier::GetViewTarget(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CameraModifier.GetViewTarget");

	FGetViewTarget parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UCameraModifier::EnableModifier(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CameraModifier.EnableModifier");

	FEnableModifier parms{};	

	ProcessEvent(fn, &parms);
}

void UCameraModifier::DisableModifier(bool bImmediate){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CameraModifier.DisableModifier");

	FDisableModifier parms{};	
	parms.bImmediate = bImmediate;

	ProcessEvent(fn, &parms);
}

void UCameraModifier::BlueprintModifyPostProcess(float DeltaTime, float& PostProcessBlendWeight, struct FPostProcessSettings& PostProcessSettings){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CameraModifier.BlueprintModifyPostProcess");

	FBlueprintModifyPostProcess parms{};	
	parms.DeltaTime = DeltaTime;
	parms.PostProcessBlendWeight = PostProcessBlendWeight;
	parms.PostProcessSettings = PostProcessSettings;

	ProcessEvent(fn, &parms);
}

void UCameraModifier::BlueprintModifyCamera(float DeltaTime, struct FVector ViewLocation, struct FRotator ViewRotation, float FOV, struct FVector& NewViewLocation, struct FRotator& NewViewRotation, float& NewFOV){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CameraModifier.BlueprintModifyCamera");

	FBlueprintModifyCamera parms{};	
	parms.DeltaTime = DeltaTime;
	parms.ViewLocation = ViewLocation;
	parms.ViewRotation = ViewRotation;
	parms.FOV = FOV;
	parms.NewViewLocation = NewViewLocation;
	parms.NewViewRotation = NewViewRotation;
	parms.NewFOV = NewFOV;

	ProcessEvent(fn, &parms);
}

void UPhysicalAnimationComponent::SetStrengthMultiplyer(float InStrengthMultiplyer){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicalAnimationComponent.SetStrengthMultiplyer");

	FSetStrengthMultiplyer parms{};	
	parms.InStrengthMultiplyer = InStrengthMultiplyer;

	ProcessEvent(fn, &parms);
}

void UPhysicalAnimationComponent::SetSkeletalMeshComponent(struct USkeletalMeshComponent* InSkeletalMeshComponent){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicalAnimationComponent.SetSkeletalMeshComponent");

	FSetSkeletalMeshComponent parms{};	
	parms.InSkeletalMeshComponent = InSkeletalMeshComponent;

	ProcessEvent(fn, &parms);
}

struct FTransform UPhysicalAnimationComponent::GetBodyTargetTransform(struct FName BodyName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicalAnimationComponent.GetBodyTargetTransform");

	FGetBodyTargetTransform parms{};	
	parms.BodyName = BodyName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UPhysicalAnimationComponent::ApplyPhysicalAnimationSettingsBelow(struct FName BodyName, struct FPhysicalAnimationData& PhysicalAnimationData, bool bIncludeSelf){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicalAnimationComponent.ApplyPhysicalAnimationSettingsBelow");

	FApplyPhysicalAnimationSettingsBelow parms{};	
	parms.BodyName = BodyName;
	parms.PhysicalAnimationData = PhysicalAnimationData;
	parms.bIncludeSelf = bIncludeSelf;

	ProcessEvent(fn, &parms);
}

void UPhysicalAnimationComponent::ApplyPhysicalAnimationSettings(struct FName BodyName, struct FPhysicalAnimationData& PhysicalAnimationData){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicalAnimationComponent.ApplyPhysicalAnimationSettings");

	FApplyPhysicalAnimationSettings parms{};	
	parms.BodyName = BodyName;
	parms.PhysicalAnimationData = PhysicalAnimationData;

	ProcessEvent(fn, &parms);
}

void UPhysicalAnimationComponent::ApplyPhysicalAnimationProfileBelow(struct FName BodyName, struct FName ProfileName, bool bIncludeSelf, bool bClearNotFound){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicalAnimationComponent.ApplyPhysicalAnimationProfileBelow");

	FApplyPhysicalAnimationProfileBelow parms{};	
	parms.BodyName = BodyName;
	parms.ProfileName = ProfileName;
	parms.bIncludeSelf = bIncludeSelf;
	parms.bClearNotFound = bClearNotFound;

	ProcessEvent(fn, &parms);
}

void UMovementComponent::StopMovementImmediately(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MovementComponent.StopMovementImmediately");

	FStopMovementImmediately parms{};	

	ProcessEvent(fn, &parms);
}

void UMovementComponent::SnapUpdatedComponentToPlane(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MovementComponent.SnapUpdatedComponentToPlane");

	FSnapUpdatedComponentToPlane parms{};	

	ProcessEvent(fn, &parms);
}

void UMovementComponent::SetUpdatedComponent(struct USceneComponent* NewUpdatedComponent){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MovementComponent.SetUpdatedComponent");

	FSetUpdatedComponent parms{};	
	parms.NewUpdatedComponent = NewUpdatedComponent;

	ProcessEvent(fn, &parms);
}

void UMovementComponent::SetPlaneConstraintOrigin(struct FVector PlaneOrigin){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MovementComponent.SetPlaneConstraintOrigin");

	FSetPlaneConstraintOrigin parms{};	
	parms.PlaneOrigin = PlaneOrigin;

	ProcessEvent(fn, &parms);
}

void UMovementComponent::SetPlaneConstraintNormal(struct FVector PlaneNormal){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MovementComponent.SetPlaneConstraintNormal");

	FSetPlaneConstraintNormal parms{};	
	parms.PlaneNormal = PlaneNormal;

	ProcessEvent(fn, &parms);
}

void UMovementComponent::SetPlaneConstraintFromVectors(struct FVector Forward, struct FVector Up){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MovementComponent.SetPlaneConstraintFromVectors");

	FSetPlaneConstraintFromVectors parms{};	
	parms.Forward = Forward;
	parms.Up = Up;

	ProcessEvent(fn, &parms);
}

void UMovementComponent::SetPlaneConstraintEnabled(bool bEnabled){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MovementComponent.SetPlaneConstraintEnabled");

	FSetPlaneConstraintEnabled parms{};	
	parms.bEnabled = bEnabled;

	ProcessEvent(fn, &parms);
}

void UMovementComponent::SetPlaneConstraintAxisSetting(uint8_t NewAxisSetting){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MovementComponent.SetPlaneConstraintAxisSetting");

	FSetPlaneConstraintAxisSetting parms{};	
	parms.NewAxisSetting = NewAxisSetting;

	ProcessEvent(fn, &parms);
}

void UMovementComponent::PhysicsVolumeChanged(struct APhysicsVolume* NewVolume){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MovementComponent.PhysicsVolumeChanged");

	FPhysicsVolumeChanged parms{};	
	parms.NewVolume = NewVolume;

	ProcessEvent(fn, &parms);
}

bool UMovementComponent::K2_MoveUpdatedComponent(struct FVector Delta, struct FRotator NewRotation, struct FHitResult& OutHit, bool bSweep, bool bTeleport){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MovementComponent.K2_MoveUpdatedComponent");

	FK2_MoveUpdatedComponent parms{};	
	parms.Delta = Delta;
	parms.NewRotation = NewRotation;
	parms.OutHit = OutHit;
	parms.bSweep = bSweep;
	parms.bTeleport = bTeleport;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UMovementComponent::IsExceedingMaxSpeed(float MaxSpeed){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MovementComponent.IsExceedingMaxSpeed");

	FIsExceedingMaxSpeed parms{};	
	parms.MaxSpeed = MaxSpeed;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UMovementComponent::GetPlaneConstraintOrigin(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MovementComponent.GetPlaneConstraintOrigin");

	FGetPlaneConstraintOrigin parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UMovementComponent::GetPlaneConstraintNormal(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MovementComponent.GetPlaneConstraintNormal");

	FGetPlaneConstraintNormal parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

uint8_t UMovementComponent::GetPlaneConstraintAxisSetting(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MovementComponent.GetPlaneConstraintAxisSetting");

	FGetPlaneConstraintAxisSetting parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct APhysicsVolume* UMovementComponent::GetPhysicsVolume(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MovementComponent.GetPhysicsVolume");

	FGetPhysicsVolume parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UMovementComponent::GetMaxSpeed(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MovementComponent.GetMaxSpeed");

	FGetMaxSpeed parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UMovementComponent::GetGravityZ(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MovementComponent.GetGravityZ");

	FGetGravityZ parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UMovementComponent::ConstrainNormalToPlane(struct FVector Normal){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MovementComponent.ConstrainNormalToPlane");

	FConstrainNormalToPlane parms{};	
	parms.Normal = Normal;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UMovementComponent::ConstrainLocationToPlane(struct FVector Location){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MovementComponent.ConstrainLocationToPlane");

	FConstrainLocationToPlane parms{};	
	parms.Location = Location;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UMovementComponent::ConstrainDirectionToPlane(struct FVector Direction){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MovementComponent.ConstrainDirectionToPlane");

	FConstrainDirectionToPlane parms{};	
	parms.Direction = Direction;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UNavMovementComponent::StopMovementKeepPathing(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.NavMovementComponent.StopMovementKeepPathing");

	FStopMovementKeepPathing parms{};	

	ProcessEvent(fn, &parms);
}

void UNavMovementComponent::StopActiveMovement(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.NavMovementComponent.StopActiveMovement");

	FStopActiveMovement parms{};	

	ProcessEvent(fn, &parms);
}

bool UNavMovementComponent::IsSwimming(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.NavMovementComponent.IsSwimming");

	FIsSwimming parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UNavMovementComponent::IsMovingOnGround(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.NavMovementComponent.IsMovingOnGround");

	FIsMovingOnGround parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UNavMovementComponent::IsFlying(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.NavMovementComponent.IsFlying");

	FIsFlying parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UNavMovementComponent::IsFalling(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.NavMovementComponent.IsFalling");

	FIsFalling parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UNavMovementComponent::IsCrouching(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.NavMovementComponent.IsCrouching");

	FIsCrouching parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UPawnMovementComponent::IsMoveInputIgnored(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PawnMovementComponent.IsMoveInputIgnored");

	FIsMoveInputIgnored parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UPawnMovementComponent::GetPendingInputVector(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PawnMovementComponent.GetPendingInputVector");

	FGetPendingInputVector parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct APawn* UPawnMovementComponent::GetPawnOwner(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PawnMovementComponent.GetPawnOwner");

	FGetPawnOwner parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UPawnMovementComponent::GetLastInputVector(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PawnMovementComponent.GetLastInputVector");

	FGetLastInputVector parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UPawnMovementComponent::ConsumeInputVector(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PawnMovementComponent.ConsumeInputVector");

	FConsumeInputVector parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UPawnMovementComponent::AddInputVector(struct FVector WorldVector, bool bForce){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PawnMovementComponent.AddInputVector");

	FAddInputVector parms{};	
	parms.WorldVector = WorldVector;
	parms.bForce = bForce;

	ProcessEvent(fn, &parms);
}

void USplineMeshComponent::UpdateMesh(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.UpdateMesh");

	FUpdateMesh parms{};	

	ProcessEvent(fn, &parms);
}

void USplineMeshComponent::SetStartTangent(struct FVector StartTangent, bool bUpdateMesh){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetStartTangent");

	FSetStartTangent parms{};	
	parms.StartTangent = StartTangent;
	parms.bUpdateMesh = bUpdateMesh;

	ProcessEvent(fn, &parms);
}

void USplineMeshComponent::SetStartScale(struct FVector2D StartScale, bool bUpdateMesh){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetStartScale");

	FSetStartScale parms{};	
	parms.StartScale = StartScale;
	parms.bUpdateMesh = bUpdateMesh;

	ProcessEvent(fn, &parms);
}

void USplineMeshComponent::SetStartRoll(float StartRoll, bool bUpdateMesh){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetStartRoll");

	FSetStartRoll parms{};	
	parms.StartRoll = StartRoll;
	parms.bUpdateMesh = bUpdateMesh;

	ProcessEvent(fn, &parms);
}

void USplineMeshComponent::SetStartPosition(struct FVector StartPos, bool bUpdateMesh){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetStartPosition");

	FSetStartPosition parms{};	
	parms.StartPos = StartPos;
	parms.bUpdateMesh = bUpdateMesh;

	ProcessEvent(fn, &parms);
}

void USplineMeshComponent::SetStartOffset(struct FVector2D StartOffset, bool bUpdateMesh){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetStartOffset");

	FSetStartOffset parms{};	
	parms.StartOffset = StartOffset;
	parms.bUpdateMesh = bUpdateMesh;

	ProcessEvent(fn, &parms);
}

void USplineMeshComponent::SetStartAndEnd(struct FVector StartPos, struct FVector StartTangent, struct FVector EndPos, struct FVector EndTangent, bool bUpdateMesh){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetStartAndEnd");

	FSetStartAndEnd parms{};	
	parms.StartPos = StartPos;
	parms.StartTangent = StartTangent;
	parms.EndPos = EndPos;
	parms.EndTangent = EndTangent;
	parms.bUpdateMesh = bUpdateMesh;

	ProcessEvent(fn, &parms);
}

void USplineMeshComponent::SetSplineUpDir(struct FVector& InSplineUpDir, bool bUpdateMesh){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetSplineUpDir");

	FSetSplineUpDir parms{};	
	parms.InSplineUpDir = InSplineUpDir;
	parms.bUpdateMesh = bUpdateMesh;

	ProcessEvent(fn, &parms);
}

void USplineMeshComponent::SetForwardAxis(enum class ESplineMeshAxis InForwardAxis, bool bUpdateMesh){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetForwardAxis");

	FSetForwardAxis parms{};	
	parms.InForwardAxis = InForwardAxis;
	parms.bUpdateMesh = bUpdateMesh;

	ProcessEvent(fn, &parms);
}

void USplineMeshComponent::SetEndTangent(struct FVector EndTangent, bool bUpdateMesh){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetEndTangent");

	FSetEndTangent parms{};	
	parms.EndTangent = EndTangent;
	parms.bUpdateMesh = bUpdateMesh;

	ProcessEvent(fn, &parms);
}

void USplineMeshComponent::SetEndScale(struct FVector2D EndScale, bool bUpdateMesh){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetEndScale");

	FSetEndScale parms{};	
	parms.EndScale = EndScale;
	parms.bUpdateMesh = bUpdateMesh;

	ProcessEvent(fn, &parms);
}

void USplineMeshComponent::SetEndRoll(float EndRoll, bool bUpdateMesh){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetEndRoll");

	FSetEndRoll parms{};	
	parms.EndRoll = EndRoll;
	parms.bUpdateMesh = bUpdateMesh;

	ProcessEvent(fn, &parms);
}

void USplineMeshComponent::SetEndPosition(struct FVector EndPos, bool bUpdateMesh){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetEndPosition");

	FSetEndPosition parms{};	
	parms.EndPos = EndPos;
	parms.bUpdateMesh = bUpdateMesh;

	ProcessEvent(fn, &parms);
}

void USplineMeshComponent::SetEndOffset(struct FVector2D EndOffset, bool bUpdateMesh){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetEndOffset");

	FSetEndOffset parms{};	
	parms.EndOffset = EndOffset;
	parms.bUpdateMesh = bUpdateMesh;

	ProcessEvent(fn, &parms);
}

void USplineMeshComponent::SetBoundaryMin(float InBoundaryMin, bool bUpdateMesh){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetBoundaryMin");

	FSetBoundaryMin parms{};	
	parms.InBoundaryMin = InBoundaryMin;
	parms.bUpdateMesh = bUpdateMesh;

	ProcessEvent(fn, &parms);
}

void USplineMeshComponent::SetBoundaryMax(float InBoundaryMax, bool bUpdateMesh){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetBoundaryMax");

	FSetBoundaryMax parms{};	
	parms.InBoundaryMax = InBoundaryMax;
	parms.bUpdateMesh = bUpdateMesh;

	ProcessEvent(fn, &parms);
}

struct FVector USplineMeshComponent::GetStartTangent(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetStartTangent");

	FGetStartTangent parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector2D USplineMeshComponent::GetStartScale(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetStartScale");

	FGetStartScale parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float USplineMeshComponent::GetStartRoll(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetStartRoll");

	FGetStartRoll parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineMeshComponent::GetStartPosition(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetStartPosition");

	FGetStartPosition parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector2D USplineMeshComponent::GetStartOffset(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetStartOffset");

	FGetStartOffset parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineMeshComponent::GetSplineUpDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetSplineUpDir");

	FGetSplineUpDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

enum class ESplineMeshAxis USplineMeshComponent::GetForwardAxis(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetForwardAxis");

	FGetForwardAxis parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineMeshComponent::GetEndTangent(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetEndTangent");

	FGetEndTangent parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector2D USplineMeshComponent::GetEndScale(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetEndScale");

	FGetEndScale parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float USplineMeshComponent::GetEndRoll(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetEndRoll");

	FGetEndRoll parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USplineMeshComponent::GetEndPosition(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetEndPosition");

	FGetEndPosition parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector2D USplineMeshComponent::GetEndOffset(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetEndOffset");

	FGetEndOffset parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float USplineMeshComponent::GetBoundaryMin(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetBoundaryMin");

	FGetBoundaryMin parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float USplineMeshComponent::GetBoundaryMax(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetBoundaryMax");

	FGetBoundaryMax parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UCharacterMovementComponent::SetWalkableFloorZ(float InWalkableFloorZ){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetWalkableFloorZ");

	FSetWalkableFloorZ parms{};	
	parms.InWalkableFloorZ = InWalkableFloorZ;

	ProcessEvent(fn, &parms);
}

void UCharacterMovementComponent::SetWalkableFloorAngle(float InWalkableFloorAngle){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetWalkableFloorAngle");

	FSetWalkableFloorAngle parms{};	
	parms.InWalkableFloorAngle = InWalkableFloorAngle;

	ProcessEvent(fn, &parms);
}

void UCharacterMovementComponent::SetMovementMode(enum class EMovementMode NewMovementMode, char NewCustomMode){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetMovementMode");

	FSetMovementMode parms{};	
	parms.NewMovementMode = NewMovementMode;
	parms.NewCustomMode = NewCustomMode;

	ProcessEvent(fn, &parms);
}

void UCharacterMovementComponent::SetGroupsToIgnoreMask(struct FNavAvoidanceMask& GroupMask){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetGroupsToIgnoreMask");

	FSetGroupsToIgnoreMask parms{};	
	parms.GroupMask = GroupMask;

	ProcessEvent(fn, &parms);
}

void UCharacterMovementComponent::SetGroupsToIgnore(int32_t GroupFlags){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetGroupsToIgnore");

	FSetGroupsToIgnore parms{};	
	parms.GroupFlags = GroupFlags;

	ProcessEvent(fn, &parms);
}

void UCharacterMovementComponent::SetGroupsToAvoidMask(struct FNavAvoidanceMask& GroupMask){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetGroupsToAvoidMask");

	FSetGroupsToAvoidMask parms{};	
	parms.GroupMask = GroupMask;

	ProcessEvent(fn, &parms);
}

void UCharacterMovementComponent::SetGroupsToAvoid(int32_t GroupFlags){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetGroupsToAvoid");

	FSetGroupsToAvoid parms{};	
	parms.GroupFlags = GroupFlags;

	ProcessEvent(fn, &parms);
}

void UCharacterMovementComponent::SetCrouchedHalfHeight(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetCrouchedHalfHeight");

	FSetCrouchedHalfHeight parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UCharacterMovementComponent::SetAvoidanceGroupMask(struct FNavAvoidanceMask& GroupMask){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetAvoidanceGroupMask");

	FSetAvoidanceGroupMask parms{};	
	parms.GroupMask = GroupMask;

	ProcessEvent(fn, &parms);
}

void UCharacterMovementComponent::SetAvoidanceGroup(int32_t GroupFlags){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetAvoidanceGroup");

	FSetAvoidanceGroup parms{};	
	parms.GroupFlags = GroupFlags;

	ProcessEvent(fn, &parms);
}

void UCharacterMovementComponent::SetAvoidanceEnabled(bool bEnable){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetAvoidanceEnabled");

	FSetAvoidanceEnabled parms{};	
	parms.bEnable = bEnable;

	ProcessEvent(fn, &parms);
}

float UCharacterMovementComponent::K2_GetWalkableFloorZ(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.K2_GetWalkableFloorZ");

	FK2_GetWalkableFloorZ parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UCharacterMovementComponent::K2_GetWalkableFloorAngle(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.K2_GetWalkableFloorAngle");

	FK2_GetWalkableFloorAngle parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UCharacterMovementComponent::K2_FindFloor(struct FVector CapsuleLocation, struct FFindFloorResult& FloorResult){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.K2_FindFloor");

	FK2_FindFloor parms{};	
	parms.CapsuleLocation = CapsuleLocation;
	parms.FloorResult = FloorResult;

	ProcessEvent(fn, &parms);
}

void UCharacterMovementComponent::K2_ComputeFloorDist(struct FVector CapsuleLocation, float LineDistance, float SweepDistance, float SweepRadius, struct FFindFloorResult& FloorResult){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.K2_ComputeFloorDist");

	FK2_ComputeFloorDist parms{};	
	parms.CapsuleLocation = CapsuleLocation;
	parms.LineDistance = LineDistance;
	parms.SweepDistance = SweepDistance;
	parms.SweepRadius = SweepRadius;
	parms.FloorResult = FloorResult;

	ProcessEvent(fn, &parms);
}

bool UCharacterMovementComponent::IsWalking(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.IsWalking");

	FIsWalking parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UCharacterMovementComponent::IsWalkable(struct FHitResult& Hit){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.IsWalkable");

	FIsWalkable parms{};	
	parms.Hit = Hit;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UCharacterMovementComponent::GetValidPerchRadius(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetValidPerchRadius");

	FGetValidPerchRadius parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UCharacterMovementComponent::GetPerchRadiusThreshold(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetPerchRadiusThreshold");

	FGetPerchRadiusThreshold parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UPrimitiveComponent* UCharacterMovementComponent::GetMovementBase(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetMovementBase");

	FGetMovementBase parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UCharacterMovementComponent::GetMinAnalogSpeed(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetMinAnalogSpeed");

	FGetMinAnalogSpeed parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UCharacterMovementComponent::GetMaxJumpHeightWithJumpTime(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetMaxJumpHeightWithJumpTime");

	FGetMaxJumpHeightWithJumpTime parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UCharacterMovementComponent::GetMaxJumpHeight(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetMaxJumpHeight");

	FGetMaxJumpHeight parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UCharacterMovementComponent::GetMaxBrakingDeceleration(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetMaxBrakingDeceleration");

	FGetMaxBrakingDeceleration parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UCharacterMovementComponent::GetMaxAcceleration(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetMaxAcceleration");

	FGetMaxAcceleration parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UCharacterMovementComponent::GetLastUpdateVelocity(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetLastUpdateVelocity");

	FGetLastUpdateVelocity parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator UCharacterMovementComponent::GetLastUpdateRotation(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetLastUpdateRotation");

	FGetLastUpdateRotation parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UCharacterMovementComponent::GetLastUpdateRequestedVelocity(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetLastUpdateRequestedVelocity");

	FGetLastUpdateRequestedVelocity parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UCharacterMovementComponent::GetLastUpdateLocation(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetLastUpdateLocation");

	FGetLastUpdateLocation parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UCharacterMovementComponent::GetImpartedMovementBaseVelocity(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetImpartedMovementBaseVelocity");

	FGetImpartedMovementBaseVelocity parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UCharacterMovementComponent::GetCurrentAcceleration(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetCurrentAcceleration");

	FGetCurrentAcceleration parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UCharacterMovementComponent::GetCrouchedHalfHeight(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetCrouchedHalfHeight");

	FGetCrouchedHalfHeight parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct ACharacter* UCharacterMovementComponent::GetCharacterOwner(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetCharacterOwner");

	FGetCharacterOwner parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UCharacterMovementComponent::GetAnalogInputModifier(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetAnalogInputModifier");

	FGetAnalogInputModifier parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UCharacterMovementComponent::DisableMovement(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.DisableMovement");

	FDisableMovement parms{};	

	ProcessEvent(fn, &parms);
}

void UCharacterMovementComponent::ClearAccumulatedForces(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.ClearAccumulatedForces");

	FClearAccumulatedForces parms{};	

	ProcessEvent(fn, &parms);
}

void UCharacterMovementComponent::CapsuleTouched(struct UPrimitiveComponent* OverlappedComp, struct AActor* Other, struct UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.CapsuleTouched");

	FCapsuleTouched parms{};	
	parms.OverlappedComp = OverlappedComp;
	parms.Other = Other;
	parms.OtherComp = OtherComp;
	parms.OtherBodyIndex = OtherBodyIndex;
	parms.bFromSweep = bFromSweep;
	parms.SweepResult = SweepResult;

	ProcessEvent(fn, &parms);
}

void UCharacterMovementComponent::CalcVelocity(float DeltaTime, float Friction, bool bFluid, float BrakingDeceleration){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.CalcVelocity");

	FCalcVelocity parms{};	
	parms.DeltaTime = DeltaTime;
	parms.Friction = Friction;
	parms.bFluid = bFluid;
	parms.BrakingDeceleration = BrakingDeceleration;

	ProcessEvent(fn, &parms);
}

void UCharacterMovementComponent::AddImpulse(struct FVector Impulse, bool bVelocityChange){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.AddImpulse");

	FAddImpulse parms{};	
	parms.Impulse = Impulse;
	parms.bVelocityChange = bVelocityChange;

	ProcessEvent(fn, &parms);
}

void UCharacterMovementComponent::AddForce(struct FVector Force){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.AddForce");

	FAddForce parms{};	
	parms.Force = Force;

	ProcessEvent(fn, &parms);
}

void USoundWave::SetSoundAssetCompressionType(uint8_t InSoundAssetCompressionType, bool bMarkDirty){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SoundWave.SetSoundAssetCompressionType");

	FSetSoundAssetCompressionType parms{};	
	parms.InSoundAssetCompressionType = InSoundAssetCompressionType;
	parms.bMarkDirty = bMarkDirty;

	ProcessEvent(fn, &parms);
}

uint8_t USoundWave::GetSoundAssetCompressionType(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SoundWave.GetSoundAssetCompressionType");

	FGetSoundAssetCompressionType parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void USceneCaptureComponent2D::RemoveBlendable(struct TScriptInterface<IBlendableInterface> InBlendableObject){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponent2D.RemoveBlendable");

	FRemoveBlendable parms{};	
	parms.InBlendableObject = InBlendableObject;

	ProcessEvent(fn, &parms);
}

void USceneCaptureComponent2D::CaptureScene(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponent2D.CaptureScene");

	FCaptureScene parms{};	

	ProcessEvent(fn, &parms);
}

void USceneCaptureComponent2D::AddOrUpdateBlendable(struct TScriptInterface<IBlendableInterface> InBlendableObject, float InWeight){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponent2D.AddOrUpdateBlendable");

	FAddOrUpdateBlendable parms{};	
	parms.InBlendableObject = InBlendableObject;
	parms.InWeight = InWeight;

	ProcessEvent(fn, &parms);
}

void APlanarReflection::OnInterpToggle(bool bEnable){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlanarReflection.OnInterpToggle");

	FOnInterpToggle parms{};	
	parms.bEnable = bEnable;

	ProcessEvent(fn, &parms);
}

void AController::UnPossess(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Controller.UnPossess");

	FUnPossess parms{};	

	ProcessEvent(fn, &parms);
}

void AController::StopMovement(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Controller.StopMovement");

	FStopMovement parms{};	

	ProcessEvent(fn, &parms);
}

void AController::SetInitialLocationAndRotation(struct FVector& NewLocation, struct FRotator& NewRotation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Controller.SetInitialLocationAndRotation");

	FSetInitialLocationAndRotation parms{};	
	parms.NewLocation = NewLocation;
	parms.NewRotation = NewRotation;

	ProcessEvent(fn, &parms);
}

void AController::SetIgnoreMoveInput(bool bNewMoveInput){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Controller.SetIgnoreMoveInput");

	FSetIgnoreMoveInput parms{};	
	parms.bNewMoveInput = bNewMoveInput;

	ProcessEvent(fn, &parms);
}

void AController::SetIgnoreLookInput(bool bNewLookInput){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Controller.SetIgnoreLookInput");

	FSetIgnoreLookInput parms{};	
	parms.bNewLookInput = bNewLookInput;

	ProcessEvent(fn, &parms);
}

void AController::SetControlRotation(struct FRotator& NewRotation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Controller.SetControlRotation");

	FSetControlRotation parms{};	
	parms.NewRotation = NewRotation;

	ProcessEvent(fn, &parms);
}

void AController::ResetIgnoreMoveInput(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Controller.ResetIgnoreMoveInput");

	FResetIgnoreMoveInput parms{};	

	ProcessEvent(fn, &parms);
}

void AController::ResetIgnoreLookInput(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Controller.ResetIgnoreLookInput");

	FResetIgnoreLookInput parms{};	

	ProcessEvent(fn, &parms);
}

void AController::ResetIgnoreInputFlags(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Controller.ResetIgnoreInputFlags");

	FResetIgnoreInputFlags parms{};	

	ProcessEvent(fn, &parms);
}

void AController::ReceiveUnPossess(struct APawn* UnpossessedPawn){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Controller.ReceiveUnPossess");

	FReceiveUnPossess parms{};	
	parms.UnpossessedPawn = UnpossessedPawn;

	ProcessEvent(fn, &parms);
}

void AController::ReceivePossess(struct APawn* PossessedPawn){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Controller.ReceivePossess");

	FReceivePossess parms{};	
	parms.PossessedPawn = PossessedPawn;

	ProcessEvent(fn, &parms);
}

void AController::ReceiveInstigatedAnyDamage(float Damage, struct UDamageType* DamageType, struct AActor* DamagedActor, struct AActor* DamageCauser){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Controller.ReceiveInstigatedAnyDamage");

	FReceiveInstigatedAnyDamage parms{};	
	parms.Damage = Damage;
	parms.DamageType = DamageType;
	parms.DamagedActor = DamagedActor;
	parms.DamageCauser = DamageCauser;

	ProcessEvent(fn, &parms);
}

void AController::Possess(struct APawn* InPawn){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Controller.Possess");

	FPossess parms{};	
	parms.InPawn = InPawn;

	ProcessEvent(fn, &parms);
}

void AController::OnRep_PlayerState(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Controller.OnRep_PlayerState");

	FOnRep_PlayerState parms{};	

	ProcessEvent(fn, &parms);
}

void AController::OnRep_Pawn(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Controller.OnRep_Pawn");

	FOnRep_Pawn parms{};	

	ProcessEvent(fn, &parms);
}

bool AController::LineOfSightTo(struct AActor* Other, struct FVector ViewPoint, bool bAlternateChecks){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Controller.LineOfSightTo");

	FLineOfSightTo parms{};	
	parms.Other = Other;
	parms.ViewPoint = ViewPoint;
	parms.bAlternateChecks = bAlternateChecks;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct APawn* AController::K2_GetPawn(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Controller.K2_GetPawn");

	FK2_GetPawn parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool AController::IsPlayerController(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Controller.IsPlayerController");

	FIsPlayerController parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool AController::IsMoveInputIgnored(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Controller.IsMoveInputIgnored");

	FIsMoveInputIgnored parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool AController::IsLookInputIgnored(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Controller.IsLookInputIgnored");

	FIsLookInputIgnored parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool AController::IsLocalPlayerController(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Controller.IsLocalPlayerController");

	FIsLocalPlayerController parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool AController::IsLocalController(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Controller.IsLocalController");

	FIsLocalController parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct AActor* AController::GetViewTarget(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Controller.GetViewTarget");

	FGetViewTarget parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void AController::GetPlayerViewPoint(struct FVector& Location, struct FRotator& Rotation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Controller.GetPlayerViewPoint");

	FGetPlayerViewPoint parms{};	
	parms.Location = Location;
	parms.Rotation = Rotation;

	ProcessEvent(fn, &parms);
}

struct FRotator AController::GetDesiredRotation(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Controller.GetDesiredRotation");

	FGetDesiredRotation parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator AController::GetControlRotation(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Controller.GetControlRotation");

	FGetControlRotation parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void AController::ClientSetRotation(struct FRotator NewRotation, bool bResetCamera){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Controller.ClientSetRotation");

	FClientSetRotation parms{};	
	parms.NewRotation = NewRotation;
	parms.bResetCamera = bResetCamera;

	ProcessEvent(fn, &parms);
}

void AController::ClientSetLocation(struct FVector NewLocation, struct FRotator NewRotation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Controller.ClientSetLocation");

	FClientSetLocation parms{};	
	parms.NewLocation = NewLocation;
	parms.NewRotation = NewRotation;

	ProcessEvent(fn, &parms);
}

void ALight::ToggleEnabled(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Light.ToggleEnabled");

	FToggleEnabled parms{};	

	ProcessEvent(fn, &parms);
}

void ALight::SetLightFunctionScale(struct FVector NewLightFunctionScale){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Light.SetLightFunctionScale");

	FSetLightFunctionScale parms{};	
	parms.NewLightFunctionScale = NewLightFunctionScale;

	ProcessEvent(fn, &parms);
}

void ALight::SetLightFunctionMaterial(struct UMaterialInterface* NewLightFunctionMaterial){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Light.SetLightFunctionMaterial");

	FSetLightFunctionMaterial parms{};	
	parms.NewLightFunctionMaterial = NewLightFunctionMaterial;

	ProcessEvent(fn, &parms);
}

void ALight::SetLightFunctionFadeDistance(float NewLightFunctionFadeDistance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Light.SetLightFunctionFadeDistance");

	FSetLightFunctionFadeDistance parms{};	
	parms.NewLightFunctionFadeDistance = NewLightFunctionFadeDistance;

	ProcessEvent(fn, &parms);
}

void ALight::SetLightColor(struct FLinearColor NewLightColor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Light.SetLightColor");

	FSetLightColor parms{};	
	parms.NewLightColor = NewLightColor;

	ProcessEvent(fn, &parms);
}

void ALight::SetEnabled(bool bSetEnabled){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Light.SetEnabled");

	FSetEnabled parms{};	
	parms.bSetEnabled = bSetEnabled;

	ProcessEvent(fn, &parms);
}

void ALight::SetCastShadows(bool bNewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Light.SetCastShadows");

	FSetCastShadows parms{};	
	parms.bNewValue = bNewValue;

	ProcessEvent(fn, &parms);
}

void ALight::SetBrightness(float NewBrightness){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Light.SetBrightness");

	FSetBrightness parms{};	
	parms.NewBrightness = NewBrightness;

	ProcessEvent(fn, &parms);
}

void ALight::SetAffectTranslucentLighting(bool bNewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Light.SetAffectTranslucentLighting");

	FSetAffectTranslucentLighting parms{};	
	parms.bNewValue = bNewValue;

	ProcessEvent(fn, &parms);
}

void ALight::OnRep_bEnabled(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Light.OnRep_bEnabled");

	FOnRep_bEnabled parms{};	

	ProcessEvent(fn, &parms);
}

bool ALight::IsEnabled(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Light.IsEnabled");

	FIsEnabled parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FLinearColor ALight::GetLightColor(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Light.GetLightColor");

	FGetLightColor parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float ALight::GetBrightness(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Light.GetBrightness");

	FGetBrightness parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void AGameStateBase::OnRep_SpectatorClass(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameStateBase.OnRep_SpectatorClass");

	FOnRep_SpectatorClass parms{};	

	ProcessEvent(fn, &parms);
}

void AGameStateBase::OnRep_ReplicatedWorldTimeSeconds(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameStateBase.OnRep_ReplicatedWorldTimeSeconds");

	FOnRep_ReplicatedWorldTimeSeconds parms{};	

	ProcessEvent(fn, &parms);
}

void AGameStateBase::OnRep_ReplicatedHasBegunPlay(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameStateBase.OnRep_ReplicatedHasBegunPlay");

	FOnRep_ReplicatedHasBegunPlay parms{};	

	ProcessEvent(fn, &parms);
}

void AGameStateBase::OnRep_GameModeClass(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameStateBase.OnRep_GameModeClass");

	FOnRep_GameModeClass parms{};	

	ProcessEvent(fn, &parms);
}

bool AGameStateBase::HasMatchStarted(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameStateBase.HasMatchStarted");

	FHasMatchStarted parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool AGameStateBase::HasMatchEnded(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameStateBase.HasMatchEnded");

	FHasMatchEnded parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool AGameStateBase::HasBegunPlay(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameStateBase.HasBegunPlay");

	FHasBegunPlay parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float AGameStateBase::GetServerWorldTimeSeconds(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameStateBase.GetServerWorldTimeSeconds");

	FGetServerWorldTimeSeconds parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float AGameStateBase::GetPlayerStartTime(struct AController* Controller){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameStateBase.GetPlayerStartTime");

	FGetPlayerStartTime parms{};	
	parms.Controller = Controller;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float AGameStateBase::GetPlayerRespawnDelay(struct AController* Controller){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameStateBase.GetPlayerRespawnDelay");

	FGetPlayerRespawnDelay parms{};	
	parms.Controller = Controller;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UGameUserSettings::ValidateSettings(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.ValidateSettings");

	FValidateSettings parms{};	

	ProcessEvent(fn, &parms);
}

bool UGameUserSettings::SupportsHDRDisplayOutput(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SupportsHDRDisplayOutput");

	FSupportsHDRDisplayOutput parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UGameUserSettings::SetVSyncEnabled(bool bEnable){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetVSyncEnabled");

	FSetVSyncEnabled parms{};	
	parms.bEnable = bEnable;

	ProcessEvent(fn, &parms);
}

void UGameUserSettings::SetVisualEffectQuality(int32_t Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetVisualEffectQuality");

	FSetVisualEffectQuality parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UGameUserSettings::SetViewDistanceQuality(int32_t Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetViewDistanceQuality");

	FSetViewDistanceQuality parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UGameUserSettings::SetToDefaults(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetToDefaults");

	FSetToDefaults parms{};	

	ProcessEvent(fn, &parms);
}

void UGameUserSettings::SetTextureQuality(int32_t Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetTextureQuality");

	FSetTextureQuality parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UGameUserSettings::SetShadowQuality(int32_t Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetShadowQuality");

	FSetShadowQuality parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UGameUserSettings::SetShadingQuality(int32_t Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetShadingQuality");

	FSetShadingQuality parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UGameUserSettings::SetScreenResolution(struct FIntPoint Resolution){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetScreenResolution");

	FSetScreenResolution parms{};	
	parms.Resolution = Resolution;

	ProcessEvent(fn, &parms);
}

void UGameUserSettings::SetResolutionScaleValueEx(float NewScaleValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetResolutionScaleValueEx");

	FSetResolutionScaleValueEx parms{};	
	parms.NewScaleValue = NewScaleValue;

	ProcessEvent(fn, &parms);
}

void UGameUserSettings::SetResolutionScaleValue(int32_t NewScaleValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetResolutionScaleValue");

	FSetResolutionScaleValue parms{};	
	parms.NewScaleValue = NewScaleValue;

	ProcessEvent(fn, &parms);
}

void UGameUserSettings::SetResolutionScaleNormalized(float NewScaleNormalized){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetResolutionScaleNormalized");

	FSetResolutionScaleNormalized parms{};	
	parms.NewScaleNormalized = NewScaleNormalized;

	ProcessEvent(fn, &parms);
}

void UGameUserSettings::SetReflectionQuality(int32_t Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetReflectionQuality");

	FSetReflectionQuality parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UGameUserSettings::SetPostProcessingQuality(int32_t Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetPostProcessingQuality");

	FSetPostProcessingQuality parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UGameUserSettings::SetOverallScalabilityLevel(int32_t Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetOverallScalabilityLevel");

	FSetOverallScalabilityLevel parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UGameUserSettings::SetGlobalIlluminationQuality(int32_t Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetGlobalIlluminationQuality");

	FSetGlobalIlluminationQuality parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UGameUserSettings::SetFullscreenMode(enum class EWindowMode InFullscreenMode){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetFullscreenMode");

	FSetFullscreenMode parms{};	
	parms.InFullscreenMode = InFullscreenMode;

	ProcessEvent(fn, &parms);
}

void UGameUserSettings::SetFrameRateLimit(float NewLimit){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetFrameRateLimit");

	FSetFrameRateLimit parms{};	
	parms.NewLimit = NewLimit;

	ProcessEvent(fn, &parms);
}

void UGameUserSettings::SetFoliageQuality(int32_t Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetFoliageQuality");

	FSetFoliageQuality parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UGameUserSettings::SetDynamicResolutionEnabled(bool bEnable){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetDynamicResolutionEnabled");

	FSetDynamicResolutionEnabled parms{};	
	parms.bEnable = bEnable;

	ProcessEvent(fn, &parms);
}

void UGameUserSettings::SetBenchmarkFallbackValues(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetBenchmarkFallbackValues");

	FSetBenchmarkFallbackValues parms{};	

	ProcessEvent(fn, &parms);
}

void UGameUserSettings::SetAudioQualityLevel(int32_t QualityLevel){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetAudioQualityLevel");

	FSetAudioQualityLevel parms{};	
	parms.QualityLevel = QualityLevel;

	ProcessEvent(fn, &parms);
}

void UGameUserSettings::SetAntiAliasingQuality(int32_t Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetAntiAliasingQuality");

	FSetAntiAliasingQuality parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UGameUserSettings::SaveSettings(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SaveSettings");

	FSaveSettings parms{};	

	ProcessEvent(fn, &parms);
}

void UGameUserSettings::RunHardwareBenchmark(int32_t WorkScale, float CPUMultiplier, float GPUMultiplier){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.RunHardwareBenchmark");

	FRunHardwareBenchmark parms{};	
	parms.WorkScale = WorkScale;
	parms.CPUMultiplier = CPUMultiplier;
	parms.GPUMultiplier = GPUMultiplier;

	ProcessEvent(fn, &parms);
}

void UGameUserSettings::RevertVideoMode(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.RevertVideoMode");

	FRevertVideoMode parms{};	

	ProcessEvent(fn, &parms);
}

void UGameUserSettings::ResetToCurrentSettings(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.ResetToCurrentSettings");

	FResetToCurrentSettings parms{};	

	ProcessEvent(fn, &parms);
}

void UGameUserSettings::LoadSettings(bool bForceReload){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.LoadSettings");

	FLoadSettings parms{};	
	parms.bForceReload = bForceReload;

	ProcessEvent(fn, &parms);
}

bool UGameUserSettings::IsVSyncEnabled(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.IsVSyncEnabled");

	FIsVSyncEnabled parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UGameUserSettings::IsVSyncDirty(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.IsVSyncDirty");

	FIsVSyncDirty parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UGameUserSettings::IsScreenResolutionDirty(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.IsScreenResolutionDirty");

	FIsScreenResolutionDirty parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UGameUserSettings::IsHDREnabled(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.IsHDREnabled");

	FIsHDREnabled parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UGameUserSettings::IsFullscreenModeDirty(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.IsFullscreenModeDirty");

	FIsFullscreenModeDirty parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UGameUserSettings::IsDynamicResolutionEnabled(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.IsDynamicResolutionEnabled");

	FIsDynamicResolutionEnabled parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UGameUserSettings::IsDynamicResolutionDirty(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.IsDynamicResolutionDirty");

	FIsDynamicResolutionDirty parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UGameUserSettings::IsDirty(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.IsDirty");

	FIsDirty parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UGameUserSettings::GetVisualEffectQuality(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetVisualEffectQuality");

	FGetVisualEffectQuality parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UGameUserSettings::GetViewDistanceQuality(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetViewDistanceQuality");

	FGetViewDistanceQuality parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UGameUserSettings::GetTextureQuality(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetTextureQuality");

	FGetTextureQuality parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UGameUserSettings::GetSyncInterval(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetSyncInterval");

	FGetSyncInterval parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UGameUserSettings::GetShadowQuality(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetShadowQuality");

	FGetShadowQuality parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UGameUserSettings::GetShadingQuality(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetShadingQuality");

	FGetShadingQuality parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FIntPoint UGameUserSettings::GetScreenResolution(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetScreenResolution");

	FGetScreenResolution parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UGameUserSettings::GetResolutionScaleNormalized(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetResolutionScaleNormalized");

	FGetResolutionScaleNormalized parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UGameUserSettings::GetResolutionScaleInformationEx(float& CurrentScaleNormalized, float& CurrentScaleValue, float& MinScaleValue, float& MaxScaleValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetResolutionScaleInformationEx");

	FGetResolutionScaleInformationEx parms{};	
	parms.CurrentScaleNormalized = CurrentScaleNormalized;
	parms.CurrentScaleValue = CurrentScaleValue;
	parms.MinScaleValue = MinScaleValue;
	parms.MaxScaleValue = MaxScaleValue;

	ProcessEvent(fn, &parms);
}

void UGameUserSettings::GetResolutionScaleInformation(float& CurrentScaleNormalized, int32_t& CurrentScaleValue, int32_t& MinScaleValue, int32_t& MaxScaleValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetResolutionScaleInformation");

	FGetResolutionScaleInformation parms{};	
	parms.CurrentScaleNormalized = CurrentScaleNormalized;
	parms.CurrentScaleValue = CurrentScaleValue;
	parms.MinScaleValue = MinScaleValue;
	parms.MaxScaleValue = MaxScaleValue;

	ProcessEvent(fn, &parms);
}

int32_t UGameUserSettings::GetReflectionQuality(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetReflectionQuality");

	FGetReflectionQuality parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UGameUserSettings::GetRecommendedResolutionScale(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetRecommendedResolutionScale");

	FGetRecommendedResolutionScale parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

enum class EWindowMode UGameUserSettings::GetPreferredFullscreenMode(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetPreferredFullscreenMode");

	FGetPreferredFullscreenMode parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UGameUserSettings::GetPostProcessingQuality(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetPostProcessingQuality");

	FGetPostProcessingQuality parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UGameUserSettings::GetOverallScalabilityLevel(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetOverallScalabilityLevel");

	FGetOverallScalabilityLevel parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FIntPoint UGameUserSettings::GetLastConfirmedScreenResolution(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetLastConfirmedScreenResolution");

	FGetLastConfirmedScreenResolution parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

enum class EWindowMode UGameUserSettings::GetLastConfirmedFullscreenMode(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetLastConfirmedFullscreenMode");

	FGetLastConfirmedFullscreenMode parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UGameUserSettings::GetGlobalIlluminationQuality(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetGlobalIlluminationQuality");

	FGetGlobalIlluminationQuality parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UGameUserSettings* UGameUserSettings::GetGameUserSettings(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetGameUserSettings");

	FGetGameUserSettings parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

enum class EWindowMode UGameUserSettings::GetFullscreenMode(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetFullscreenMode");

	FGetFullscreenMode parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UGameUserSettings::GetFrameRateLimit(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetFrameRateLimit");

	FGetFrameRateLimit parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UGameUserSettings::GetFramePace(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetFramePace");

	FGetFramePace parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UGameUserSettings::GetFoliageQuality(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetFoliageQuality");

	FGetFoliageQuality parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FIntPoint UGameUserSettings::GetDesktopResolution(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetDesktopResolution");

	FGetDesktopResolution parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FIntPoint UGameUserSettings::GetDefaultWindowPosition(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetDefaultWindowPosition");

	FGetDefaultWindowPosition parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

enum class EWindowMode UGameUserSettings::GetDefaultWindowMode(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetDefaultWindowMode");

	FGetDefaultWindowMode parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UGameUserSettings::GetDefaultResolutionScale(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetDefaultResolutionScale");

	FGetDefaultResolutionScale parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FIntPoint UGameUserSettings::GetDefaultResolution(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetDefaultResolution");

	FGetDefaultResolution parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UGameUserSettings::GetCurrentHDRDisplayNits(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetCurrentHDRDisplayNits");

	FGetCurrentHDRDisplayNits parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UGameUserSettings::GetAudioQualityLevel(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetAudioQualityLevel");

	FGetAudioQualityLevel parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UGameUserSettings::GetAntiAliasingQuality(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetAntiAliasingQuality");

	FGetAntiAliasingQuality parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UGameUserSettings::EnableHDRDisplayOutput(bool bEnable, int32_t DisplayNits){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.EnableHDRDisplayOutput");

	FEnableHDRDisplayOutput parms{};	
	parms.bEnable = bEnable;
	parms.DisplayNits = DisplayNits;

	ProcessEvent(fn, &parms);
}

void UGameUserSettings::ConfirmVideoMode(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.ConfirmVideoMode");

	FConfirmVideoMode parms{};	

	ProcessEvent(fn, &parms);
}

void UGameUserSettings::ApplySettings(bool bCheckForCommandLineOverrides){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.ApplySettings");

	FApplySettings parms{};	
	parms.bCheckForCommandLineOverrides = bCheckForCommandLineOverrides;

	ProcessEvent(fn, &parms);
}

void UGameUserSettings::ApplyResolutionSettings(bool bCheckForCommandLineOverrides){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.ApplyResolutionSettings");

	FApplyResolutionSettings parms{};	
	parms.bCheckForCommandLineOverrides = bCheckForCommandLineOverrides;

	ProcessEvent(fn, &parms);
}

void UGameUserSettings::ApplyNonResolutionSettings(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.ApplyNonResolutionSettings");

	FApplyNonResolutionSettings parms{};	

	ProcessEvent(fn, &parms);
}

void UGameUserSettings::ApplyHardwareBenchmarkResults(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameUserSettings.ApplyHardwareBenchmarkResults");

	FApplyHardwareBenchmarkResults parms{};	

	ProcessEvent(fn, &parms);
}

bool APlayerController::WasInputKeyJustReleased(struct FKey Key){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.WasInputKeyJustReleased");

	FWasInputKeyJustReleased parms{};	
	parms.Key = Key;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool APlayerController::WasInputKeyJustPressed(struct FKey Key){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.WasInputKeyJustPressed");

	FWasInputKeyJustPressed parms{};	
	parms.Key = Key;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void APlayerController::ToggleSpeaking(bool bInSpeaking){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ToggleSpeaking");

	FToggleSpeaking parms{};	
	parms.bInSpeaking = bInSpeaking;

	ProcessEvent(fn, &parms);
}

void APlayerController::TestServerLevelVisibilityChange(struct FName PackageName, struct FName Filename){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.TestServerLevelVisibilityChange");

	FTestServerLevelVisibilityChange parms{};	
	parms.PackageName = PackageName;
	parms.Filename = Filename;

	ProcessEvent(fn, &parms);
}

void APlayerController::SwitchLevel(struct FString URL){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.SwitchLevel");

	FSwitchLevel parms{};	
	parms.URL = URL;

	ProcessEvent(fn, &parms);
}

bool APlayerController::StreamingSourceShouldBlockOnSlowStreaming(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.StreamingSourceShouldBlockOnSlowStreaming");

	FStreamingSourceShouldBlockOnSlowStreaming parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool APlayerController::StreamingSourceShouldActivate(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.StreamingSourceShouldActivate");

	FStreamingSourceShouldActivate parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void APlayerController::StopHapticEffect(uint8_t Hand){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.StopHapticEffect");

	FStopHapticEffect parms{};	
	parms.Hand = Hand;

	ProcessEvent(fn, &parms);
}

void APlayerController::StartFire(char FireModeNum){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.StartFire");

	FStartFire parms{};	
	parms.FireModeNum = FireModeNum;

	ProcessEvent(fn, &parms);
}

void APlayerController::SetVirtualJoystickVisibility(bool bVisible){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.SetVirtualJoystickVisibility");

	FSetVirtualJoystickVisibility parms{};	
	parms.bVisible = bVisible;

	ProcessEvent(fn, &parms);
}

void APlayerController::SetViewTargetWithBlend(struct AActor* NewViewTarget, float BlendTime, enum class EViewTargetBlendFunction BlendFunc, float BlendExp, bool bLockOutgoing){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.SetViewTargetWithBlend");

	FSetViewTargetWithBlend parms{};	
	parms.NewViewTarget = NewViewTarget;
	parms.BlendTime = BlendTime;
	parms.BlendFunc = BlendFunc;
	parms.BlendExp = BlendExp;
	parms.bLockOutgoing = bLockOutgoing;

	ProcessEvent(fn, &parms);
}

void APlayerController::SetName(struct FString S){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.SetName");

	FSetName parms{};	
	parms.S = S;

	ProcessEvent(fn, &parms);
}

void APlayerController::SetMouseLocation(int32_t X, int32_t Y){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.SetMouseLocation");

	FSetMouseLocation parms{};	
	parms.X = X;
	parms.Y = Y;

	ProcessEvent(fn, &parms);
}

void APlayerController::SetMouseCursorWidget(enum class EMouseCursor Cursor, struct UUserWidget* CursorWidget){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.SetMouseCursorWidget");

	FSetMouseCursorWidget parms{};	
	parms.Cursor = Cursor;
	parms.CursorWidget = CursorWidget;

	ProcessEvent(fn, &parms);
}

void APlayerController::SetMotionControlsEnabled(bool bEnabled){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.SetMotionControlsEnabled");

	FSetMotionControlsEnabled parms{};	
	parms.bEnabled = bEnabled;

	ProcessEvent(fn, &parms);
}

void APlayerController::SetHapticsByValue(float Frequency, float Amplitude, uint8_t Hand){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.SetHapticsByValue");

	FSetHapticsByValue parms{};	
	parms.Frequency = Frequency;
	parms.Amplitude = Amplitude;
	parms.Hand = Hand;

	ProcessEvent(fn, &parms);
}

void APlayerController::SetDisableHaptics(bool bNewDisabled){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.SetDisableHaptics");

	FSetDisableHaptics parms{};	
	parms.bNewDisabled = bNewDisabled;

	ProcessEvent(fn, &parms);
}

void APlayerController::SetDeprecatedInputYawScale(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.SetDeprecatedInputYawScale");

	FSetDeprecatedInputYawScale parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void APlayerController::SetDeprecatedInputRollScale(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.SetDeprecatedInputRollScale");

	FSetDeprecatedInputRollScale parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void APlayerController::SetDeprecatedInputPitchScale(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.SetDeprecatedInputPitchScale");

	FSetDeprecatedInputPitchScale parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void APlayerController::SetControllerLightColor(struct FColor Color){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.SetControllerLightColor");

	FSetControllerLightColor parms{};	
	parms.Color = Color;

	ProcessEvent(fn, &parms);
}

void APlayerController::SetCinematicMode(bool bInCinematicMode, bool bHidePlayer, bool bAffectsHUD, bool bAffectsMovement, bool bAffectsTurning){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.SetCinematicMode");

	FSetCinematicMode parms{};	
	parms.bInCinematicMode = bInCinematicMode;
	parms.bHidePlayer = bHidePlayer;
	parms.bAffectsHUD = bAffectsHUD;
	parms.bAffectsMovement = bAffectsMovement;
	parms.bAffectsTurning = bAffectsTurning;

	ProcessEvent(fn, &parms);
}

void APlayerController::SetAudioListenerOverride(struct USceneComponent* AttachToComponent, struct FVector Location, struct FRotator Rotation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.SetAudioListenerOverride");

	FSetAudioListenerOverride parms{};	
	parms.AttachToComponent = AttachToComponent;
	parms.Location = Location;
	parms.Rotation = Rotation;

	ProcessEvent(fn, &parms);
}

void APlayerController::SetAudioListenerAttenuationOverride(struct USceneComponent* AttachToComponent, struct FVector AttenuationLocationOVerride){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.SetAudioListenerAttenuationOverride");

	FSetAudioListenerAttenuationOverride parms{};	
	parms.AttachToComponent = AttachToComponent;
	parms.AttenuationLocationOVerride = AttenuationLocationOVerride;

	ProcessEvent(fn, &parms);
}

void APlayerController::ServerViewSelf(struct FViewTargetTransitionParams TransitionParams){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerViewSelf");

	FServerViewSelf parms{};	
	parms.TransitionParams = TransitionParams;

	ProcessEvent(fn, &parms);
}

void APlayerController::ServerViewPrevPlayer(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerViewPrevPlayer");

	FServerViewPrevPlayer parms{};	

	ProcessEvent(fn, &parms);
}

void APlayerController::ServerViewNextPlayer(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerViewNextPlayer");

	FServerViewNextPlayer parms{};	

	ProcessEvent(fn, &parms);
}

void APlayerController::ServerVerifyViewTarget(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerVerifyViewTarget");

	FServerVerifyViewTarget parms{};	

	ProcessEvent(fn, &parms);
}

void APlayerController::ServerUpdateMultipleLevelsVisibility(struct TArray<struct FUpdateLevelVisibilityLevelInfo> LevelVisibilities){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerUpdateMultipleLevelsVisibility");

	FServerUpdateMultipleLevelsVisibility parms{};	
	parms.LevelVisibilities = LevelVisibilities;

	ProcessEvent(fn, &parms);
}

void APlayerController::ServerUpdateLevelVisibility(struct FUpdateLevelVisibilityLevelInfo LevelVisibility){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerUpdateLevelVisibility");

	FServerUpdateLevelVisibility parms{};	
	parms.LevelVisibility = LevelVisibility;

	ProcessEvent(fn, &parms);
}

void APlayerController::ServerUpdateCamera(struct FVector_NetQuantize CamLoc, int32_t CamPitchAndYaw){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerUpdateCamera");

	FServerUpdateCamera parms{};	
	parms.CamLoc = CamLoc;
	parms.CamPitchAndYaw = CamPitchAndYaw;

	ProcessEvent(fn, &parms);
}

void APlayerController::ServerUnmutePlayer(struct FUniqueNetIdRepl PlayerId){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerUnmutePlayer");

	FServerUnmutePlayer parms{};	
	parms.PlayerId = PlayerId;

	ProcessEvent(fn, &parms);
}

void APlayerController::ServerUnblockPlayer(struct FUniqueNetIdRepl PlayerId){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerUnblockPlayer");

	FServerUnblockPlayer parms{};	
	parms.PlayerId = PlayerId;

	ProcessEvent(fn, &parms);
}

void APlayerController::ServerToggleAILogging(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerToggleAILogging");

	FServerToggleAILogging parms{};	

	ProcessEvent(fn, &parms);
}

void APlayerController::ServerShortTimeout(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerShortTimeout");

	FServerShortTimeout parms{};	

	ProcessEvent(fn, &parms);
}

void APlayerController::ServerSetSpectatorWaiting(bool bWaiting){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerSetSpectatorWaiting");

	FServerSetSpectatorWaiting parms{};	
	parms.bWaiting = bWaiting;

	ProcessEvent(fn, &parms);
}

void APlayerController::ServerSetSpectatorLocation(struct FVector NewLoc, struct FRotator NewRot){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerSetSpectatorLocation");

	FServerSetSpectatorLocation parms{};	
	parms.NewLoc = NewLoc;
	parms.NewRot = NewRot;

	ProcessEvent(fn, &parms);
}

void APlayerController::ServerSendLatestAsyncPhysicsTimestamp(struct FAsyncPhysicsTimestamp Timestamp){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerSendLatestAsyncPhysicsTimestamp");

	FServerSendLatestAsyncPhysicsTimestamp parms{};	
	parms.Timestamp = Timestamp;

	ProcessEvent(fn, &parms);
}

void APlayerController::ServerRestartPlayer(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerRestartPlayer");

	FServerRestartPlayer parms{};	

	ProcessEvent(fn, &parms);
}

void APlayerController::ServerRecvClientInputFrame(int32_t RecvClientInputFrame, struct TArray<char> Data){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerRecvClientInputFrame");

	FServerRecvClientInputFrame parms{};	
	parms.RecvClientInputFrame = RecvClientInputFrame;
	parms.Data = Data;

	ProcessEvent(fn, &parms);
}

void APlayerController::ServerPause(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerPause");

	FServerPause parms{};	

	ProcessEvent(fn, &parms);
}

void APlayerController::ServerNotifyLoadedWorld(struct FName WorldPackageName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerNotifyLoadedWorld");

	FServerNotifyLoadedWorld parms{};	
	parms.WorldPackageName = WorldPackageName;

	ProcessEvent(fn, &parms);
}

void APlayerController::ServerMutePlayer(struct FUniqueNetIdRepl PlayerId){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerMutePlayer");

	FServerMutePlayer parms{};	
	parms.PlayerId = PlayerId;

	ProcessEvent(fn, &parms);
}

void APlayerController::ServerExecRPC(struct FString Msg){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerExecRPC");

	FServerExecRPC parms{};	
	parms.Msg = Msg;

	ProcessEvent(fn, &parms);
}

void APlayerController::ServerExec(struct FString Msg){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerExec");

	FServerExec parms{};	
	parms.Msg = Msg;

	ProcessEvent(fn, &parms);
}

void APlayerController::ServerCheckClientPossessionReliable(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerCheckClientPossessionReliable");

	FServerCheckClientPossessionReliable parms{};	

	ProcessEvent(fn, &parms);
}

void APlayerController::ServerCheckClientPossession(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerCheckClientPossession");

	FServerCheckClientPossession parms{};	

	ProcessEvent(fn, &parms);
}

void APlayerController::ServerChangeName(struct FString S){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerChangeName");

	FServerChangeName parms{};	
	parms.S = S;

	ProcessEvent(fn, &parms);
}

void APlayerController::ServerCamera(struct FName NewMode){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerCamera");

	FServerCamera parms{};	
	parms.NewMode = NewMode;

	ProcessEvent(fn, &parms);
}

void APlayerController::ServerBlockPlayer(struct FUniqueNetIdRepl PlayerId){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerBlockPlayer");

	FServerBlockPlayer parms{};	
	parms.PlayerId = PlayerId;

	ProcessEvent(fn, &parms);
}

void APlayerController::ServerAcknowledgePossession(struct APawn* P){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerAcknowledgePossession");

	FServerAcknowledgePossession parms{};	
	parms.P = P;

	ProcessEvent(fn, &parms);
}

void APlayerController::SendToConsole(struct FString Command){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.SendToConsole");

	FSendToConsole parms{};	
	parms.Command = Command;

	ProcessEvent(fn, &parms);
}

void APlayerController::RestartLevel(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.RestartLevel");

	FRestartLevel parms{};	

	ProcessEvent(fn, &parms);
}

void APlayerController::ResetControllerLightColor(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ResetControllerLightColor");

	FResetControllerLightColor parms{};	

	ProcessEvent(fn, &parms);
}

bool APlayerController::ProjectWorldLocationToScreen(struct FVector WorldLocation, struct FVector2D& ScreenLocation, bool bPlayerViewportRelative){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ProjectWorldLocationToScreen");

	FProjectWorldLocationToScreen parms{};	
	parms.WorldLocation = WorldLocation;
	parms.ScreenLocation = ScreenLocation;
	parms.bPlayerViewportRelative = bPlayerViewportRelative;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void APlayerController::PlayHapticEffect(struct UHapticFeedbackEffect_Base* HapticEffect, uint8_t Hand, float Scale, bool bLoop){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.PlayHapticEffect");

	FPlayHapticEffect parms{};	
	parms.HapticEffect = HapticEffect;
	parms.Hand = Hand;
	parms.Scale = Scale;
	parms.bLoop = bLoop;

	ProcessEvent(fn, &parms);
}

void APlayerController::PlayDynamicForceFeedback(float Intensity, float Duration, bool bAffectsLeftLarge, bool bAffectsLeftSmall, bool bAffectsRightLarge, bool bAffectsRightSmall, enum class EDynamicForceFeedbackAction Action, struct FLatentActionInfo LatentInfo){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.PlayDynamicForceFeedback");

	FPlayDynamicForceFeedback parms{};	
	parms.Intensity = Intensity;
	parms.Duration = Duration;
	parms.bAffectsLeftLarge = bAffectsLeftLarge;
	parms.bAffectsLeftSmall = bAffectsLeftSmall;
	parms.bAffectsRightLarge = bAffectsRightLarge;
	parms.bAffectsRightSmall = bAffectsRightSmall;
	parms.Action = Action;
	parms.LatentInfo = LatentInfo;

	ProcessEvent(fn, &parms);
}

void APlayerController::Pause(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.Pause");

	FPause parms{};	

	ProcessEvent(fn, &parms);
}

void APlayerController::OnServerStartedVisualLogger(bool bIsLogging){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.OnServerStartedVisualLogger");

	FOnServerStartedVisualLogger parms{};	
	parms.bIsLogging = bIsLogging;

	ProcessEvent(fn, &parms);
}

void APlayerController::OnRep_AsyncPhysicsDataComponent(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.OnRep_AsyncPhysicsDataComponent");

	FOnRep_AsyncPhysicsDataComponent parms{};	

	ProcessEvent(fn, &parms);
}

void APlayerController::LocalTravel(struct FString URL){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.LocalTravel");

	FLocalTravel parms{};	
	parms.URL = URL;

	ProcessEvent(fn, &parms);
}

void APlayerController::K2_ClientPlayForceFeedback(struct UForceFeedbackEffect* ForceFeedbackEffect, struct FName Tag, bool bLooping, bool bIgnoreTimeDilation, bool bPlayWhilePaused){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.K2_ClientPlayForceFeedback");

	FK2_ClientPlayForceFeedback parms{};	
	parms.ForceFeedbackEffect = ForceFeedbackEffect;
	parms.Tag = Tag;
	parms.bLooping = bLooping;
	parms.bIgnoreTimeDilation = bIgnoreTimeDilation;
	parms.bPlayWhilePaused = bPlayWhilePaused;

	ProcessEvent(fn, &parms);
}

bool APlayerController::IsStreamingSourceEnabled(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.IsStreamingSourceEnabled");

	FIsStreamingSourceEnabled parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool APlayerController::IsInputKeyDown(struct FKey Key){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.IsInputKeyDown");

	FIsInputKeyDown parms{};	
	parms.Key = Key;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void APlayerController::GetViewportSize(int32_t& SizeX, int32_t& SizeY){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.GetViewportSize");

	FGetViewportSize parms{};	
	parms.SizeX = SizeX;
	parms.SizeY = SizeY;

	ProcessEvent(fn, &parms);
}

void APlayerController::GetStreamingSourceShapes(struct TArray<struct FStreamingSourceShape>& OutShapes){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.GetStreamingSourceShapes");

	FGetStreamingSourceShapes parms{};	
	parms.OutShapes = OutShapes;

	ProcessEvent(fn, &parms);
}

uint8_t APlayerController::GetStreamingSourcePriority(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.GetStreamingSourcePriority");

	FGetStreamingSourcePriority parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void APlayerController::GetStreamingSourceLocationAndRotation(struct FVector& OutLocation, struct FRotator& OutRotation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.GetStreamingSourceLocationAndRotation");

	FGetStreamingSourceLocationAndRotation parms{};	
	parms.OutLocation = OutLocation;
	parms.OutRotation = OutRotation;

	ProcessEvent(fn, &parms);
}

struct ASpectatorPawn* APlayerController::GetSpectatorPawn(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.GetSpectatorPawn");

	FGetSpectatorPawn parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FPlatformUserId APlayerController::GetPlatformUserId(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.GetPlatformUserId");

	FGetPlatformUserId parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

UPlayerInput* APlayerController::GetOverridePlayerInputClass(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.GetOverridePlayerInputClass");

	FGetOverridePlayerInputClass parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool APlayerController::GetMousePosition(float& LocationX, float& LocationY){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.GetMousePosition");

	FGetMousePosition parms{};	
	parms.LocationX = LocationX;
	parms.LocationY = LocationY;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector APlayerController::GetInputVectorKeyState(struct FKey Key){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.GetInputVectorKeyState");

	FGetInputVectorKeyState parms{};	
	parms.Key = Key;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void APlayerController::GetInputTouchState(enum class ETouchIndex FingerIndex, float& LocationX, float& LocationY, bool& bIsCurrentlyPressed){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.GetInputTouchState");

	FGetInputTouchState parms{};	
	parms.FingerIndex = FingerIndex;
	parms.LocationX = LocationX;
	parms.LocationY = LocationY;
	parms.bIsCurrentlyPressed = bIsCurrentlyPressed;

	ProcessEvent(fn, &parms);
}

void APlayerController::GetInputMouseDelta(float& DeltaX, float& DeltaY){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.GetInputMouseDelta");

	FGetInputMouseDelta parms{};	
	parms.DeltaX = DeltaX;
	parms.DeltaY = DeltaY;

	ProcessEvent(fn, &parms);
}

void APlayerController::GetInputMotionState(struct FVector& Tilt, struct FVector& RotationRate, struct FVector& Gravity, struct FVector& Acceleration){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.GetInputMotionState");

	FGetInputMotionState parms{};	
	parms.Tilt = Tilt;
	parms.RotationRate = RotationRate;
	parms.Gravity = Gravity;
	parms.Acceleration = Acceleration;

	ProcessEvent(fn, &parms);
}

float APlayerController::GetInputKeyTimeDown(struct FKey Key){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.GetInputKeyTimeDown");

	FGetInputKeyTimeDown parms{};	
	parms.Key = Key;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void APlayerController::GetInputAnalogStickState(enum class EControllerAnalogStick WhichStick, float& StickX, float& StickY){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.GetInputAnalogStickState");

	FGetInputAnalogStickState parms{};	
	parms.WhichStick = WhichStick;
	parms.StickX = StickX;
	parms.StickY = StickY;

	ProcessEvent(fn, &parms);
}

float APlayerController::GetInputAnalogKeyState(struct FKey Key){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.GetInputAnalogKeyState");

	FGetInputAnalogKeyState parms{};	
	parms.Key = Key;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct AHUD* APlayerController::GetHUD(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.GetHUD");

	FGetHUD parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool APlayerController::GetHitResultUnderFingerForObjects(enum class ETouchIndex FingerIndex, struct TArray<enum class EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, struct FHitResult& HitResult){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.GetHitResultUnderFingerForObjects");

	FGetHitResultUnderFingerForObjects parms{};	
	parms.FingerIndex = FingerIndex;
	parms.ObjectTypes = ObjectTypes;
	parms.bTraceComplex = bTraceComplex;
	parms.HitResult = HitResult;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool APlayerController::GetHitResultUnderFingerByChannel(enum class ETouchIndex FingerIndex, enum class ETraceTypeQuery TraceChannel, bool bTraceComplex, struct FHitResult& HitResult){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.GetHitResultUnderFingerByChannel");

	FGetHitResultUnderFingerByChannel parms{};	
	parms.FingerIndex = FingerIndex;
	parms.TraceChannel = TraceChannel;
	parms.bTraceComplex = bTraceComplex;
	parms.HitResult = HitResult;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool APlayerController::GetHitResultUnderFinger(enum class ETouchIndex FingerIndex, enum class ECollisionChannel TraceChannel, bool bTraceComplex, struct FHitResult& HitResult){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.GetHitResultUnderFinger");

	FGetHitResultUnderFinger parms{};	
	parms.FingerIndex = FingerIndex;
	parms.TraceChannel = TraceChannel;
	parms.bTraceComplex = bTraceComplex;
	parms.HitResult = HitResult;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool APlayerController::GetHitResultUnderCursorForObjects(struct TArray<enum class EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, struct FHitResult& HitResult){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.GetHitResultUnderCursorForObjects");

	FGetHitResultUnderCursorForObjects parms{};	
	parms.ObjectTypes = ObjectTypes;
	parms.bTraceComplex = bTraceComplex;
	parms.HitResult = HitResult;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool APlayerController::GetHitResultUnderCursorByChannel(enum class ETraceTypeQuery TraceChannel, bool bTraceComplex, struct FHitResult& HitResult){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.GetHitResultUnderCursorByChannel");

	FGetHitResultUnderCursorByChannel parms{};	
	parms.TraceChannel = TraceChannel;
	parms.bTraceComplex = bTraceComplex;
	parms.HitResult = HitResult;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool APlayerController::GetHitResultUnderCursor(enum class ECollisionChannel TraceChannel, bool bTraceComplex, struct FHitResult& HitResult){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.GetHitResultUnderCursor");

	FGetHitResultUnderCursor parms{};	
	parms.TraceChannel = TraceChannel;
	parms.bTraceComplex = bTraceComplex;
	parms.HitResult = HitResult;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector APlayerController::GetFocalLocation(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.GetFocalLocation");

	FGetFocalLocation parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float APlayerController::GetDeprecatedInputYawScale(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.GetDeprecatedInputYawScale");

	FGetDeprecatedInputYawScale parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float APlayerController::GetDeprecatedInputRollScale(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.GetDeprecatedInputRollScale");

	FGetDeprecatedInputRollScale parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float APlayerController::GetDeprecatedInputPitchScale(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.GetDeprecatedInputPitchScale");

	FGetDeprecatedInputPitchScale parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UAsyncPhysicsData* APlayerController::GetAsyncPhysicsDataToWrite(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.GetAsyncPhysicsDataToWrite");

	FGetAsyncPhysicsDataToWrite parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UAsyncPhysicsData* APlayerController::GetAsyncPhysicsDataToConsume(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.GetAsyncPhysicsDataToConsume");

	FGetAsyncPhysicsDataToConsume parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void APlayerController::FOV(float NewFOV){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.FOV");

	FFOV parms{};	
	parms.NewFOV = NewFOV;

	ProcessEvent(fn, &parms);
}

void APlayerController::EnableCheats(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.EnableCheats");

	FEnableCheats parms{};	

	ProcessEvent(fn, &parms);
}

bool APlayerController::DeprojectScreenPositionToWorld(float ScreenX, float ScreenY, struct FVector& WorldLocation, struct FVector& WorldDirection){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.DeprojectScreenPositionToWorld");

	FDeprojectScreenPositionToWorld parms{};	
	parms.ScreenX = ScreenX;
	parms.ScreenY = ScreenY;
	parms.WorldLocation = WorldLocation;
	parms.WorldDirection = WorldDirection;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool APlayerController::DeprojectMousePositionToWorld(struct FVector& WorldLocation, struct FVector& WorldDirection){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.DeprojectMousePositionToWorld");

	FDeprojectMousePositionToWorld parms{};	
	parms.WorldLocation = WorldLocation;
	parms.WorldDirection = WorldDirection;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void APlayerController::ConsoleKey(struct FKey Key){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ConsoleKey");

	FConsoleKey parms{};	
	parms.Key = Key;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientWasKicked(struct FText KickReason){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientWasKicked");

	FClientWasKicked parms{};	
	parms.KickReason = KickReason;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientVoiceHandshakeComplete(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientVoiceHandshakeComplete");

	FClientVoiceHandshakeComplete parms{};	

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientUpdateMultipleLevelsStreamingStatus(struct TArray<struct FUpdateLevelStreamingLevelStatus> LevelStatuses){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientUpdateMultipleLevelsStreamingStatus");

	FClientUpdateMultipleLevelsStreamingStatus parms{};	
	parms.LevelStatuses = LevelStatuses;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientUpdateLevelStreamingStatus(struct FName PackageName, bool bNewShouldBeLoaded, bool bNewShouldBeVisible, bool bNewShouldBlockOnLoad, int32_t LODIndex, struct FNetLevelVisibilityTransactionId TransactionId){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientUpdateLevelStreamingStatus");

	FClientUpdateLevelStreamingStatus parms{};	
	parms.PackageName = PackageName;
	parms.bNewShouldBeLoaded = bNewShouldBeLoaded;
	parms.bNewShouldBeVisible = bNewShouldBeVisible;
	parms.bNewShouldBlockOnLoad = bNewShouldBlockOnLoad;
	parms.LODIndex = LODIndex;
	parms.TransactionId = TransactionId;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientUnmutePlayers(struct TArray<struct FUniqueNetIdRepl> PlayerIds){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientUnmutePlayers");

	FClientUnmutePlayers parms{};	
	parms.PlayerIds = PlayerIds;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientUnmutePlayer(struct FUniqueNetIdRepl PlayerId){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientUnmutePlayer");

	FClientUnmutePlayer parms{};	
	parms.PlayerId = PlayerId;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientTravelInternal(struct FString URL, enum class ETravelType TravelType, bool bSeamless, struct FGuid MapPackageGuid){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientTravelInternal");

	FClientTravelInternal parms{};	
	parms.URL = URL;
	parms.TravelType = TravelType;
	parms.bSeamless = bSeamless;
	parms.MapPackageGuid = MapPackageGuid;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientTravel(struct FString URL, enum class ETravelType TravelType, bool bSeamless, struct FGuid MapPackageGuid){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientTravel");

	FClientTravel parms{};	
	parms.URL = URL;
	parms.TravelType = TravelType;
	parms.bSeamless = bSeamless;
	parms.MapPackageGuid = MapPackageGuid;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientTeamMessage(struct APlayerState* SenderPlayerState, struct FString S, struct FName Type, float MsgLifeTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientTeamMessage");

	FClientTeamMessage parms{};	
	parms.SenderPlayerState = SenderPlayerState;
	parms.S = S;
	parms.Type = Type;
	parms.MsgLifeTime = MsgLifeTime;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientStopForceFeedback(struct UForceFeedbackEffect* ForceFeedbackEffect, struct FName Tag){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientStopForceFeedback");

	FClientStopForceFeedback parms{};	
	parms.ForceFeedbackEffect = ForceFeedbackEffect;
	parms.Tag = Tag;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientStopCameraShakesFromSource(struct UCameraShakeSourceComponent* SourceComponent, bool bImmediately){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientStopCameraShakesFromSource");

	FClientStopCameraShakesFromSource parms{};	
	parms.SourceComponent = SourceComponent;
	parms.bImmediately = bImmediately;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientStopCameraShake(UCameraShakeBase* Shake, bool bImmediately){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientStopCameraShake");

	FClientStopCameraShake parms{};	
	parms.Shake = Shake;
	parms.bImmediately = bImmediately;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientStartOnlineSession(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientStartOnlineSession");

	FClientStartOnlineSession parms{};	

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientStartCameraShakeFromSource(UCameraShakeBase* Shake, struct UCameraShakeSourceComponent* SourceComponent){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientStartCameraShakeFromSource");

	FClientStartCameraShakeFromSource parms{};	
	parms.Shake = Shake;
	parms.SourceComponent = SourceComponent;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientStartCameraShake(UCameraShakeBase* Shake, float Scale, uint8_t PlaySpace, struct FRotator UserPlaySpaceRot){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientStartCameraShake");

	FClientStartCameraShake parms{};	
	parms.Shake = Shake;
	parms.Scale = Scale;
	parms.PlaySpace = PlaySpace;
	parms.UserPlaySpaceRot = UserPlaySpaceRot;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientSpawnGenericCameraLensEffect(AActor* LensEffectEmitterClass){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSpawnGenericCameraLensEffect");

	FClientSpawnGenericCameraLensEffect parms{};	
	parms.LensEffectEmitterClass = LensEffectEmitterClass;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientSpawnCameraLensEffect(AEmitterCameraLensEffectBase* LensEffectEmitterClass){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSpawnCameraLensEffect");

	FClientSpawnCameraLensEffect parms{};	
	parms.LensEffectEmitterClass = LensEffectEmitterClass;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientSetViewTarget(struct AActor* A, struct FViewTargetTransitionParams TransitionParams){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSetViewTarget");

	FClientSetViewTarget parms{};	
	parms.A = A;
	parms.TransitionParams = TransitionParams;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientSetSpectatorWaiting(bool bWaiting){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSetSpectatorWaiting");

	FClientSetSpectatorWaiting parms{};	
	parms.bWaiting = bWaiting;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientSetHUD(AHUD* NewHUDClass){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSetHUD");

	FClientSetHUD parms{};	
	parms.NewHUDClass = NewHUDClass;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientSetForceMipLevelsToBeResident(struct UMaterialInterface* Material, float ForceDuration, int32_t CinematicTextureGroups){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSetForceMipLevelsToBeResident");

	FClientSetForceMipLevelsToBeResident parms{};	
	parms.Material = Material;
	parms.ForceDuration = ForceDuration;
	parms.CinematicTextureGroups = CinematicTextureGroups;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientSetCinematicMode(bool bInCinematicMode, bool bAffectsMovement, bool bAffectsTurning, bool bAffectsHUD){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSetCinematicMode");

	FClientSetCinematicMode parms{};	
	parms.bInCinematicMode = bInCinematicMode;
	parms.bAffectsMovement = bAffectsMovement;
	parms.bAffectsTurning = bAffectsTurning;
	parms.bAffectsHUD = bAffectsHUD;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientSetCameraMode(struct FName NewCamMode){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSetCameraMode");

	FClientSetCameraMode parms{};	
	parms.NewCamMode = NewCamMode;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientSetCameraFade(bool bEnableFading, struct FColor FadeColor, struct FVector2D FadeAlpha, float FadeTime, bool bFadeAudio, bool bHoldWhenFinished){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSetCameraFade");

	FClientSetCameraFade parms{};	
	parms.bEnableFading = bEnableFading;
	parms.FadeColor = FadeColor;
	parms.FadeAlpha = FadeAlpha;
	parms.FadeTime = FadeTime;
	parms.bFadeAudio = bFadeAudio;
	parms.bHoldWhenFinished = bHoldWhenFinished;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientSetBlockOnAsyncLoading(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSetBlockOnAsyncLoading");

	FClientSetBlockOnAsyncLoading parms{};	

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientReturnToMainMenuWithTextReason(struct FText ReturnReason){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientReturnToMainMenuWithTextReason");

	FClientReturnToMainMenuWithTextReason parms{};	
	parms.ReturnReason = ReturnReason;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientReturnToMainMenu(struct FString ReturnReason){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientReturnToMainMenu");

	FClientReturnToMainMenu parms{};	
	parms.ReturnReason = ReturnReason;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientRetryClientRestart(struct APawn* NewPawn){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientRetryClientRestart");

	FClientRetryClientRestart parms{};	
	parms.NewPawn = NewPawn;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientRestart(struct APawn* NewPawn){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientRestart");

	FClientRestart parms{};	
	parms.NewPawn = NewPawn;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientReset(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientReset");

	FClientReset parms{};	

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientRepObjRef(struct UObject* Object){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientRepObjRef");

	FClientRepObjRef parms{};	
	parms.Object = Object;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientRecvServerAckFrameDebug(char NumBuffered, float TargetNumBufferedCmds){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientRecvServerAckFrameDebug");

	FClientRecvServerAckFrameDebug parms{};	
	parms.NumBuffered = NumBuffered;
	parms.TargetNumBufferedCmds = TargetNumBufferedCmds;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientRecvServerAckFrame(int32_t LastProcessedInputFrame, int32_t RecvServerFrameNumber, int8_t TimeDilation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientRecvServerAckFrame");

	FClientRecvServerAckFrame parms{};	
	parms.LastProcessedInputFrame = LastProcessedInputFrame;
	parms.RecvServerFrameNumber = RecvServerFrameNumber;
	parms.TimeDilation = TimeDilation;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientReceiveLocalizedMessage(ULocalMessage* Message, int32_t SWITCH, struct APlayerState* RelatedPlayerState_2, struct APlayerState* RelatedPlayerState_3, struct UObject* OptionalObject){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientReceiveLocalizedMessage");

	FClientReceiveLocalizedMessage parms{};	
	parms.Message = Message;
	parms.SWITCH = SWITCH;
	parms.RelatedPlayerState_2 = RelatedPlayerState_2;
	parms.RelatedPlayerState_3 = RelatedPlayerState_3;
	parms.OptionalObject = OptionalObject;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientPrestreamTextures(struct AActor* ForcedActor, float ForceDuration, bool bEnableStreaming, int32_t CinematicTextureGroups){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientPrestreamTextures");

	FClientPrestreamTextures parms{};	
	parms.ForcedActor = ForcedActor;
	parms.ForceDuration = ForceDuration;
	parms.bEnableStreaming = bEnableStreaming;
	parms.CinematicTextureGroups = CinematicTextureGroups;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientPrepareMapChange(struct FName LevelName, bool bFirst, bool bLast){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientPrepareMapChange");

	FClientPrepareMapChange parms{};	
	parms.LevelName = LevelName;
	parms.bFirst = bFirst;
	parms.bLast = bLast;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientPlaySoundAtLocation(struct USoundBase* Sound, struct FVector Location, float VolumeMultiplier, float PitchMultiplier){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientPlaySoundAtLocation");

	FClientPlaySoundAtLocation parms{};	
	parms.Sound = Sound;
	parms.Location = Location;
	parms.VolumeMultiplier = VolumeMultiplier;
	parms.PitchMultiplier = PitchMultiplier;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientPlaySound(struct USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientPlaySound");

	FClientPlaySound parms{};	
	parms.Sound = Sound;
	parms.VolumeMultiplier = VolumeMultiplier;
	parms.PitchMultiplier = PitchMultiplier;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientPlayForceFeedback_Internal(struct UForceFeedbackEffect* ForceFeedbackEffect, struct FForceFeedbackParameters Params){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientPlayForceFeedback_Internal");

	FClientPlayForceFeedback_Internal parms{};	
	parms.ForceFeedbackEffect = ForceFeedbackEffect;
	parms.Params = Params;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientMutePlayer(struct FUniqueNetIdRepl PlayerId){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientMutePlayer");

	FClientMutePlayer parms{};	
	parms.PlayerId = PlayerId;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientMessage(struct FString S, struct FName Type, float MsgLifeTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientMessage");

	FClientMessage parms{};	
	parms.S = S;
	parms.Type = Type;
	parms.MsgLifeTime = MsgLifeTime;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientIgnoreMoveInput(bool bIgnore){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientIgnoreMoveInput");

	FClientIgnoreMoveInput parms{};	
	parms.bIgnore = bIgnore;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientIgnoreLookInput(bool bIgnore){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientIgnoreLookInput");

	FClientIgnoreLookInput parms{};	
	parms.bIgnore = bIgnore;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientGotoState(struct FName NewState){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientGotoState");

	FClientGotoState parms{};	
	parms.NewState = NewState;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientGameEnded(struct AActor* EndGameFocus, bool bIsWinner){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientGameEnded");

	FClientGameEnded parms{};	
	parms.EndGameFocus = EndGameFocus;
	parms.bIsWinner = bIsWinner;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientForceGarbageCollection(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientForceGarbageCollection");

	FClientForceGarbageCollection parms{};	

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientFlushLevelStreaming(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientFlushLevelStreaming");

	FClientFlushLevelStreaming parms{};	

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientEndOnlineSession(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientEndOnlineSession");

	FClientEndOnlineSession parms{};	

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientEnableNetworkVoice(bool bEnable){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientEnableNetworkVoice");

	FClientEnableNetworkVoice parms{};	
	parms.bEnable = bEnable;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientCorrectionAsyncPhysicsTimestamp(struct FAsyncPhysicsTimestamp Timestamp){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientCorrectionAsyncPhysicsTimestamp");

	FClientCorrectionAsyncPhysicsTimestamp parms{};	
	parms.Timestamp = Timestamp;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientCommitMapChange(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientCommitMapChange");

	FClientCommitMapChange parms{};	

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientClearCameraLensEffects(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientClearCameraLensEffects");

	FClientClearCameraLensEffects parms{};	

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientCapBandwidth(int32_t Cap){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientCapBandwidth");

	FClientCapBandwidth parms{};	
	parms.Cap = Cap;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientCancelPendingMapChange(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientCancelPendingMapChange");

	FClientCancelPendingMapChange parms{};	

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientAddTextureStreamingLoc(struct FVector InLoc, float Duration, bool bOverrideLocation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientAddTextureStreamingLoc");

	FClientAddTextureStreamingLoc parms{};	
	parms.InLoc = InLoc;
	parms.Duration = Duration;
	parms.bOverrideLocation = bOverrideLocation;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientAckUpdateLevelVisibility(struct FName PackageName, struct FNetLevelVisibilityTransactionId TransactionId, bool bClientAckCanMakeVisible){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientAckUpdateLevelVisibility");

	FClientAckUpdateLevelVisibility parms{};	
	parms.PackageName = PackageName;
	parms.TransactionId = TransactionId;
	parms.bClientAckCanMakeVisible = bClientAckCanMakeVisible;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClientAckTimeDilation(float TimeDilation, int32_t ServerStep){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientAckTimeDilation");

	FClientAckTimeDilation parms{};	
	parms.TimeDilation = TimeDilation;
	parms.ServerStep = ServerStep;

	ProcessEvent(fn, &parms);
}

void APlayerController::ClearAudioListenerOverride(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClearAudioListenerOverride");

	FClearAudioListenerOverride parms{};	

	ProcessEvent(fn, &parms);
}

void APlayerController::ClearAudioListenerAttenuationOverride(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ClearAudioListenerAttenuationOverride");

	FClearAudioListenerAttenuationOverride parms{};	

	ProcessEvent(fn, &parms);
}

bool APlayerController::CanRestartPlayer(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.CanRestartPlayer");

	FCanRestartPlayer parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void APlayerController::Camera(struct FName NewMode){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.Camera");

	FCamera parms{};	
	parms.NewMode = NewMode;

	ProcessEvent(fn, &parms);
}

void APlayerController::AddYawInput(float Val){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.AddYawInput");

	FAddYawInput parms{};	
	parms.Val = Val;

	ProcessEvent(fn, &parms);
}

void APlayerController::AddRollInput(float Val){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.AddRollInput");

	FAddRollInput parms{};	
	parms.Val = Val;

	ProcessEvent(fn, &parms);
}

void APlayerController::AddPitchInput(float Val){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.AddPitchInput");

	FAddPitchInput parms{};	
	parms.Val = Val;

	ProcessEvent(fn, &parms);
}

void APlayerController::ActivateTouchInterface(struct UTouchInterface* NewTouchInterface){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerController.ActivateTouchInterface");

	FActivateTouchInterface parms{};	
	parms.NewTouchInterface = NewTouchInterface;

	ProcessEvent(fn, &parms);
}

void APlayerState::ReceiveOverrideWith(struct APlayerState* OldPlayerState){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerState.ReceiveOverrideWith");

	FReceiveOverrideWith parms{};	
	parms.OldPlayerState = OldPlayerState;

	ProcessEvent(fn, &parms);
}

void APlayerState::ReceiveCopyProperties(struct APlayerState* NewPlayerState){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerState.ReceiveCopyProperties");

	FReceiveCopyProperties parms{};	
	parms.NewPlayerState = NewPlayerState;

	ProcessEvent(fn, &parms);
}

void APlayerState::OnRep_UniqueId(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerState.OnRep_UniqueId");

	FOnRep_UniqueId parms{};	

	ProcessEvent(fn, &parms);
}

void APlayerState::OnRep_Score(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerState.OnRep_Score");

	FOnRep_Score parms{};	

	ProcessEvent(fn, &parms);
}

void APlayerState::OnRep_PlayerName(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerState.OnRep_PlayerName");

	FOnRep_PlayerName parms{};	

	ProcessEvent(fn, &parms);
}

void APlayerState::OnRep_PlayerId(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerState.OnRep_PlayerId");

	FOnRep_PlayerId parms{};	

	ProcessEvent(fn, &parms);
}

void APlayerState::OnRep_bIsInactive(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerState.OnRep_bIsInactive");

	FOnRep_bIsInactive parms{};	

	ProcessEvent(fn, &parms);
}

void APlayerState::OnPawnPrivateDestroyed(struct AActor* InActor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerState.OnPawnPrivateDestroyed");

	FOnPawnPrivateDestroyed parms{};	
	parms.InActor = InActor;

	ProcessEvent(fn, &parms);
}

bool APlayerState::IsSpectator(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerState.IsSpectator");

	FIsSpectator parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool APlayerState::IsOnlyASpectator(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerState.IsOnlyASpectator");

	FIsOnlyASpectator parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool APlayerState::IsABot(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerState.IsABot");

	FIsABot parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float APlayerState::GetScore(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerState.GetScore");

	FGetScore parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString APlayerState::GetPlayerName(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerState.GetPlayerName");

	FGetPlayerName parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t APlayerState::GetPlayerId(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerState.GetPlayerId");

	FGetPlayerId parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct APlayerController* APlayerState::GetPlayerController(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerState.GetPlayerController");

	FGetPlayerController parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float APlayerState::GetPingInMilliseconds(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerState.GetPingInMilliseconds");

	FGetPingInMilliseconds parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct APawn* APlayerState::GetPawn(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerState.GetPawn");

	FGetPawn parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

char APlayerState::GetCompressedPing(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerState.GetCompressedPing");

	FGetCompressedPing parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FUniqueNetIdRepl APlayerState::BP_GetUniqueId(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerState.BP_GetUniqueId");

	FBP_GetUniqueId parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void AGameMode::StartMatch(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameMode.StartMatch");

	FStartMatch parms{};	

	ProcessEvent(fn, &parms);
}

void AGameMode::Say(struct FString Msg){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameMode.Say");

	FSay parms{};	
	parms.Msg = Msg;

	ProcessEvent(fn, &parms);
}

void AGameMode::RestartGame(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameMode.RestartGame");

	FRestartGame parms{};	

	ProcessEvent(fn, &parms);
}

bool AGameMode::ReadyToStartMatch(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameMode.ReadyToStartMatch");

	FReadyToStartMatch parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool AGameMode::ReadyToEndMatch(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameMode.ReadyToEndMatch");

	FReadyToEndMatch parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void AGameMode::K2_OnSetMatchState(struct FName NewState){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameMode.K2_OnSetMatchState");

	FK2_OnSetMatchState parms{};	
	parms.NewState = NewState;

	ProcessEvent(fn, &parms);
}

bool AGameMode::IsMatchInProgress(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameMode.IsMatchInProgress");

	FIsMatchInProgress parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FName AGameMode::GetMatchState(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameMode.GetMatchState");

	FGetMatchState parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void AGameMode::EndMatch(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameMode.EndMatch");

	FEndMatch parms{};	

	ProcessEvent(fn, &parms);
}

void AGameMode::AbortMatch(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameMode.AbortMatch");

	FAbortMatch parms{};	

	ProcessEvent(fn, &parms);
}

void AGameState::OnRep_MatchState(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameState.OnRep_MatchState");

	FOnRep_MatchState parms{};	

	ProcessEvent(fn, &parms);
}

void AGameState::OnRep_ElapsedTime(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameState.OnRep_ElapsedTime");

	FOnRep_ElapsedTime parms{};	

	ProcessEvent(fn, &parms);
}

void ASkyLight::OnRep_bEnabled(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkyLight.OnRep_bEnabled");

	FOnRep_bEnabled parms{};	

	ProcessEvent(fn, &parms);
}

void UStreamableRenderAsset::SetForceMipLevelsToBeResident(float Seconds, int32_t CinematicLODGroupMask){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StreamableRenderAsset.SetForceMipLevelsToBeResident");

	FSetForceMipLevelsToBeResident parms{};	
	parms.Seconds = Seconds;
	parms.CinematicLODGroupMask = CinematicLODGroupMask;

	ProcessEvent(fn, &parms);
}

bool UStaticMeshComponent::SetStaticMesh(struct UStaticMesh* NewMesh){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StaticMeshComponent.SetStaticMesh");

	FSetStaticMesh parms{};	
	parms.NewMesh = NewMesh;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UStaticMeshComponent::SetReverseCulling(bool ReverseCulling){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StaticMeshComponent.SetReverseCulling");

	FSetReverseCulling parms{};	
	parms.ReverseCulling = ReverseCulling;

	ProcessEvent(fn, &parms);
}

void UStaticMeshComponent::SetForcedLodModel(int32_t NewForcedLodModel){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StaticMeshComponent.SetForcedLodModel");

	FSetForcedLodModel parms{};	
	parms.NewForcedLodModel = NewForcedLodModel;

	ProcessEvent(fn, &parms);
}

void UStaticMeshComponent::SetEvaluateWorldPositionOffsetInRayTracing(bool NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StaticMeshComponent.SetEvaluateWorldPositionOffsetInRayTracing");

	FSetEvaluateWorldPositionOffsetInRayTracing parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UStaticMeshComponent::SetEvaluateWorldPositionOffset(bool NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StaticMeshComponent.SetEvaluateWorldPositionOffset");

	FSetEvaluateWorldPositionOffset parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UStaticMeshComponent::SetDistanceFieldSelfShadowBias(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StaticMeshComponent.SetDistanceFieldSelfShadowBias");

	FSetDistanceFieldSelfShadowBias parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UStaticMeshComponent::OnRep_StaticMesh(struct UStaticMesh* OldStaticMesh){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StaticMeshComponent.OnRep_StaticMesh");

	FOnRep_StaticMesh parms{};	
	parms.OldStaticMesh = OldStaticMesh;

	ProcessEvent(fn, &parms);
}

void UStaticMeshComponent::GetLocalBounds(struct FVector& Min, struct FVector& Max){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StaticMeshComponent.GetLocalBounds");

	FGetLocalBounds parms{};	
	parms.Min = Min;
	parms.Max = Max;

	ProcessEvent(fn, &parms);
}

bool UStaticMeshComponent::GetInitialEvaluateWorldPositionOffset(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StaticMeshComponent.GetInitialEvaluateWorldPositionOffset");

	FGetInitialEvaluateWorldPositionOffset parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UCheatManagerExtension::RemovedFromCheatManager(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManagerExtension.RemovedFromCheatManager");

	FRemovedFromCheatManager parms{};	

	ProcessEvent(fn, &parms);
}

struct APlayerController* UCheatManagerExtension::GetPlayerController(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManagerExtension.GetPlayerController");

	FGetPlayerController parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UCheatManagerExtension::AddedToCheatManager(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManagerExtension.AddedToCheatManager");

	FAddedToCheatManager parms{};	

	ProcessEvent(fn, &parms);
}

struct TArray<struct FName> UMaterialParameterCollection::GetVectorParameterNames(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MaterialParameterCollection.GetVectorParameterNames");

	FGetVectorParameterNames parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FLinearColor UMaterialParameterCollection::GetVectorParameterDefaultValue(struct FName ParameterName, bool& bParameterFound){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MaterialParameterCollection.GetVectorParameterDefaultValue");

	FGetVectorParameterDefaultValue parms{};	
	parms.ParameterName = ParameterName;
	parms.bParameterFound = bParameterFound;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<struct FName> UMaterialParameterCollection::GetScalarParameterNames(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MaterialParameterCollection.GetScalarParameterNames");

	FGetScalarParameterNames parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UMaterialParameterCollection::GetScalarParameterDefaultValue(struct FName ParameterName, bool& bParameterFound){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MaterialParameterCollection.GetScalarParameterDefaultValue");

	FGetScalarParameterDefaultValue parms{};	
	parms.ParameterName = ParameterName;
	parms.bParameterFound = bParameterFound;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UInstancedStaticMeshComponent::UpdateInstanceTransform(int32_t InstanceIndex, struct FTransform& NewInstanceTransform, bool bWorldSpace, bool bMarkRenderStateDirty, bool bTeleport){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.UpdateInstanceTransform");

	FUpdateInstanceTransform parms{};	
	parms.InstanceIndex = InstanceIndex;
	parms.NewInstanceTransform = NewInstanceTransform;
	parms.bWorldSpace = bWorldSpace;
	parms.bMarkRenderStateDirty = bMarkRenderStateDirty;
	parms.bTeleport = bTeleport;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UInstancedStaticMeshComponent::SetCustomDataValue(int32_t InstanceIndex, int32_t CustomDataIndex, float CustomDataValue, bool bMarkRenderStateDirty){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.SetCustomDataValue");

	FSetCustomDataValue parms{};	
	parms.InstanceIndex = InstanceIndex;
	parms.CustomDataIndex = CustomDataIndex;
	parms.CustomDataValue = CustomDataValue;
	parms.bMarkRenderStateDirty = bMarkRenderStateDirty;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UInstancedStaticMeshComponent::SetCullDistances(int32_t StartCullDistance, int32_t EndCullDistance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.SetCullDistances");

	FSetCullDistances parms{};	
	parms.StartCullDistance = StartCullDistance;
	parms.EndCullDistance = EndCullDistance;

	ProcessEvent(fn, &parms);
}

bool UInstancedStaticMeshComponent::RemoveInstances(struct TArray<int32_t>& InstancesToRemove){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.RemoveInstances");

	FRemoveInstances parms{};	
	parms.InstancesToRemove = InstancesToRemove;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UInstancedStaticMeshComponent::RemoveInstance(int32_t InstanceIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.RemoveInstance");

	FRemoveInstance parms{};	
	parms.InstanceIndex = InstanceIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UInstancedStaticMeshComponent::IsValidInstance(int32_t InstanceIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.IsValidInstance");

	FIsValidInstance parms{};	
	parms.InstanceIndex = InstanceIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UInstancedStaticMeshComponent::GetInstanceTransform(int32_t InstanceIndex, struct FTransform& OutInstanceTransform, bool bWorldSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.GetInstanceTransform");

	FGetInstanceTransform parms{};	
	parms.InstanceIndex = InstanceIndex;
	parms.OutInstanceTransform = OutInstanceTransform;
	parms.bWorldSpace = bWorldSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<int32_t> UInstancedStaticMeshComponent::GetInstancesOverlappingSphere(struct FVector& Center, float Radius, bool bSphereInWorldSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.GetInstancesOverlappingSphere");

	FGetInstancesOverlappingSphere parms{};	
	parms.Center = Center;
	parms.Radius = Radius;
	parms.bSphereInWorldSpace = bSphereInWorldSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<int32_t> UInstancedStaticMeshComponent::GetInstancesOverlappingBox(struct FBox& Box, bool bBoxInWorldSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.GetInstancesOverlappingBox");

	FGetInstancesOverlappingBox parms{};	
	parms.Box = Box;
	parms.bBoxInWorldSpace = bBoxInWorldSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UInstancedStaticMeshComponent::GetInstanceCount(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.GetInstanceCount");

	FGetInstanceCount parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UInstancedStaticMeshComponent::ClearInstances(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.ClearInstances");

	FClearInstances parms{};	

	ProcessEvent(fn, &parms);
}

bool UInstancedStaticMeshComponent::BatchUpdateInstancesTransforms(int32_t StartInstanceIndex, struct TArray<struct FTransform>& NewInstancesTransforms, bool bWorldSpace, bool bMarkRenderStateDirty, bool bTeleport){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.BatchUpdateInstancesTransforms");

	FBatchUpdateInstancesTransforms parms{};	
	parms.StartInstanceIndex = StartInstanceIndex;
	parms.NewInstancesTransforms = NewInstancesTransforms;
	parms.bWorldSpace = bWorldSpace;
	parms.bMarkRenderStateDirty = bMarkRenderStateDirty;
	parms.bTeleport = bTeleport;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UInstancedStaticMeshComponent::BatchUpdateInstancesTransform(int32_t StartInstanceIndex, int32_t NumInstances, struct FTransform& NewInstancesTransform, bool bWorldSpace, bool bMarkRenderStateDirty, bool bTeleport){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.BatchUpdateInstancesTransform");

	FBatchUpdateInstancesTransform parms{};	
	parms.StartInstanceIndex = StartInstanceIndex;
	parms.NumInstances = NumInstances;
	parms.NewInstancesTransform = NewInstancesTransform;
	parms.bWorldSpace = bWorldSpace;
	parms.bMarkRenderStateDirty = bMarkRenderStateDirty;
	parms.bTeleport = bTeleport;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UInstancedStaticMeshComponent::AddInstanceWorldSpace(struct FTransform& WorldTransform){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.AddInstanceWorldSpace");

	FAddInstanceWorldSpace parms{};	
	parms.WorldTransform = WorldTransform;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<int32_t> UInstancedStaticMeshComponent::AddInstances(struct TArray<struct FTransform>& InstanceTransforms, bool bShouldReturnIndices, bool bWorldSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.AddInstances");

	FAddInstances parms{};	
	parms.InstanceTransforms = InstanceTransforms;
	parms.bShouldReturnIndices = bShouldReturnIndices;
	parms.bWorldSpace = bWorldSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UInstancedStaticMeshComponent::AddInstance(struct FTransform& InstanceTransform, bool bWorldSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.AddInstance");

	FAddInstance parms{};	
	parms.InstanceTransform = InstanceTransform;
	parms.bWorldSpace = bWorldSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void AStaticMeshActor::SetMobility(enum class EComponentMobility InMobility){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StaticMeshActor.SetMobility");

	FSetMobility parms{};	
	parms.InMobility = InMobility;

	ProcessEvent(fn, &parms);
}

struct UAsyncActionLoadPrimaryAsset* UAsyncActionLoadPrimaryAsset::AsyncLoadPrimaryAsset(struct UObject* WorldContextObject, struct FPrimaryAssetId PrimaryAsset, struct TArray<struct FName>& LoadBundles){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AsyncActionLoadPrimaryAsset.AsyncLoadPrimaryAsset");

	FAsyncLoadPrimaryAsset parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.PrimaryAsset = PrimaryAsset;
	parms.LoadBundles = LoadBundles;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UAnimationDataController::UpdateCurveNamesFromSkeleton(struct USkeleton* Skeleton, uint8_t SupportedCurveType, bool bShouldTransact){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationDataController.UpdateCurveNamesFromSkeleton");

	FUpdateCurveNamesFromSkeleton parms{};	
	parms.Skeleton = Skeleton;
	parms.SupportedCurveType = SupportedCurveType;
	parms.bShouldTransact = bShouldTransact;

	ProcessEvent(fn, &parms);
}

bool UAnimationDataController::SetTransformCurveKeys(struct FAnimationCurveIdentifier& CurveId, struct TArray<struct FTransform>& TransformValues, struct TArray<float>& TimeKeys, bool bShouldTransact){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationDataController.SetTransformCurveKeys");

	FSetTransformCurveKeys parms{};	
	parms.CurveId = CurveId;
	parms.TransformValues = TransformValues;
	parms.TimeKeys = TimeKeys;
	parms.bShouldTransact = bShouldTransact;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimationDataController::SetTransformCurveKey(struct FAnimationCurveIdentifier& CurveId, float Time, struct FTransform& Value, bool bShouldTransact){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationDataController.SetTransformCurveKey");

	FSetTransformCurveKey parms{};	
	parms.CurveId = CurveId;
	parms.Time = Time;
	parms.Value = Value;
	parms.bShouldTransact = bShouldTransact;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UAnimationDataController::SetPlayLength(float Length, bool bShouldTransact){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationDataController.SetPlayLength");

	FSetPlayLength parms{};	
	parms.Length = Length;
	parms.bShouldTransact = bShouldTransact;

	ProcessEvent(fn, &parms);
}

void UAnimationDataController::SetModel(struct UAnimDataModel* InModel){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationDataController.SetModel");

	FSetModel parms{};	
	parms.InModel = InModel;

	ProcessEvent(fn, &parms);
}

void UAnimationDataController::SetFrameRate(struct FFrameRate FrameRate, bool bShouldTransact){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationDataController.SetFrameRate");

	FSetFrameRate parms{};	
	parms.FrameRate = FrameRate;
	parms.bShouldTransact = bShouldTransact;

	ProcessEvent(fn, &parms);
}

bool UAnimationDataController::SetCurveKeys(struct FAnimationCurveIdentifier& CurveId, struct TArray<struct FRichCurveKey>& CurveKeys, bool bShouldTransact){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationDataController.SetCurveKeys");

	FSetCurveKeys parms{};	
	parms.CurveId = CurveId;
	parms.CurveKeys = CurveKeys;
	parms.bShouldTransact = bShouldTransact;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimationDataController::SetCurveKey(struct FAnimationCurveIdentifier& CurveId, struct FRichCurveKey& Key, bool bShouldTransact){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationDataController.SetCurveKey");

	FSetCurveKey parms{};	
	parms.CurveId = CurveId;
	parms.Key = Key;
	parms.bShouldTransact = bShouldTransact;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimationDataController::SetCurveFlags(struct FAnimationCurveIdentifier& CurveId, int32_t Flags, bool bShouldTransact){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationDataController.SetCurveFlags");

	FSetCurveFlags parms{};	
	parms.CurveId = CurveId;
	parms.Flags = Flags;
	parms.bShouldTransact = bShouldTransact;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimationDataController::SetCurveFlag(struct FAnimationCurveIdentifier& CurveId, enum class EAnimAssetCurveFlags Flag, bool bState, bool bShouldTransact){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationDataController.SetCurveFlag");

	FSetCurveFlag parms{};	
	parms.CurveId = CurveId;
	parms.Flag = Flag;
	parms.bState = bState;
	parms.bShouldTransact = bShouldTransact;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimationDataController::SetCurveColor(struct FAnimationCurveIdentifier& CurveId, struct FLinearColor Color, bool bShouldTransact){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationDataController.SetCurveColor");

	FSetCurveColor parms{};	
	parms.CurveId = CurveId;
	parms.Color = Color;
	parms.bShouldTransact = bShouldTransact;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimationDataController::SetBoneTrackKeys(struct FName BoneName, struct TArray<struct FVector>& PositionalKeys, struct TArray<struct FQuat>& RotationalKeys, struct TArray<struct FVector>& ScalingKeys, bool bShouldTransact){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationDataController.SetBoneTrackKeys");

	FSetBoneTrackKeys parms{};	
	parms.BoneName = BoneName;
	parms.PositionalKeys = PositionalKeys;
	parms.RotationalKeys = RotationalKeys;
	parms.ScalingKeys = ScalingKeys;
	parms.bShouldTransact = bShouldTransact;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimationDataController::ScaleCurve(struct FAnimationCurveIdentifier& CurveId, float Origin, float Factor, bool bShouldTransact){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationDataController.ScaleCurve");

	FScaleCurve parms{};	
	parms.CurveId = CurveId;
	parms.Origin = Origin;
	parms.Factor = Factor;
	parms.bShouldTransact = bShouldTransact;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UAnimationDataController::ResizePlayLength(float NewLength, float T0, float T1, bool bShouldTransact){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationDataController.ResizePlayLength");

	FResizePlayLength parms{};	
	parms.NewLength = NewLength;
	parms.T0 = T0;
	parms.T1 = T1;
	parms.bShouldTransact = bShouldTransact;

	ProcessEvent(fn, &parms);
}

void UAnimationDataController::Resize(float Length, float T0, float T1, bool bShouldTransact){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationDataController.Resize");

	FResize parms{};	
	parms.Length = Length;
	parms.T0 = T0;
	parms.T1 = T1;
	parms.bShouldTransact = bShouldTransact;

	ProcessEvent(fn, &parms);
}

bool UAnimationDataController::RenameCurve(struct FAnimationCurveIdentifier& CurveToRenameId, struct FAnimationCurveIdentifier& NewCurveId, bool bShouldTransact){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationDataController.RenameCurve");

	FRenameCurve parms{};	
	parms.CurveToRenameId = CurveToRenameId;
	parms.NewCurveId = NewCurveId;
	parms.bShouldTransact = bShouldTransact;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimationDataController::RemoveTransformCurveKey(struct FAnimationCurveIdentifier& CurveId, float Time, bool bShouldTransact){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationDataController.RemoveTransformCurveKey");

	FRemoveTransformCurveKey parms{};	
	parms.CurveId = CurveId;
	parms.Time = Time;
	parms.bShouldTransact = bShouldTransact;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimationDataController::RemoveCurveKey(struct FAnimationCurveIdentifier& CurveId, float Time, bool bShouldTransact){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationDataController.RemoveCurveKey");

	FRemoveCurveKey parms{};	
	parms.CurveId = CurveId;
	parms.Time = Time;
	parms.bShouldTransact = bShouldTransact;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimationDataController::RemoveCurve(struct FAnimationCurveIdentifier& CurveId, bool bShouldTransact){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationDataController.RemoveCurve");

	FRemoveCurve parms{};	
	parms.CurveId = CurveId;
	parms.bShouldTransact = bShouldTransact;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimationDataController::RemoveBoneTrack(struct FName BoneName, bool bShouldTransact){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationDataController.RemoveBoneTrack");

	FRemoveBoneTrack parms{};	
	parms.BoneName = BoneName;
	parms.bShouldTransact = bShouldTransact;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimationDataController::RemoveAttributeKey(struct FAnimationAttributeIdentifier& AttributeIdentifier, float Time, bool bShouldTransact){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationDataController.RemoveAttributeKey");

	FRemoveAttributeKey parms{};	
	parms.AttributeIdentifier = AttributeIdentifier;
	parms.Time = Time;
	parms.bShouldTransact = bShouldTransact;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimationDataController::RemoveAttribute(struct FAnimationAttributeIdentifier& AttributeIdentifier, bool bShouldTransact){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationDataController.RemoveAttribute");

	FRemoveAttribute parms{};	
	parms.AttributeIdentifier = AttributeIdentifier;
	parms.bShouldTransact = bShouldTransact;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UAnimationDataController::RemoveAllCurvesOfType(uint8_t SupportedCurveType, bool bShouldTransact){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationDataController.RemoveAllCurvesOfType");

	FRemoveAllCurvesOfType parms{};	
	parms.SupportedCurveType = SupportedCurveType;
	parms.bShouldTransact = bShouldTransact;

	ProcessEvent(fn, &parms);
}

void UAnimationDataController::RemoveAllBoneTracks(bool bShouldTransact){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationDataController.RemoveAllBoneTracks");

	FRemoveAllBoneTracks parms{};	
	parms.bShouldTransact = bShouldTransact;

	ProcessEvent(fn, &parms);
}

int32_t UAnimationDataController::RemoveAllAttributesForBone(struct FName& BoneName, bool bShouldTransact){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationDataController.RemoveAllAttributesForBone");

	FRemoveAllAttributesForBone parms{};	
	parms.BoneName = BoneName;
	parms.bShouldTransact = bShouldTransact;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UAnimationDataController::RemoveAllAttributes(bool bShouldTransact){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationDataController.RemoveAllAttributes");

	FRemoveAllAttributes parms{};	
	parms.bShouldTransact = bShouldTransact;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UAnimationDataController::OpenBracket(struct FText& InTitle, bool bShouldTransact){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationDataController.OpenBracket");

	FOpenBracket parms{};	
	parms.InTitle = InTitle;
	parms.bShouldTransact = bShouldTransact;

	ProcessEvent(fn, &parms);
}

int32_t UAnimationDataController::InsertBoneTrack(struct FName BoneName, int32_t DesiredIndex, bool bShouldTransact){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationDataController.InsertBoneTrack");

	FInsertBoneTrack parms{};	
	parms.BoneName = BoneName;
	parms.DesiredIndex = DesiredIndex;
	parms.bShouldTransact = bShouldTransact;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UAnimDataModel* UAnimationDataController::GetModel(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationDataController.GetModel");

	FGetModel parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UAnimationDataController::FindOrAddCurveNamesOnSkeleton(struct USkeleton* Skeleton, uint8_t SupportedCurveType, bool bShouldTransact){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationDataController.FindOrAddCurveNamesOnSkeleton");

	FFindOrAddCurveNamesOnSkeleton parms{};	
	parms.Skeleton = Skeleton;
	parms.SupportedCurveType = SupportedCurveType;
	parms.bShouldTransact = bShouldTransact;

	ProcessEvent(fn, &parms);
}

bool UAnimationDataController::DuplicateCurve(struct FAnimationCurveIdentifier& CopyCurveId, struct FAnimationCurveIdentifier& NewCurveId, bool bShouldTransact){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationDataController.DuplicateCurve");

	FDuplicateCurve parms{};	
	parms.CopyCurveId = CopyCurveId;
	parms.NewCurveId = NewCurveId;
	parms.bShouldTransact = bShouldTransact;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimationDataController::DuplicateAttribute(struct FAnimationAttributeIdentifier& AttributeIdentifier, struct FAnimationAttributeIdentifier& NewAttributeIdentifier, bool bShouldTransact){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationDataController.DuplicateAttribute");

	FDuplicateAttribute parms{};	
	parms.AttributeIdentifier = AttributeIdentifier;
	parms.NewAttributeIdentifier = NewAttributeIdentifier;
	parms.bShouldTransact = bShouldTransact;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UAnimationDataController::CloseBracket(bool bShouldTransact){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationDataController.CloseBracket");

	FCloseBracket parms{};	
	parms.bShouldTransact = bShouldTransact;

	ProcessEvent(fn, &parms);
}

bool UAnimationDataController::AddCurve(struct FAnimationCurveIdentifier& CurveId, int32_t CurveFlags, bool bShouldTransact){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationDataController.AddCurve");

	FAddCurve parms{};	
	parms.CurveId = CurveId;
	parms.CurveFlags = CurveFlags;
	parms.bShouldTransact = bShouldTransact;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UAnimationDataController::AddBoneTrack(struct FName BoneName, bool bShouldTransact){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationDataController.AddBoneTrack");

	FAddBoneTrack parms{};	
	parms.BoneName = BoneName;
	parms.bShouldTransact = bShouldTransact;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimationDataController::AddAttribute(struct FAnimationAttributeIdentifier& AttributeIdentifier, bool bShouldTransact){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationDataController.AddAttribute");

	FAddAttribute parms{};	
	parms.AttributeIdentifier = AttributeIdentifier;
	parms.bShouldTransact = bShouldTransact;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t ACameraActor::GetAutoActivatePlayerIndex(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CameraActor.GetAutoActivatePlayerIndex");

	FGetAutoActivatePlayerIndex parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UCameraComponent::SetUseFieldOfViewForLOD(bool bInUseFieldOfViewForLOD){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CameraComponent.SetUseFieldOfViewForLOD");

	FSetUseFieldOfViewForLOD parms{};	
	parms.bInUseFieldOfViewForLOD = bInUseFieldOfViewForLOD;

	ProcessEvent(fn, &parms);
}

void UCameraComponent::SetProjectionMode(enum class ECameraProjectionMode InProjectionMode){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CameraComponent.SetProjectionMode");

	FSetProjectionMode parms{};	
	parms.InProjectionMode = InProjectionMode;

	ProcessEvent(fn, &parms);
}

void UCameraComponent::SetPostProcessBlendWeight(float InPostProcessBlendWeight){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CameraComponent.SetPostProcessBlendWeight");

	FSetPostProcessBlendWeight parms{};	
	parms.InPostProcessBlendWeight = InPostProcessBlendWeight;

	ProcessEvent(fn, &parms);
}

void UCameraComponent::SetOrthoWidth(float InOrthoWidth){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CameraComponent.SetOrthoWidth");

	FSetOrthoWidth parms{};	
	parms.InOrthoWidth = InOrthoWidth;

	ProcessEvent(fn, &parms);
}

void UCameraComponent::SetOrthoNearClipPlane(float InOrthoNearClipPlane){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CameraComponent.SetOrthoNearClipPlane");

	FSetOrthoNearClipPlane parms{};	
	parms.InOrthoNearClipPlane = InOrthoNearClipPlane;

	ProcessEvent(fn, &parms);
}

void UCameraComponent::SetOrthoFarClipPlane(float InOrthoFarClipPlane){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CameraComponent.SetOrthoFarClipPlane");

	FSetOrthoFarClipPlane parms{};	
	parms.InOrthoFarClipPlane = InOrthoFarClipPlane;

	ProcessEvent(fn, &parms);
}

void UCameraComponent::SetFieldOfView(float InFieldOfView){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CameraComponent.SetFieldOfView");

	FSetFieldOfView parms{};	
	parms.InFieldOfView = InFieldOfView;

	ProcessEvent(fn, &parms);
}

void UCameraComponent::SetConstraintAspectRatio(bool bInConstrainAspectRatio){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CameraComponent.SetConstraintAspectRatio");

	FSetConstraintAspectRatio parms{};	
	parms.bInConstrainAspectRatio = bInConstrainAspectRatio;

	ProcessEvent(fn, &parms);
}

void UCameraComponent::SetAspectRatio(float InAspectRatio){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CameraComponent.SetAspectRatio");

	FSetAspectRatio parms{};	
	parms.InAspectRatio = InAspectRatio;

	ProcessEvent(fn, &parms);
}

void UCameraComponent::RemoveBlendable(struct TScriptInterface<IBlendableInterface> InBlendableObject){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CameraComponent.RemoveBlendable");

	FRemoveBlendable parms{};	
	parms.InBlendableObject = InBlendableObject;

	ProcessEvent(fn, &parms);
}

void UCameraComponent::OnCameraMeshHiddenChanged(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CameraComponent.OnCameraMeshHiddenChanged");

	FOnCameraMeshHiddenChanged parms{};	

	ProcessEvent(fn, &parms);
}

void UCameraComponent::GetCameraView(float DeltaTime, struct FMinimalViewInfo& DesiredView){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CameraComponent.GetCameraView");

	FGetCameraView parms{};	
	parms.DeltaTime = DeltaTime;
	parms.DesiredView = DesiredView;

	ProcessEvent(fn, &parms);
}

void UCameraComponent::AddOrUpdateBlendable(struct TScriptInterface<IBlendableInterface> InBlendableObject, float InWeight){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CameraComponent.AddOrUpdateBlendable");

	FAddOrUpdateBlendable parms{};	
	parms.InBlendableObject = InBlendableObject;
	parms.InWeight = InWeight;

	ProcessEvent(fn, &parms);
}

int32_t UPlatformInterfaceWebResponse::GetNumHeaders(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlatformInterfaceWebResponse.GetNumHeaders");

	FGetNumHeaders parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UPlatformInterfaceWebResponse::GetHeaderValue(struct FString HeaderName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlatformInterfaceWebResponse.GetHeaderValue");

	FGetHeaderValue parms{};	
	parms.HeaderName = HeaderName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UPlatformInterfaceWebResponse::GetHeader(int32_t HeaderIndex, struct FString& Header, struct FString& Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlatformInterfaceWebResponse.GetHeader");

	FGetHeader parms{};	
	parms.HeaderIndex = HeaderIndex;
	parms.Header = Header;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

float UAnimationAsset::GetPlayLength(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationAsset.GetPlayLength");

	FGetPlayLength parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void USceneCaptureComponentCube::CaptureScene(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponentCube.CaptureScene");

	FCaptureScene parms{};	

	ProcessEvent(fn, &parms);
}

struct TArray<struct FVector> URawAnimSequenceTrackExtensions::GetScaleKeys(struct FRawAnimSequenceTrack& Track){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.RawAnimSequenceTrackExtensions.GetScaleKeys");

	FGetScaleKeys parms{};	
	parms.Track = Track;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<struct FQuat> URawAnimSequenceTrackExtensions::GetRotationalKeys(struct FRawAnimSequenceTrack& Track){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.RawAnimSequenceTrackExtensions.GetRotationalKeys");

	FGetRotationalKeys parms{};	
	parms.Track = Track;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<struct FVector> URawAnimSequenceTrackExtensions::GetPositionalKeys(struct FRawAnimSequenceTrack& Track){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.RawAnimSequenceTrackExtensions.GetPositionalKeys");

	FGetPositionalKeys parms{};	
	parms.Track = Track;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FName UAudioPanelWidgetInterface::GetIconBrushName(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioPanelWidgetInterface.GetIconBrushName");

	FGetIconBrushName parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FText UAudioPanelWidgetInterface::GetEditorName(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioPanelWidgetInterface.GetEditorName");

	FGetEditorName parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void ALevelInstance::OnRep_LevelInstanceSpawnGuid(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LevelInstance.OnRep_LevelInstanceSpawnGuid");

	FOnRep_LevelInstanceSpawnGuid parms{};	

	ProcessEvent(fn, &parms);
}

void UBlueprintSetLibrary::SetSetPropertyByName(struct UObject* Object, struct FName PropertyName, struct TSet<int32_t>& Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintSetLibrary.SetSetPropertyByName");

	FSetSetPropertyByName parms{};	
	parms.Object = Object;
	parms.PropertyName = PropertyName;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UBlueprintSetLibrary::Set_Union(struct TSet<int32_t>& A, struct TSet<int32_t>& B, struct TSet<int32_t>& Result){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintSetLibrary.Set_Union");

	FSet_Union parms{};	
	parms.A = A;
	parms.B = B;
	parms.Result = Result;

	ProcessEvent(fn, &parms);
}

void UBlueprintSetLibrary::Set_ToArray(struct TSet<int32_t>& A, struct TArray<int32_t>& Result){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintSetLibrary.Set_ToArray");

	FSet_ToArray parms{};	
	parms.A = A;
	parms.Result = Result;

	ProcessEvent(fn, &parms);
}

void UBlueprintSetLibrary::Set_RemoveItems(struct TSet<int32_t>& TargetSet, struct TArray<int32_t>& Items){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintSetLibrary.Set_RemoveItems");

	FSet_RemoveItems parms{};	
	parms.TargetSet = TargetSet;
	parms.Items = Items;

	ProcessEvent(fn, &parms);
}

bool UBlueprintSetLibrary::Set_Remove(struct TSet<int32_t>& TargetSet, int32_t& Item){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintSetLibrary.Set_Remove");

	FSet_Remove parms{};	
	parms.TargetSet = TargetSet;
	parms.Item = Item;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UBlueprintSetLibrary::Set_Length(struct TSet<int32_t>& TargetSet){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintSetLibrary.Set_Length");

	FSet_Length parms{};	
	parms.TargetSet = TargetSet;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UBlueprintSetLibrary::Set_IsNotEmpty(struct TSet<int32_t>& TargetSet){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintSetLibrary.Set_IsNotEmpty");

	FSet_IsNotEmpty parms{};	
	parms.TargetSet = TargetSet;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UBlueprintSetLibrary::Set_IsEmpty(struct TSet<int32_t>& TargetSet){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintSetLibrary.Set_IsEmpty");

	FSet_IsEmpty parms{};	
	parms.TargetSet = TargetSet;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UBlueprintSetLibrary::Set_Intersection(struct TSet<int32_t>& A, struct TSet<int32_t>& B, struct TSet<int32_t>& Result){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintSetLibrary.Set_Intersection");

	FSet_Intersection parms{};	
	parms.A = A;
	parms.B = B;
	parms.Result = Result;

	ProcessEvent(fn, &parms);
}

void UBlueprintSetLibrary::Set_Difference(struct TSet<int32_t>& A, struct TSet<int32_t>& B, struct TSet<int32_t>& Result){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintSetLibrary.Set_Difference");

	FSet_Difference parms{};	
	parms.A = A;
	parms.B = B;
	parms.Result = Result;

	ProcessEvent(fn, &parms);
}

bool UBlueprintSetLibrary::Set_Contains(struct TSet<int32_t>& TargetSet, int32_t& ItemToFind){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintSetLibrary.Set_Contains");

	FSet_Contains parms{};	
	parms.TargetSet = TargetSet;
	parms.ItemToFind = ItemToFind;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UBlueprintSetLibrary::Set_Clear(struct TSet<int32_t>& TargetSet){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintSetLibrary.Set_Clear");

	FSet_Clear parms{};	
	parms.TargetSet = TargetSet;

	ProcessEvent(fn, &parms);
}

void UBlueprintSetLibrary::Set_AddItems(struct TSet<int32_t>& TargetSet, struct TArray<int32_t>& NewItems){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintSetLibrary.Set_AddItems");

	FSet_AddItems parms{};	
	parms.TargetSet = TargetSet;
	parms.NewItems = NewItems;

	ProcessEvent(fn, &parms);
}

void UBlueprintSetLibrary::Set_Add(struct TSet<int32_t>& TargetSet, int32_t& NewItem){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintSetLibrary.Set_Add");

	FSet_Add parms{};	
	parms.TargetSet = TargetSet;
	parms.NewItem = NewItem;

	ProcessEvent(fn, &parms);
}

void UPoseableMeshComponent::SetBoneTransformByName(struct FName BoneName, struct FTransform& InTransform, enum class EBoneSpaces BoneSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.SetBoneTransformByName");

	FSetBoneTransformByName parms{};	
	parms.BoneName = BoneName;
	parms.InTransform = InTransform;
	parms.BoneSpace = BoneSpace;

	ProcessEvent(fn, &parms);
}

void UPoseableMeshComponent::SetBoneScaleByName(struct FName BoneName, struct FVector InScale3D, enum class EBoneSpaces BoneSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.SetBoneScaleByName");

	FSetBoneScaleByName parms{};	
	parms.BoneName = BoneName;
	parms.InScale3D = InScale3D;
	parms.BoneSpace = BoneSpace;

	ProcessEvent(fn, &parms);
}

void UPoseableMeshComponent::SetBoneRotationByName(struct FName BoneName, struct FRotator InRotation, enum class EBoneSpaces BoneSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.SetBoneRotationByName");

	FSetBoneRotationByName parms{};	
	parms.BoneName = BoneName;
	parms.InRotation = InRotation;
	parms.BoneSpace = BoneSpace;

	ProcessEvent(fn, &parms);
}

void UPoseableMeshComponent::SetBoneLocationByName(struct FName BoneName, struct FVector InLocation, enum class EBoneSpaces BoneSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.SetBoneLocationByName");

	FSetBoneLocationByName parms{};	
	parms.BoneName = BoneName;
	parms.InLocation = InLocation;
	parms.BoneSpace = BoneSpace;

	ProcessEvent(fn, &parms);
}

void UPoseableMeshComponent::ResetBoneTransformByName(struct FName BoneName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.ResetBoneTransformByName");

	FResetBoneTransformByName parms{};	
	parms.BoneName = BoneName;

	ProcessEvent(fn, &parms);
}

struct FTransform UPoseableMeshComponent::GetBoneTransformByName(struct FName BoneName, enum class EBoneSpaces BoneSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.GetBoneTransformByName");

	FGetBoneTransformByName parms{};	
	parms.BoneName = BoneName;
	parms.BoneSpace = BoneSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UPoseableMeshComponent::GetBoneScaleByName(struct FName BoneName, enum class EBoneSpaces BoneSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.GetBoneScaleByName");

	FGetBoneScaleByName parms{};	
	parms.BoneName = BoneName;
	parms.BoneSpace = BoneSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator UPoseableMeshComponent::GetBoneRotationByName(struct FName BoneName, enum class EBoneSpaces BoneSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.GetBoneRotationByName");

	FGetBoneRotationByName parms{};	
	parms.BoneName = BoneName;
	parms.BoneSpace = BoneSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UPoseableMeshComponent::GetBoneLocationByName(struct FName BoneName, enum class EBoneSpaces BoneSpace){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.GetBoneLocationByName");

	FGetBoneLocationByName parms{};	
	parms.BoneName = BoneName;
	parms.BoneSpace = BoneSpace;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UPoseableMeshComponent::CopyPoseFromSkeletalComponent(struct USkeletalMeshComponent* InComponentToCopy){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.CopyPoseFromSkeletalComponent");

	FCopyPoseFromSkeletalComponent parms{};	
	parms.InComponentToCopy = InComponentToCopy;

	ProcessEvent(fn, &parms);
}

void ULightComponent::SetVolumetricScatteringIntensity(float NewIntensity){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LightComponent.SetVolumetricScatteringIntensity");

	FSetVolumetricScatteringIntensity parms{};	
	parms.NewIntensity = NewIntensity;

	ProcessEvent(fn, &parms);
}

void ULightComponent::SetUseTemperature(bool bNewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LightComponent.SetUseTemperature");

	FSetUseTemperature parms{};	
	parms.bNewValue = bNewValue;

	ProcessEvent(fn, &parms);
}

void ULightComponent::SetUseIESBrightness(bool bNewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LightComponent.SetUseIESBrightness");

	FSetUseIESBrightness parms{};	
	parms.bNewValue = bNewValue;

	ProcessEvent(fn, &parms);
}

void ULightComponent::SetTransmission(bool bNewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LightComponent.SetTransmission");

	FSetTransmission parms{};	
	parms.bNewValue = bNewValue;

	ProcessEvent(fn, &parms);
}

void ULightComponent::SetTemperature(float NewTemperature){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LightComponent.SetTemperature");

	FSetTemperature parms{};	
	parms.NewTemperature = NewTemperature;

	ProcessEvent(fn, &parms);
}

void ULightComponent::SetSpecularScale(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LightComponent.SetSpecularScale");

	FSetSpecularScale parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void ULightComponent::SetShadowSlopeBias(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LightComponent.SetShadowSlopeBias");

	FSetShadowSlopeBias parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void ULightComponent::SetShadowBias(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LightComponent.SetShadowBias");

	FSetShadowBias parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void ULightComponent::SetLightingChannels(bool bChannel0, bool bChannel1, bool bChannel2){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LightComponent.SetLightingChannels");

	FSetLightingChannels parms{};	
	parms.bChannel0 = bChannel0;
	parms.bChannel1 = bChannel1;
	parms.bChannel2 = bChannel2;

	ProcessEvent(fn, &parms);
}

void ULightComponent::SetLightFunctionScale(struct FVector NewLightFunctionScale){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LightComponent.SetLightFunctionScale");

	FSetLightFunctionScale parms{};	
	parms.NewLightFunctionScale = NewLightFunctionScale;

	ProcessEvent(fn, &parms);
}

void ULightComponent::SetLightFunctionMaterial(struct UMaterialInterface* NewLightFunctionMaterial){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LightComponent.SetLightFunctionMaterial");

	FSetLightFunctionMaterial parms{};	
	parms.NewLightFunctionMaterial = NewLightFunctionMaterial;

	ProcessEvent(fn, &parms);
}

void ULightComponent::SetLightFunctionFadeDistance(float NewLightFunctionFadeDistance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LightComponent.SetLightFunctionFadeDistance");

	FSetLightFunctionFadeDistance parms{};	
	parms.NewLightFunctionFadeDistance = NewLightFunctionFadeDistance;

	ProcessEvent(fn, &parms);
}

void ULightComponent::SetLightFunctionDisabledBrightness(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LightComponent.SetLightFunctionDisabledBrightness");

	FSetLightFunctionDisabledBrightness parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void ULightComponent::SetLightFColor(struct FColor NewLightColor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LightComponent.SetLightFColor");

	FSetLightFColor parms{};	
	parms.NewLightColor = NewLightColor;

	ProcessEvent(fn, &parms);
}

void ULightComponent::SetLightColor(struct FLinearColor NewLightColor, bool bSRGB){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LightComponent.SetLightColor");

	FSetLightColor parms{};	
	parms.NewLightColor = NewLightColor;
	parms.bSRGB = bSRGB;

	ProcessEvent(fn, &parms);
}

void ULightComponent::SetIntensity(float NewIntensity){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LightComponent.SetIntensity");

	FSetIntensity parms{};	
	parms.NewIntensity = NewIntensity;

	ProcessEvent(fn, &parms);
}

void ULightComponent::SetIndirectLightingIntensity(float NewIntensity){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LightComponent.SetIndirectLightingIntensity");

	FSetIndirectLightingIntensity parms{};	
	parms.NewIntensity = NewIntensity;

	ProcessEvent(fn, &parms);
}

void ULightComponent::SetIESTexture(struct UTextureLightProfile* NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LightComponent.SetIESTexture");

	FSetIESTexture parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void ULightComponent::SetIESBrightnessScale(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LightComponent.SetIESBrightnessScale");

	FSetIESBrightnessScale parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void ULightComponent::SetForceCachedShadowsForMovablePrimitives(bool bNewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LightComponent.SetForceCachedShadowsForMovablePrimitives");

	FSetForceCachedShadowsForMovablePrimitives parms{};	
	parms.bNewValue = bNewValue;

	ProcessEvent(fn, &parms);
}

void ULightComponent::SetEnableLightShaftBloom(bool bNewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LightComponent.SetEnableLightShaftBloom");

	FSetEnableLightShaftBloom parms{};	
	parms.bNewValue = bNewValue;

	ProcessEvent(fn, &parms);
}

void ULightComponent::SetBloomTint(struct FColor NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LightComponent.SetBloomTint");

	FSetBloomTint parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void ULightComponent::SetBloomThreshold(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LightComponent.SetBloomThreshold");

	FSetBloomThreshold parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void ULightComponent::SetBloomScale(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LightComponent.SetBloomScale");

	FSetBloomScale parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void ULightComponent::SetBloomMaxBrightness(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LightComponent.SetBloomMaxBrightness");

	FSetBloomMaxBrightness parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void ULightComponent::SetAffectTranslucentLighting(bool bNewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LightComponent.SetAffectTranslucentLighting");

	FSetAffectTranslucentLighting parms{};	
	parms.bNewValue = bNewValue;

	ProcessEvent(fn, &parms);
}

void ULightComponent::SetAffectDynamicIndirectLighting(bool bNewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LightComponent.SetAffectDynamicIndirectLighting");

	FSetAffectDynamicIndirectLighting parms{};	
	parms.bNewValue = bNewValue;

	ProcessEvent(fn, &parms);
}

void AEmitter::ToggleActive(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Emitter.ToggleActive");

	FToggleActive parms{};	

	ProcessEvent(fn, &parms);
}

void AEmitter::SetVectorParameter(struct FName ParameterName, struct FVector Param){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Emitter.SetVectorParameter");

	FSetVectorParameter parms{};	
	parms.ParameterName = ParameterName;
	parms.Param = Param;

	ProcessEvent(fn, &parms);
}

void AEmitter::SetTemplate(struct UParticleSystem* NewTemplate){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Emitter.SetTemplate");

	FSetTemplate parms{};	
	parms.NewTemplate = NewTemplate;

	ProcessEvent(fn, &parms);
}

void AEmitter::SetMaterialParameter(struct FName ParameterName, struct UMaterialInterface* Param){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Emitter.SetMaterialParameter");

	FSetMaterialParameter parms{};	
	parms.ParameterName = ParameterName;
	parms.Param = Param;

	ProcessEvent(fn, &parms);
}

void AEmitter::SetFloatParameter(struct FName ParameterName, float Param){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Emitter.SetFloatParameter");

	FSetFloatParameter parms{};	
	parms.ParameterName = ParameterName;
	parms.Param = Param;

	ProcessEvent(fn, &parms);
}

void AEmitter::SetColorParameter(struct FName ParameterName, struct FLinearColor Param){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Emitter.SetColorParameter");

	FSetColorParameter parms{};	
	parms.ParameterName = ParameterName;
	parms.Param = Param;

	ProcessEvent(fn, &parms);
}

void AEmitter::SetActorParameter(struct FName ParameterName, struct AActor* Param){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Emitter.SetActorParameter");

	FSetActorParameter parms{};	
	parms.ParameterName = ParameterName;
	parms.Param = Param;

	ProcessEvent(fn, &parms);
}

void AEmitter::OnRep_bCurrentlyActive(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Emitter.OnRep_bCurrentlyActive");

	FOnRep_bCurrentlyActive parms{};	

	ProcessEvent(fn, &parms);
}

void AEmitter::OnParticleSystemFinished(struct UParticleSystemComponent* FinishedComponent){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Emitter.OnParticleSystemFinished");

	FOnParticleSystemFinished parms{};	
	parms.FinishedComponent = FinishedComponent;

	ProcessEvent(fn, &parms);
}

bool AEmitter::IsActive(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Emitter.IsActive");

	FIsActive parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void AEmitter::Deactivate(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Emitter.Deactivate");

	FDeactivate parms{};	

	ProcessEvent(fn, &parms);
}

void AEmitter::Activate(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Emitter.Activate");

	FActivate parms{};	

	ProcessEvent(fn, &parms);
}

struct FVector UCurveVector::GetVectorValue(float InTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CurveVector.GetVectorValue");

	FGetVectorValue parms{};	
	parms.InTime = InTime;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void APlayerCameraManager::SwapPendingViewTargetWhenUsingClientSideCameraUpdates(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.SwapPendingViewTargetWhenUsingClientSideCameraUpdates");

	FSwapPendingViewTargetWhenUsingClientSideCameraUpdates parms{};	

	ProcessEvent(fn, &parms);
}

void APlayerCameraManager::StopCameraShake(struct UCameraShakeBase* ShakeInstance, bool bImmediately){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.StopCameraShake");

	FStopCameraShake parms{};	
	parms.ShakeInstance = ShakeInstance;
	parms.bImmediately = bImmediately;

	ProcessEvent(fn, &parms);
}

void APlayerCameraManager::StopCameraFade(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.StopCameraFade");

	FStopCameraFade parms{};	

	ProcessEvent(fn, &parms);
}

void APlayerCameraManager::StopAllInstancesOfCameraShakeFromSource(UCameraShakeBase* Shake, struct UCameraShakeSourceComponent* SourceComponent, bool bImmediately){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.StopAllInstancesOfCameraShakeFromSource");

	FStopAllInstancesOfCameraShakeFromSource parms{};	
	parms.Shake = Shake;
	parms.SourceComponent = SourceComponent;
	parms.bImmediately = bImmediately;

	ProcessEvent(fn, &parms);
}

void APlayerCameraManager::StopAllInstancesOfCameraShake(UCameraShakeBase* Shake, bool bImmediately){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.StopAllInstancesOfCameraShake");

	FStopAllInstancesOfCameraShake parms{};	
	parms.Shake = Shake;
	parms.bImmediately = bImmediately;

	ProcessEvent(fn, &parms);
}

void APlayerCameraManager::StopAllCameraShakesFromSource(struct UCameraShakeSourceComponent* SourceComponent, bool bImmediately){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.StopAllCameraShakesFromSource");

	FStopAllCameraShakesFromSource parms{};	
	parms.SourceComponent = SourceComponent;
	parms.bImmediately = bImmediately;

	ProcessEvent(fn, &parms);
}

void APlayerCameraManager::StopAllCameraShakes(bool bImmediately){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.StopAllCameraShakes");

	FStopAllCameraShakes parms{};	
	parms.bImmediately = bImmediately;

	ProcessEvent(fn, &parms);
}

struct UCameraShakeBase* APlayerCameraManager::StartCameraShakeFromSource(UCameraShakeBase* ShakeClass, struct UCameraShakeSourceComponent* SourceComponent, float Scale, uint8_t PlaySpace, struct FRotator UserPlaySpaceRot){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.StartCameraShakeFromSource");

	FStartCameraShakeFromSource parms{};	
	parms.ShakeClass = ShakeClass;
	parms.SourceComponent = SourceComponent;
	parms.Scale = Scale;
	parms.PlaySpace = PlaySpace;
	parms.UserPlaySpaceRot = UserPlaySpaceRot;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UCameraShakeBase* APlayerCameraManager::StartCameraShake(UCameraShakeBase* ShakeClass, float Scale, uint8_t PlaySpace, struct FRotator UserPlaySpaceRot){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.StartCameraShake");

	FStartCameraShake parms{};	
	parms.ShakeClass = ShakeClass;
	parms.Scale = Scale;
	parms.PlaySpace = PlaySpace;
	parms.UserPlaySpaceRot = UserPlaySpaceRot;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void APlayerCameraManager::StartCameraFade(float FromAlpha, float ToAlpha, float Duration, struct FLinearColor Color, bool bShouldFadeAudio, bool bHoldWhenFinished){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.StartCameraFade");

	FStartCameraFade parms{};	
	parms.FromAlpha = FromAlpha;
	parms.ToAlpha = ToAlpha;
	parms.Duration = Duration;
	parms.Color = Color;
	parms.bShouldFadeAudio = bShouldFadeAudio;
	parms.bHoldWhenFinished = bHoldWhenFinished;

	ProcessEvent(fn, &parms);
}

void APlayerCameraManager::SetManualCameraFade(float InFadeAmount, struct FLinearColor Color, bool bInFadeAudio){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.SetManualCameraFade");

	FSetManualCameraFade parms{};	
	parms.InFadeAmount = InFadeAmount;
	parms.Color = Color;
	parms.bInFadeAudio = bInFadeAudio;

	ProcessEvent(fn, &parms);
}

void APlayerCameraManager::SetGameCameraCutThisFrame(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.SetGameCameraCutThisFrame");

	FSetGameCameraCutThisFrame parms{};	

	ProcessEvent(fn, &parms);
}

void APlayerCameraManager::RemoveGenericCameraLensEffect(struct TScriptInterface<ICameraLensEffectInterface> Emitter){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.RemoveGenericCameraLensEffect");

	FRemoveGenericCameraLensEffect parms{};	
	parms.Emitter = Emitter;

	ProcessEvent(fn, &parms);
}

bool APlayerCameraManager::RemoveCameraModifier(struct UCameraModifier* ModifierToRemove){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.RemoveCameraModifier");

	FRemoveCameraModifier parms{};	
	parms.ModifierToRemove = ModifierToRemove;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void APlayerCameraManager::RemoveCameraLensEffect(struct AEmitterCameraLensEffectBase* Emitter){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.RemoveCameraLensEffect");

	FRemoveCameraLensEffect parms{};	
	parms.Emitter = Emitter;

	ProcessEvent(fn, &parms);
}

void APlayerCameraManager::PhotographyCameraModify(struct FVector NewCameraLocation, struct FVector PreviousCameraLocation, struct FVector OriginalCameraLocation, struct FVector& ResultCameraLocation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.PhotographyCameraModify");

	FPhotographyCameraModify parms{};	
	parms.NewCameraLocation = NewCameraLocation;
	parms.PreviousCameraLocation = PreviousCameraLocation;
	parms.OriginalCameraLocation = OriginalCameraLocation;
	parms.ResultCameraLocation = ResultCameraLocation;

	ProcessEvent(fn, &parms);
}

void APlayerCameraManager::OnPhotographySessionStart(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.OnPhotographySessionStart");

	FOnPhotographySessionStart parms{};	

	ProcessEvent(fn, &parms);
}

void APlayerCameraManager::OnPhotographySessionEnd(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.OnPhotographySessionEnd");

	FOnPhotographySessionEnd parms{};	

	ProcessEvent(fn, &parms);
}

void APlayerCameraManager::OnPhotographyMultiPartCaptureStart(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.OnPhotographyMultiPartCaptureStart");

	FOnPhotographyMultiPartCaptureStart parms{};	

	ProcessEvent(fn, &parms);
}

void APlayerCameraManager::OnPhotographyMultiPartCaptureEnd(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.OnPhotographyMultiPartCaptureEnd");

	FOnPhotographyMultiPartCaptureEnd parms{};	

	ProcessEvent(fn, &parms);
}

struct APlayerController* APlayerCameraManager::GetOwningPlayerController(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.GetOwningPlayerController");

	FGetOwningPlayerController parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float APlayerCameraManager::GetFOVAngle(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.GetFOVAngle");

	FGetFOVAngle parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator APlayerCameraManager::GetCameraRotation(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.GetCameraRotation");

	FGetCameraRotation parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector APlayerCameraManager::GetCameraLocation(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.GetCameraLocation");

	FGetCameraLocation parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UCameraModifier* APlayerCameraManager::FindCameraModifierByClass(UCameraModifier* ModifierClass){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.FindCameraModifierByClass");

	FFindCameraModifierByClass parms{};	
	parms.ModifierClass = ModifierClass;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void APlayerCameraManager::ClearCameraLensEffects(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.ClearCameraLensEffects");

	FClearCameraLensEffects parms{};	

	ProcessEvent(fn, &parms);
}

bool APlayerCameraManager::BlueprintUpdateCamera(struct AActor* CameraTarget, struct FVector& NewCameraLocation, struct FRotator& NewCameraRotation, float& NewCameraFOV){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.BlueprintUpdateCamera");

	FBlueprintUpdateCamera parms{};	
	parms.CameraTarget = CameraTarget;
	parms.NewCameraLocation = NewCameraLocation;
	parms.NewCameraRotation = NewCameraRotation;
	parms.NewCameraFOV = NewCameraFOV;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UCameraModifier* APlayerCameraManager::AddNewCameraModifier(UCameraModifier* ModifierClass){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.AddNewCameraModifier");

	FAddNewCameraModifier parms{};	
	parms.ModifierClass = ModifierClass;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TScriptInterface<ICameraLensEffectInterface> APlayerCameraManager::AddGenericCameraLensEffect(AActor* LensEffectEmitterClass){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.AddGenericCameraLensEffect");

	FAddGenericCameraLensEffect parms{};	
	parms.LensEffectEmitterClass = LensEffectEmitterClass;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct AEmitterCameraLensEffectBase* APlayerCameraManager::AddCameraLensEffect(AEmitterCameraLensEffectBase* LensEffectEmitterClass){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.AddCameraLensEffect");

	FAddCameraLensEffect parms{};	
	parms.LensEffectEmitterClass = LensEffectEmitterClass;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void AExponentialHeightFog::OnRep_bEnabled(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFog.OnRep_bEnabled");

	FOnRep_bEnabled parms{};	

	ProcessEvent(fn, &parms);
}

void UExponentialHeightFogComponent::SetVolumetricFogScatteringDistribution(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetVolumetricFogScatteringDistribution");

	FSetVolumetricFogScatteringDistribution parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UExponentialHeightFogComponent::SetVolumetricFogExtinctionScale(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetVolumetricFogExtinctionScale");

	FSetVolumetricFogExtinctionScale parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UExponentialHeightFogComponent::SetVolumetricFogEmissive(struct FLinearColor NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetVolumetricFogEmissive");

	FSetVolumetricFogEmissive parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UExponentialHeightFogComponent::SetVolumetricFogDistance(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetVolumetricFogDistance");

	FSetVolumetricFogDistance parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UExponentialHeightFogComponent::SetVolumetricFogAlbedo(struct FColor NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetVolumetricFogAlbedo");

	FSetVolumetricFogAlbedo parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UExponentialHeightFogComponent::SetVolumetricFog(bool bNewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetVolumetricFog");

	FSetVolumetricFog parms{};	
	parms.bNewValue = bNewValue;

	ProcessEvent(fn, &parms);
}

void UExponentialHeightFogComponent::SetStartDistance(float Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetStartDistance");

	FSetStartDistance parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UExponentialHeightFogComponent::SetSecondFogHeightOffset(float Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetSecondFogHeightOffset");

	FSetSecondFogHeightOffset parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UExponentialHeightFogComponent::SetSecondFogHeightFalloff(float Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetSecondFogHeightFalloff");

	FSetSecondFogHeightFalloff parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UExponentialHeightFogComponent::SetSecondFogDensity(float Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetSecondFogDensity");

	FSetSecondFogDensity parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UExponentialHeightFogComponent::SetSecondFogData(struct FExponentialHeightFogData NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetSecondFogData");

	FSetSecondFogData parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UExponentialHeightFogComponent::SetNonDirectionalInscatteringColorDistance(float Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetNonDirectionalInscatteringColorDistance");

	FSetNonDirectionalInscatteringColorDistance parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UExponentialHeightFogComponent::SetInscatteringTextureTint(struct FLinearColor Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetInscatteringTextureTint");

	FSetInscatteringTextureTint parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UExponentialHeightFogComponent::SetInscatteringColorCubemapAngle(float Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetInscatteringColorCubemapAngle");

	FSetInscatteringColorCubemapAngle parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UExponentialHeightFogComponent::SetInscatteringColorCubemap(struct UTextureCube* Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetInscatteringColorCubemap");

	FSetInscatteringColorCubemap parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UExponentialHeightFogComponent::SetFullyDirectionalInscatteringColorDistance(float Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetFullyDirectionalInscatteringColorDistance");

	FSetFullyDirectionalInscatteringColorDistance parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UExponentialHeightFogComponent::SetFogMaxOpacity(float Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetFogMaxOpacity");

	FSetFogMaxOpacity parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UExponentialHeightFogComponent::SetFogInscatteringColor(struct FLinearColor Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetFogInscatteringColor");

	FSetFogInscatteringColor parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UExponentialHeightFogComponent::SetFogHeightFalloff(float Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetFogHeightFalloff");

	FSetFogHeightFalloff parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UExponentialHeightFogComponent::SetFogDensity(float Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetFogDensity");

	FSetFogDensity parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UExponentialHeightFogComponent::SetFogCutoffDistance(float Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetFogCutoffDistance");

	FSetFogCutoffDistance parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UExponentialHeightFogComponent::SetDirectionalInscatteringStartDistance(float Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetDirectionalInscatteringStartDistance");

	FSetDirectionalInscatteringStartDistance parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UExponentialHeightFogComponent::SetDirectionalInscatteringExponent(float Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetDirectionalInscatteringExponent");

	FSetDirectionalInscatteringExponent parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UExponentialHeightFogComponent::SetDirectionalInscatteringColor(struct FLinearColor Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetDirectionalInscatteringColor");

	FSetDirectionalInscatteringColor parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void ASpotLight::SetOuterConeAngle(float NewOuterConeAngle){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SpotLight.SetOuterConeAngle");

	FSetOuterConeAngle parms{};	
	parms.NewOuterConeAngle = NewOuterConeAngle;

	ProcessEvent(fn, &parms);
}

void ASpotLight::SetInnerConeAngle(float NewInnerConeAngle){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SpotLight.SetInnerConeAngle");

	FSetInnerConeAngle parms{};	
	parms.NewInnerConeAngle = NewInnerConeAngle;

	ProcessEvent(fn, &parms);
}

void UNetPushModelHelpers::MarkPropertyDirtyFromRepIndex(struct UObject* Object, int32_t RepIndex, struct FName PropertyName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.NetPushModelHelpers.MarkPropertyDirtyFromRepIndex");

	FMarkPropertyDirtyFromRepIndex parms{};	
	parms.Object = Object;
	parms.RepIndex = RepIndex;
	parms.PropertyName = PropertyName;

	ProcessEvent(fn, &parms);
}

void UNetPushModelHelpers::MarkPropertyDirty(struct UObject* Object, struct FName PropertyName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.NetPushModelHelpers.MarkPropertyDirty");

	FMarkPropertyDirty parms{};	
	parms.Object = Object;
	parms.PropertyName = PropertyName;

	ProcessEvent(fn, &parms);
}

void UKismetGuidLibrary::Parse_StringToGuid(struct FString GuidString, struct FGuid& OutGuid, bool& Success){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetGuidLibrary.Parse_StringToGuid");

	FParse_StringToGuid parms{};	
	parms.GuidString = GuidString;
	parms.OutGuid = OutGuid;
	parms.Success = Success;

	ProcessEvent(fn, &parms);
}

bool UKismetGuidLibrary::NotEqual_GuidGuid(struct FGuid& A, struct FGuid& B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetGuidLibrary.NotEqual_GuidGuid");

	FNotEqual_GuidGuid parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FGuid UKismetGuidLibrary::NewGuid(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetGuidLibrary.NewGuid");

	FNewGuid parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetGuidLibrary::IsValid_Guid(struct FGuid& InGuid){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetGuidLibrary.IsValid_Guid");

	FIsValid_Guid parms{};	
	parms.InGuid = InGuid;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetGuidLibrary::Invalidate_Guid(struct FGuid& InGuid){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetGuidLibrary.Invalidate_Guid");

	FInvalidate_Guid parms{};	
	parms.InGuid = InGuid;

	ProcessEvent(fn, &parms);
}

bool UKismetGuidLibrary::EqualEqual_GuidGuid(struct FGuid& A, struct FGuid& B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetGuidLibrary.EqualEqual_GuidGuid");

	FEqualEqual_GuidGuid parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetGuidLibrary::Conv_GuidToString(struct FGuid& InGuid){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetGuidLibrary.Conv_GuidToString");

	FConv_GuidToString parms{};	
	parms.InGuid = InGuid;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool ULevelStreaming::ShouldBeLoaded(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LevelStreaming.ShouldBeLoaded");

	FShouldBeLoaded parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void ULevelStreaming::SetShouldBeVisible(bool bInShouldBeVisible){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LevelStreaming.SetShouldBeVisible");

	FSetShouldBeVisible parms{};	
	parms.bInShouldBeVisible = bInShouldBeVisible;

	ProcessEvent(fn, &parms);
}

void ULevelStreaming::SetShouldBeLoaded(bool bInShouldBeLoaded){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LevelStreaming.SetShouldBeLoaded");

	FSetShouldBeLoaded parms{};	
	parms.bInShouldBeLoaded = bInShouldBeLoaded;

	ProcessEvent(fn, &parms);
}

void ULevelStreaming::SetPriority(int32_t NewPriority){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LevelStreaming.SetPriority");

	FSetPriority parms{};	
	parms.NewPriority = NewPriority;

	ProcessEvent(fn, &parms);
}

void ULevelStreaming::SetLevelLODIndex(int32_t LODIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LevelStreaming.SetLevelLODIndex");

	FSetLevelLODIndex parms{};	
	parms.LODIndex = LODIndex;

	ProcessEvent(fn, &parms);
}

void ULevelStreaming::SetIsRequestingUnloadAndRemoval(bool bInIsRequestingUnloadAndRemoval){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LevelStreaming.SetIsRequestingUnloadAndRemoval");

	FSetIsRequestingUnloadAndRemoval parms{};	
	parms.bInIsRequestingUnloadAndRemoval = bInIsRequestingUnloadAndRemoval;

	ProcessEvent(fn, &parms);
}

bool ULevelStreaming::IsStreamingStatePending(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LevelStreaming.IsStreamingStatePending");

	FIsStreamingStatePending parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool ULevelStreaming::IsLevelVisible(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LevelStreaming.IsLevelVisible");

	FIsLevelVisible parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool ULevelStreaming::IsLevelLoaded(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LevelStreaming.IsLevelLoaded");

	FIsLevelLoaded parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FName ULevelStreaming::GetWorldAssetPackageFName(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LevelStreaming.GetWorldAssetPackageFName");

	FGetWorldAssetPackageFName parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct ULevel* ULevelStreaming::GetLoadedLevel(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LevelStreaming.GetLoadedLevel");

	FGetLoadedLevel parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct ALevelScriptActor* ULevelStreaming::GetLevelScriptActor(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LevelStreaming.GetLevelScriptActor");

	FGetLevelScriptActor parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool ULevelStreaming::GetIsRequestingUnloadAndRemoval(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LevelStreaming.GetIsRequestingUnloadAndRemoval");

	FGetIsRequestingUnloadAndRemoval parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct ULevelStreaming* ULevelStreaming::CreateInstance(struct FString UniqueInstanceName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LevelStreaming.CreateInstance");

	FCreateInstance parms{};	
	parms.UniqueInstanceName = UniqueInstanceName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct ULevelStreamingDynamic* ULevelStreamingDynamic::LoadLevelInstanceBySoftObjectPtr(struct UObject* WorldContextObject, struct TSoftObjectPtr<UWorld> Level, struct FVector Location, struct FRotator Rotation, bool& bOutSuccess, struct FString OptionalLevelNameOverride, ULevelStreamingDynamic* OptionalLevelStreamingClass, bool bLoadAsTempPackage){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LevelStreamingDynamic.LoadLevelInstanceBySoftObjectPtr");

	FLoadLevelInstanceBySoftObjectPtr parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Level = Level;
	parms.Location = Location;
	parms.Rotation = Rotation;
	parms.bOutSuccess = bOutSuccess;
	parms.OptionalLevelNameOverride = OptionalLevelNameOverride;
	parms.OptionalLevelStreamingClass = OptionalLevelStreamingClass;
	parms.bLoadAsTempPackage = bLoadAsTempPackage;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct ULevelStreamingDynamic* ULevelStreamingDynamic::LoadLevelInstance(struct UObject* WorldContextObject, struct FString LevelName, struct FVector Location, struct FRotator Rotation, bool& bOutSuccess, struct FString OptionalLevelNameOverride, ULevelStreamingDynamic* OptionalLevelStreamingClass, bool bLoadAsTempPackage){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LevelStreamingDynamic.LoadLevelInstance");

	FLoadLevelInstance parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.LevelName = LevelName;
	parms.Location = Location;
	parms.Rotation = Rotation;
	parms.bOutSuccess = bOutSuccess;
	parms.OptionalLevelNameOverride = OptionalLevelNameOverride;
	parms.OptionalLevelStreamingClass = OptionalLevelStreamingClass;
	parms.bLoadAsTempPackage = bLoadAsTempPackage;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UChildActorComponent::SetChildActorClass(AActor* InClass){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ChildActorComponent.SetChildActorClass");

	FSetChildActorClass parms{};	
	parms.InClass = InClass;

	ProcessEvent(fn, &parms);
}

void UChildActorComponent::OnChildActorDestroyed(struct AActor* DestroyedActor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ChildActorComponent.OnChildActorDestroyed");

	FOnChildActorDestroyed parms{};	
	parms.DestroyedActor = DestroyedActor;

	ProcessEvent(fn, &parms);
}

void ULightComponentBase::SetSamplesPerPixel(int32_t NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LightComponentBase.SetSamplesPerPixel");

	FSetSamplesPerPixel parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void ULightComponentBase::SetCastVolumetricShadow(bool bNewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LightComponentBase.SetCastVolumetricShadow");

	FSetCastVolumetricShadow parms{};	
	parms.bNewValue = bNewValue;

	ProcessEvent(fn, &parms);
}

void ULightComponentBase::SetCastShadows(bool bNewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LightComponentBase.SetCastShadows");

	FSetCastShadows parms{};	
	parms.bNewValue = bNewValue;

	ProcessEvent(fn, &parms);
}

void ULightComponentBase::SetCastRaytracedShadows(enum class ECastRayTracedShadow bNewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LightComponentBase.SetCastRaytracedShadows");

	FSetCastRaytracedShadows parms{};	
	parms.bNewValue = bNewValue;

	ProcessEvent(fn, &parms);
}

void ULightComponentBase::SetCastRaytracedShadow(bool bNewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LightComponentBase.SetCastRaytracedShadow");

	FSetCastRaytracedShadow parms{};	
	parms.bNewValue = bNewValue;

	ProcessEvent(fn, &parms);
}

void ULightComponentBase::SetCastDeepShadow(bool bNewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LightComponentBase.SetCastDeepShadow");

	FSetCastDeepShadow parms{};	
	parms.bNewValue = bNewValue;

	ProcessEvent(fn, &parms);
}

void ULightComponentBase::SetAffectReflection(bool bNewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LightComponentBase.SetAffectReflection");

	FSetAffectReflection parms{};	
	parms.bNewValue = bNewValue;

	ProcessEvent(fn, &parms);
}

void ULightComponentBase::SetAffectGlobalIllumination(bool bNewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LightComponentBase.SetAffectGlobalIllumination");

	FSetAffectGlobalIllumination parms{};	
	parms.bNewValue = bNewValue;

	ProcessEvent(fn, &parms);
}

struct FLinearColor ULightComponentBase::GetLightColor(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LightComponentBase.GetLightColor");

	FGetLightColor parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UTexture2D::Blueprint_GetSizeY(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Texture2D.Blueprint_GetSizeY");

	FBlueprint_GetSizeY parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UTexture2D::Blueprint_GetSizeX(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Texture2D.Blueprint_GetSizeX");

	FBlueprint_GetSizeX parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void URadialForceComponent::RemoveObjectTypeToAffect(enum class EObjectTypeQuery ObjectType){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.RadialForceComponent.RemoveObjectTypeToAffect");

	FRemoveObjectTypeToAffect parms{};	
	parms.ObjectType = ObjectType;

	ProcessEvent(fn, &parms);
}

void URadialForceComponent::FireImpulse(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.RadialForceComponent.FireImpulse");

	FFireImpulse parms{};	

	ProcessEvent(fn, &parms);
}

void URadialForceComponent::AddObjectTypeToAffect(enum class EObjectTypeQuery ObjectType){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.RadialForceComponent.AddObjectTypeToAffect");

	FAddObjectTypeToAffect parms{};	
	parms.ObjectType = ObjectType;

	ProcessEvent(fn, &parms);
}

struct FString UKismetStringLibrary::TrimTrailing(struct FString SourceString){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.TrimTrailing");

	FTrimTrailing parms{};	
	parms.SourceString = SourceString;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::Trim(struct FString SourceString){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Trim");

	FTrim parms{};	
	parms.SourceString = SourceString;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::ToUpper(struct FString SourceString){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.ToUpper");

	FToUpper parms{};	
	parms.SourceString = SourceString;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::ToLower(struct FString SourceString){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.ToLower");

	FToLower parms{};	
	parms.SourceString = SourceString;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::TimeSecondsToString(float InSeconds){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.TimeSecondsToString");

	FTimeSecondsToString parms{};	
	parms.InSeconds = InSeconds;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetStringLibrary::StartsWith(struct FString SourceString, struct FString InPrefix, enum class ESearchCase SearchCase){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.StartsWith");

	FStartsWith parms{};	
	parms.SourceString = SourceString;
	parms.InPrefix = InPrefix;
	parms.SearchCase = SearchCase;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetStringLibrary::Split(struct FString SourceString, struct FString InStr, struct FString& LeftS, struct FString& RightS, enum class ESearchCase SearchCase, enum class ESearchDir SearchDir){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Split");

	FSplit parms{};	
	parms.SourceString = SourceString;
	parms.InStr = InStr;
	parms.LeftS = LeftS;
	parms.RightS = RightS;
	parms.SearchCase = SearchCase;
	parms.SearchDir = SearchDir;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::RightPad(struct FString SourceString, int32_t ChCount){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.RightPad");

	FRightPad parms{};	
	parms.SourceString = SourceString;
	parms.ChCount = ChCount;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::RightChop(struct FString SourceString, int32_t Count){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.RightChop");

	FRightChop parms{};	
	parms.SourceString = SourceString;
	parms.Count = Count;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::Right(struct FString SourceString, int32_t Count){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Right");

	FRight parms{};	
	parms.SourceString = SourceString;
	parms.Count = Count;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::Reverse(struct FString SourceString){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Reverse");

	FReverse parms{};	
	parms.SourceString = SourceString;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetStringLibrary::ReplaceInline(struct FString& SourceString, struct FString SearchText, struct FString ReplacementText, enum class ESearchCase SearchCase){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.ReplaceInline");

	FReplaceInline parms{};	
	parms.SourceString = SourceString;
	parms.SearchText = SearchText;
	parms.ReplacementText = ReplacementText;
	parms.SearchCase = SearchCase;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::Replace(struct FString SourceString, struct FString From, struct FString To, enum class ESearchCase SearchCase){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Replace");

	FReplace parms{};	
	parms.SourceString = SourceString;
	parms.From = From;
	parms.To = To;
	parms.SearchCase = SearchCase;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<struct FString> UKismetStringLibrary::ParseIntoArray(struct FString SourceString, struct FString Delimiter, bool CullEmptyStrings){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.ParseIntoArray");

	FParseIntoArray parms{};	
	parms.SourceString = SourceString;
	parms.Delimiter = Delimiter;
	parms.CullEmptyStrings = CullEmptyStrings;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetStringLibrary::NotEqual_StrStr(struct FString A, struct FString B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.NotEqual_StrStr");

	FNotEqual_StrStr parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetStringLibrary::NotEqual_StriStri(struct FString A, struct FString B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.NotEqual_StriStri");

	FNotEqual_StriStri parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::Mid(struct FString SourceString, int32_t Start, int32_t Count){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Mid");

	FMid parms{};	
	parms.SourceString = SourceString;
	parms.Start = Start;
	parms.Count = Count;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetStringLibrary::MatchesWildcard(struct FString SourceString, struct FString Wildcard, enum class ESearchCase SearchCase){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.MatchesWildcard");

	FMatchesWildcard parms{};	
	parms.SourceString = SourceString;
	parms.Wildcard = Wildcard;
	parms.SearchCase = SearchCase;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetStringLibrary::Len(struct FString S){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Len");

	FLen parms{};	
	parms.S = S;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::LeftPad(struct FString SourceString, int32_t ChCount){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.LeftPad");

	FLeftPad parms{};	
	parms.SourceString = SourceString;
	parms.ChCount = ChCount;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::LeftChop(struct FString SourceString, int32_t Count){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.LeftChop");

	FLeftChop parms{};	
	parms.SourceString = SourceString;
	parms.Count = Count;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::Left(struct FString SourceString, int32_t Count){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Left");

	FLeft parms{};	
	parms.SourceString = SourceString;
	parms.Count = Count;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::JoinStringArray(struct TArray<struct FString>& SourceArray, struct FString Separator){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.JoinStringArray");

	FJoinStringArray parms{};	
	parms.SourceArray = SourceArray;
	parms.Separator = Separator;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetStringLibrary::IsNumeric(struct FString SourceString){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.IsNumeric");

	FIsNumeric parms{};	
	parms.SourceString = SourceString;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetStringLibrary::IsEmpty(struct FString InString){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.IsEmpty");

	FIsEmpty parms{};	
	parms.InString = InString;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::GetSubstring(struct FString SourceString, int32_t StartIndex, int32_t Length){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.GetSubstring");

	FGetSubstring parms{};	
	parms.SourceString = SourceString;
	parms.StartIndex = StartIndex;
	parms.Length = Length;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetStringLibrary::GetCharacterAsNumber(struct FString SourceString, int32_t Index){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.GetCharacterAsNumber");

	FGetCharacterAsNumber parms{};	
	parms.SourceString = SourceString;
	parms.Index = Index;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<struct FString> UKismetStringLibrary::GetCharacterArrayFromString(struct FString SourceString){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.GetCharacterArrayFromString");

	FGetCharacterArrayFromString parms{};	
	parms.SourceString = SourceString;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetStringLibrary::FindSubstring(struct FString SearchIn, struct FString Substring, bool bUseCase, bool bSearchFromEnd, int32_t StartPosition){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.FindSubstring");

	FFindSubstring parms{};	
	parms.SearchIn = SearchIn;
	parms.Substring = Substring;
	parms.bUseCase = bUseCase;
	parms.bSearchFromEnd = bSearchFromEnd;
	parms.StartPosition = StartPosition;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetStringLibrary::EqualEqual_StrStr(struct FString A, struct FString B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.EqualEqual_StrStr");

	FEqualEqual_StrStr parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetStringLibrary::EqualEqual_StriStri(struct FString A, struct FString B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.EqualEqual_StriStri");

	FEqualEqual_StriStri parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetStringLibrary::EndsWith(struct FString SourceString, struct FString InSuffix, enum class ESearchCase SearchCase){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.EndsWith");

	FEndsWith parms{};	
	parms.SourceString = SourceString;
	parms.InSuffix = InSuffix;
	parms.SearchCase = SearchCase;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetStringLibrary::CullArray(struct FString SourceString, struct TArray<struct FString>& inArray){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.CullArray");

	FCullArray parms{};	
	parms.SourceString = SourceString;
	parms.inArray = inArray;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::Conv_VectorToString(struct FVector InVec){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_VectorToString");

	FConv_VectorToString parms{};	
	parms.InVec = InVec;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::Conv_Vector3fToString(struct FVector3f InVec){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_Vector3fToString");

	FConv_Vector3fToString parms{};	
	parms.InVec = InVec;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::Conv_Vector2dToString(struct FVector2D InVec){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_Vector2dToString");

	FConv_Vector2dToString parms{};	
	parms.InVec = InVec;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::Conv_TransformToString(struct FTransform& InTrans){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_TransformToString");

	FConv_TransformToString parms{};	
	parms.InTrans = InTrans;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetStringLibrary::Conv_StringToVector3f(struct FString InString, struct FVector3f& OutConvertedVector, bool& OutIsValid){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_StringToVector3f");

	FConv_StringToVector3f parms{};	
	parms.InString = InString;
	parms.OutConvertedVector = OutConvertedVector;
	parms.OutIsValid = OutIsValid;

	ProcessEvent(fn, &parms);
}

void UKismetStringLibrary::Conv_StringToVector2D(struct FString InString, struct FVector2D& OutConvertedVector2D, bool& OutIsValid){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_StringToVector2D");

	FConv_StringToVector2D parms{};	
	parms.InString = InString;
	parms.OutConvertedVector2D = OutConvertedVector2D;
	parms.OutIsValid = OutIsValid;

	ProcessEvent(fn, &parms);
}

void UKismetStringLibrary::Conv_StringToVector(struct FString InString, struct FVector& OutConvertedVector, bool& OutIsValid){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_StringToVector");

	FConv_StringToVector parms{};	
	parms.InString = InString;
	parms.OutConvertedVector = OutConvertedVector;
	parms.OutIsValid = OutIsValid;

	ProcessEvent(fn, &parms);
}

void UKismetStringLibrary::Conv_StringToRotator(struct FString InString, struct FRotator& OutConvertedRotator, bool& OutIsValid){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_StringToRotator");

	FConv_StringToRotator parms{};	
	parms.InString = InString;
	parms.OutConvertedRotator = OutConvertedRotator;
	parms.OutIsValid = OutIsValid;

	ProcessEvent(fn, &parms);
}

struct FName UKismetStringLibrary::Conv_StringToName(struct FString InString){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_StringToName");

	FConv_StringToName parms{};	
	parms.InString = InString;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int64_t UKismetStringLibrary::Conv_StringToInt64(struct FString InString){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_StringToInt64");

	FConv_StringToInt64 parms{};	
	parms.InString = InString;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetStringLibrary::Conv_StringToInt(struct FString InString){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_StringToInt");

	FConv_StringToInt parms{};	
	parms.InString = InString;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetStringLibrary::Conv_StringToDouble(struct FString InString){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_StringToDouble");

	FConv_StringToDouble parms{};	
	parms.InString = InString;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetStringLibrary::Conv_StringToColor(struct FString InString, struct FLinearColor& OutConvertedColor, bool& OutIsValid){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_StringToColor");

	FConv_StringToColor parms{};	
	parms.InString = InString;
	parms.OutConvertedColor = OutConvertedColor;
	parms.OutIsValid = OutIsValid;

	ProcessEvent(fn, &parms);
}

struct FString UKismetStringLibrary::Conv_RotatorToString(struct FRotator InRot){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_RotatorToString");

	FConv_RotatorToString parms{};	
	parms.InRot = InRot;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::Conv_PlatformUserIdToString(struct FPlatformUserId InPlatformUserId){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_PlatformUserIdToString");

	FConv_PlatformUserIdToString parms{};	
	parms.InPlatformUserId = InPlatformUserId;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::Conv_ObjectToString(struct UObject* InObj){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_ObjectToString");

	FConv_ObjectToString parms{};	
	parms.InObj = InObj;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::Conv_NameToString(struct FName InName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_NameToString");

	FConv_NameToString parms{};	
	parms.InName = InName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::Conv_MatrixToString(struct FMatrix& InMatrix){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_MatrixToString");

	FConv_MatrixToString parms{};	
	parms.InMatrix = InMatrix;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::Conv_IntVectorToString(struct FIntVector InIntVec){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_IntVectorToString");

	FConv_IntVectorToString parms{};	
	parms.InIntVec = InIntVec;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::Conv_IntToString(int32_t inInt){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_IntToString");

	FConv_IntToString parms{};	
	parms.inInt = inInt;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::Conv_IntPointToString(struct FIntPoint InIntPoint){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_IntPointToString");

	FConv_IntPointToString parms{};	
	parms.InIntPoint = InIntPoint;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::Conv_Int64ToString(int64_t inInt){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_Int64ToString");

	FConv_Int64ToString parms{};	
	parms.inInt = inInt;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::Conv_InputDeviceIdToString(struct FInputDeviceId InDeviceID){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_InputDeviceIdToString");

	FConv_InputDeviceIdToString parms{};	
	parms.InDeviceID = InDeviceID;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::Conv_DoubleToString(double InDouble){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_DoubleToString");

	FConv_DoubleToString parms{};	
	parms.InDouble = InDouble;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::Conv_ColorToString(struct FLinearColor InColor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_ColorToString");

	FConv_ColorToString parms{};	
	parms.InColor = InColor;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::Conv_ByteToString(char InByte){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_ByteToString");

	FConv_ByteToString parms{};	
	parms.InByte = InByte;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::Conv_BoolToString(bool InBool){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_BoolToString");

	FConv_BoolToString parms{};	
	parms.InBool = InBool;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetStringLibrary::Contains(struct FString SearchIn, struct FString Substring, bool bUseCase, bool bSearchFromEnd){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Contains");

	FContains parms{};	
	parms.SearchIn = SearchIn;
	parms.Substring = Substring;
	parms.bUseCase = bUseCase;
	parms.bSearchFromEnd = bSearchFromEnd;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::Concat_StrStr(struct FString A, struct FString B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Concat_StrStr");

	FConcat_StrStr parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::BuildString_Vector2d(struct FString AppendTo, struct FString Prefix, struct FVector2D InVector2D, struct FString Suffix){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Vector2d");

	FBuildString_Vector2d parms{};	
	parms.AppendTo = AppendTo;
	parms.Prefix = Prefix;
	parms.InVector2D = InVector2D;
	parms.Suffix = Suffix;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::BuildString_Vector(struct FString AppendTo, struct FString Prefix, struct FVector InVector, struct FString Suffix){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Vector");

	FBuildString_Vector parms{};	
	parms.AppendTo = AppendTo;
	parms.Prefix = Prefix;
	parms.InVector = InVector;
	parms.Suffix = Suffix;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::BuildString_Rotator(struct FString AppendTo, struct FString Prefix, struct FRotator InRot, struct FString Suffix){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Rotator");

	FBuildString_Rotator parms{};	
	parms.AppendTo = AppendTo;
	parms.Prefix = Prefix;
	parms.InRot = InRot;
	parms.Suffix = Suffix;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::BuildString_Object(struct FString AppendTo, struct FString Prefix, struct UObject* InObj, struct FString Suffix){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Object");

	FBuildString_Object parms{};	
	parms.AppendTo = AppendTo;
	parms.Prefix = Prefix;
	parms.InObj = InObj;
	parms.Suffix = Suffix;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::BuildString_Name(struct FString AppendTo, struct FString Prefix, struct FName InName, struct FString Suffix){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Name");

	FBuildString_Name parms{};	
	parms.AppendTo = AppendTo;
	parms.Prefix = Prefix;
	parms.InName = InName;
	parms.Suffix = Suffix;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::BuildString_IntVector(struct FString AppendTo, struct FString Prefix, struct FIntVector InIntVector, struct FString Suffix){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_IntVector");

	FBuildString_IntVector parms{};	
	parms.AppendTo = AppendTo;
	parms.Prefix = Prefix;
	parms.InIntVector = InIntVector;
	parms.Suffix = Suffix;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::BuildString_Int(struct FString AppendTo, struct FString Prefix, int32_t inInt, struct FString Suffix){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Int");

	FBuildString_Int parms{};	
	parms.AppendTo = AppendTo;
	parms.Prefix = Prefix;
	parms.inInt = inInt;
	parms.Suffix = Suffix;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::BuildString_Double(struct FString AppendTo, struct FString Prefix, double InDouble, struct FString Suffix){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Double");

	FBuildString_Double parms{};	
	parms.AppendTo = AppendTo;
	parms.Prefix = Prefix;
	parms.InDouble = InDouble;
	parms.Suffix = Suffix;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::BuildString_Color(struct FString AppendTo, struct FString Prefix, struct FLinearColor InColor, struct FString Suffix){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Color");

	FBuildString_Color parms{};	
	parms.AppendTo = AppendTo;
	parms.Prefix = Prefix;
	parms.InColor = InColor;
	parms.Suffix = Suffix;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringLibrary::BuildString_Bool(struct FString AppendTo, struct FString Prefix, bool InBool, struct FString Suffix){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Bool");

	FBuildString_Bool parms{};	
	parms.AppendTo = AppendTo;
	parms.Prefix = Prefix;
	parms.InBool = InBool;
	parms.Suffix = Suffix;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimDataModel::IsValidBoneTrackIndex(int32_t TrackIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimDataModel.IsValidBoneTrackIndex");

	FIsValidBoneTrackIndex parms{};	
	parms.TrackIndex = TrackIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UAnimDataModel::GetPlayLength(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimDataModel.GetPlayLength");

	FGetPlayLength parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UAnimDataModel::GetNumBoneTracks(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimDataModel.GetNumBoneTracks");

	FGetNumBoneTracks parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UAnimDataModel::GetNumberOfTransformCurves(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimDataModel.GetNumberOfTransformCurves");

	FGetNumberOfTransformCurves parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UAnimDataModel::GetNumberOfKeys(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimDataModel.GetNumberOfKeys");

	FGetNumberOfKeys parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UAnimDataModel::GetNumberOfFrames(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimDataModel.GetNumberOfFrames");

	FGetNumberOfFrames parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UAnimDataModel::GetNumberOfFloatCurves(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimDataModel.GetNumberOfFloatCurves");

	FGetNumberOfFloatCurves parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FFrameRate UAnimDataModel::GetFrameRate(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimDataModel.GetFrameRate");

	FGetFrameRate parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UAnimDataModel::GetBoneTrackNames(struct TArray<struct FName>& OutNames){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimDataModel.GetBoneTrackNames");

	FGetBoneTrackNames parms{};	
	parms.OutNames = OutNames;

	ProcessEvent(fn, &parms);
}

int32_t UAnimDataModel::GetBoneTrackIndexByName(struct FName TrackName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimDataModel.GetBoneTrackIndexByName");

	FGetBoneTrackIndexByName parms{};	
	parms.TrackName = TrackName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UAnimDataModel::GetBoneTrackIndex(struct FBoneAnimationTrack& Track){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimDataModel.GetBoneTrackIndex");

	FGetBoneTrackIndex parms{};	
	parms.Track = Track;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FBoneAnimationTrack UAnimDataModel::GetBoneTrackByName(struct FName TrackName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimDataModel.GetBoneTrackByName");

	FGetBoneTrackByName parms{};	
	parms.TrackName = TrackName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FBoneAnimationTrack UAnimDataModel::GetBoneTrackByIndex(int32_t TrackIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimDataModel.GetBoneTrackByIndex");

	FGetBoneTrackByIndex parms{};	
	parms.TrackIndex = TrackIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<struct FBoneAnimationTrack> UAnimDataModel::GetBoneAnimationTracks(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimDataModel.GetBoneAnimationTracks");

	FGetBoneAnimationTracks parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UAnimSequence* UAnimDataModel::GetAnimationSequence(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimDataModel.GetAnimationSequence");

	FGetAnimationSequence parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void USoundEffectPresetWidgetInterface::OnPropertyChanged(struct USoundEffectPreset* Preset, struct FName PropertyName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SoundEffectPresetWidgetInterface.OnPropertyChanged");

	FOnPropertyChanged parms{};	
	parms.Preset = Preset;
	parms.PropertyName = PropertyName;

	ProcessEvent(fn, &parms);
}

void USoundEffectPresetWidgetInterface::OnConstructed(struct USoundEffectPreset* Preset){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SoundEffectPresetWidgetInterface.OnConstructed");

	FOnConstructed parms{};	
	parms.Preset = Preset;

	ProcessEvent(fn, &parms);
}

USoundEffectPreset* USoundEffectPresetWidgetInterface::GetClass(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SoundEffectPresetWidgetInterface.GetClass");

	FGetClass parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetMaterialLibrary::SetVectorParameterValue(struct UObject* WorldContextObject, struct UMaterialParameterCollection* Collection, struct FName ParameterName, struct FLinearColor& ParameterValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMaterialLibrary.SetVectorParameterValue");

	FSetVectorParameterValue parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Collection = Collection;
	parms.ParameterName = ParameterName;
	parms.ParameterValue = ParameterValue;

	ProcessEvent(fn, &parms);
}

void UKismetMaterialLibrary::SetScalarParameterValue(struct UObject* WorldContextObject, struct UMaterialParameterCollection* Collection, struct FName ParameterName, float ParameterValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMaterialLibrary.SetScalarParameterValue");

	FSetScalarParameterValue parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Collection = Collection;
	parms.ParameterName = ParameterName;
	parms.ParameterValue = ParameterValue;

	ProcessEvent(fn, &parms);
}

struct FLinearColor UKismetMaterialLibrary::GetVectorParameterValue(struct UObject* WorldContextObject, struct UMaterialParameterCollection* Collection, struct FName ParameterName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMaterialLibrary.GetVectorParameterValue");

	FGetVectorParameterValue parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Collection = Collection;
	parms.ParameterName = ParameterName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetMaterialLibrary::GetScalarParameterValue(struct UObject* WorldContextObject, struct UMaterialParameterCollection* Collection, struct FName ParameterName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMaterialLibrary.GetScalarParameterValue");

	FGetScalarParameterValue parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Collection = Collection;
	parms.ParameterName = ParameterName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UMaterialInstanceDynamic* UKismetMaterialLibrary::CreateDynamicMaterialInstance(struct UObject* WorldContextObject, struct UMaterialInterface* Parent, struct FName OptionalName, uint8_t CreationFlags){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMaterialLibrary.CreateDynamicMaterialInstance");

	FCreateDynamicMaterialInstance parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Parent = Parent;
	parms.OptionalName = OptionalName;
	parms.CreationFlags = CreationFlags;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FLinearColor UCurveLinearColor::GetUnadjustedLinearColorValue(float InTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CurveLinearColor.GetUnadjustedLinearColorValue");

	FGetUnadjustedLinearColorValue parms{};	
	parms.InTime = InTime;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FLinearColor UCurveLinearColor::GetLinearColorValue(float InTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CurveLinearColor.GetLinearColorValue");

	FGetLinearColorValue parms{};	
	parms.InTime = InTime;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FLinearColor UCurveLinearColor::GetClampedLinearColorValue(float InTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CurveLinearColor.GetClampedLinearColorValue");

	FGetClampedLinearColorValue parms{};	
	parms.InTime = InTime;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetArrayLibrary::SetArrayPropertyByName(struct UObject* Object, struct FName PropertyName, struct TArray<int32_t>& Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.SetArrayPropertyByName");

	FSetArrayPropertyByName parms{};	
	parms.Object = Object;
	parms.PropertyName = PropertyName;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UKismetArrayLibrary::FilterArray(struct TArray<struct AActor*>& TargetArray, AActor* FilterClass, struct TArray<struct AActor*>& FilteredArray){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.FilterArray");

	FFilterArray parms{};	
	parms.TargetArray = TargetArray;
	parms.FilterClass = FilterClass;
	parms.FilteredArray = FilteredArray;

	ProcessEvent(fn, &parms);
}

void UKismetArrayLibrary::Array_Swap(struct TArray<int32_t>& TargetArray, int32_t FirstIndex, int32_t SecondIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Swap");

	FArray_Swap parms{};	
	parms.TargetArray = TargetArray;
	parms.FirstIndex = FirstIndex;
	parms.SecondIndex = SecondIndex;

	ProcessEvent(fn, &parms);
}

void UKismetArrayLibrary::Array_Shuffle(struct TArray<int32_t>& TargetArray){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Shuffle");

	FArray_Shuffle parms{};	
	parms.TargetArray = TargetArray;

	ProcessEvent(fn, &parms);
}

void UKismetArrayLibrary::Array_Set(struct TArray<int32_t>& TargetArray, int32_t Index, int32_t& Item, bool bSizeToFit){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Set");

	FArray_Set parms{};	
	parms.TargetArray = TargetArray;
	parms.Index = Index;
	parms.Item = Item;
	parms.bSizeToFit = bSizeToFit;

	ProcessEvent(fn, &parms);
}

void UKismetArrayLibrary::Array_Reverse(struct TArray<int32_t>& TargetArray){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Reverse");

	FArray_Reverse parms{};	
	parms.TargetArray = TargetArray;

	ProcessEvent(fn, &parms);
}

void UKismetArrayLibrary::Array_Resize(struct TArray<int32_t>& TargetArray, int32_t Size){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Resize");

	FArray_Resize parms{};	
	parms.TargetArray = TargetArray;
	parms.Size = Size;

	ProcessEvent(fn, &parms);
}

bool UKismetArrayLibrary::Array_RemoveItem(struct TArray<int32_t>& TargetArray, int32_t& Item){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_RemoveItem");

	FArray_RemoveItem parms{};	
	parms.TargetArray = TargetArray;
	parms.Item = Item;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetArrayLibrary::Array_Remove(struct TArray<int32_t>& TargetArray, int32_t IndexToRemove){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Remove");

	FArray_Remove parms{};	
	parms.TargetArray = TargetArray;
	parms.IndexToRemove = IndexToRemove;

	ProcessEvent(fn, &parms);
}

void UKismetArrayLibrary::Array_RandomFromStream(struct TArray<int32_t>& TargetArray, struct FRandomStream& RandomStream, int32_t& OutItem, int32_t& OutIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_RandomFromStream");

	FArray_RandomFromStream parms{};	
	parms.TargetArray = TargetArray;
	parms.RandomStream = RandomStream;
	parms.OutItem = OutItem;
	parms.OutIndex = OutIndex;

	ProcessEvent(fn, &parms);
}

void UKismetArrayLibrary::Array_Random(struct TArray<int32_t>& TargetArray, int32_t& OutItem, int32_t& OutIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Random");

	FArray_Random parms{};	
	parms.TargetArray = TargetArray;
	parms.OutItem = OutItem;
	parms.OutIndex = OutIndex;

	ProcessEvent(fn, &parms);
}

int32_t UKismetArrayLibrary::Array_Length(struct TArray<int32_t>& TargetArray){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Length");

	FArray_Length parms{};	
	parms.TargetArray = TargetArray;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetArrayLibrary::Array_LastIndex(struct TArray<int32_t>& TargetArray){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_LastIndex");

	FArray_LastIndex parms{};	
	parms.TargetArray = TargetArray;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetArrayLibrary::Array_IsValidIndex(struct TArray<int32_t>& TargetArray, int32_t IndexToTest){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_IsValidIndex");

	FArray_IsValidIndex parms{};	
	parms.TargetArray = TargetArray;
	parms.IndexToTest = IndexToTest;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetArrayLibrary::Array_IsNotEmpty(struct TArray<int32_t>& TargetArray){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_IsNotEmpty");

	FArray_IsNotEmpty parms{};	
	parms.TargetArray = TargetArray;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetArrayLibrary::Array_IsEmpty(struct TArray<int32_t>& TargetArray){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_IsEmpty");

	FArray_IsEmpty parms{};	
	parms.TargetArray = TargetArray;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetArrayLibrary::Array_Insert(struct TArray<int32_t>& TargetArray, int32_t& NewItem, int32_t Index){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Insert");

	FArray_Insert parms{};	
	parms.TargetArray = TargetArray;
	parms.NewItem = NewItem;
	parms.Index = Index;

	ProcessEvent(fn, &parms);
}

bool UKismetArrayLibrary::Array_Identical(struct TArray<int32_t>& ArrayA, struct TArray<int32_t>& ArrayB){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Identical");

	FArray_Identical parms{};	
	parms.ArrayA = ArrayA;
	parms.ArrayB = ArrayB;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetArrayLibrary::Array_Get(struct TArray<int32_t>& TargetArray, int32_t Index, int32_t& Item){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Get");

	FArray_Get parms{};	
	parms.TargetArray = TargetArray;
	parms.Index = Index;
	parms.Item = Item;

	ProcessEvent(fn, &parms);
}

int32_t UKismetArrayLibrary::Array_Find(struct TArray<int32_t>& TargetArray, int32_t& ItemToFind){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Find");

	FArray_Find parms{};	
	parms.TargetArray = TargetArray;
	parms.ItemToFind = ItemToFind;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetArrayLibrary::Array_Contains(struct TArray<int32_t>& TargetArray, int32_t& ItemToFind){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Contains");

	FArray_Contains parms{};	
	parms.TargetArray = TargetArray;
	parms.ItemToFind = ItemToFind;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetArrayLibrary::Array_Clear(struct TArray<int32_t>& TargetArray){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Clear");

	FArray_Clear parms{};	
	parms.TargetArray = TargetArray;

	ProcessEvent(fn, &parms);
}

void UKismetArrayLibrary::Array_Append(struct TArray<int32_t>& TargetArray, struct TArray<int32_t>& SourceArray){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Append");

	FArray_Append parms{};	
	parms.TargetArray = TargetArray;
	parms.SourceArray = SourceArray;

	ProcessEvent(fn, &parms);
}

int32_t UKismetArrayLibrary::Array_AddUnique(struct TArray<int32_t>& TargetArray, int32_t& NewItem){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_AddUnique");

	FArray_AddUnique parms{};	
	parms.TargetArray = TargetArray;
	parms.NewItem = NewItem;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetArrayLibrary::Array_Add(struct TArray<int32_t>& TargetArray, int32_t& NewItem){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Add");

	FArray_Add parms{};	
	parms.TargetArray = TargetArray;
	parms.NewItem = NewItem;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UArrowComponent::SetArrowColor(struct FLinearColor NewColor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ArrowComponent.SetArrowColor");

	FSetArrowColor parms{};	
	parms.NewColor = NewColor;

	ProcessEvent(fn, &parms);
}

struct TArray<struct FScriptTypedElementHandle> UTypedElementCommonActions::K2_DuplicateSelectedElements(struct UTypedElementSelectionSet* SelectionSet, struct UWorld* World, struct FVector& LocationOffset){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TypedElementCommonActions.K2_DuplicateSelectedElements");

	FK2_DuplicateSelectedElements parms{};	
	parms.SelectionSet = SelectionSet;
	parms.World = World;
	parms.LocationOffset = LocationOffset;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<struct FScriptTypedElementHandle> UTypedElementCommonActions::DuplicateNormalizedElements(struct FScriptTypedElementListProxy ElementList, struct UWorld* World, struct FVector& LocationOffset){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TypedElementCommonActions.DuplicateNormalizedElements");

	FDuplicateNormalizedElements parms{};	
	parms.ElementList = ElementList;
	parms.World = World;
	parms.LocationOffset = LocationOffset;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UTypedElementCommonActions::DeleteSelectedElements(struct UTypedElementSelectionSet* SelectionSet, struct UWorld* World, struct FTypedElementDeletionOptions& DeletionOptions){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TypedElementCommonActions.DeleteSelectedElements");

	FDeleteSelectedElements parms{};	
	parms.SelectionSet = SelectionSet;
	parms.World = World;
	parms.DeletionOptions = DeletionOptions;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UTypedElementCommonActions::DeleteNormalizedElements(struct FScriptTypedElementListProxy ElementList, struct UWorld* World, struct UTypedElementSelectionSet* InSelectionSet, struct FTypedElementDeletionOptions& DeletionOptions){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TypedElementCommonActions.DeleteNormalizedElements");

	FDeleteNormalizedElements parms{};	
	parms.ElementList = ElementList;
	parms.World = World;
	parms.InSelectionSet = InSelectionSet;
	parms.DeletionOptions = DeletionOptions;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UCanvasRenderTarget2D::UpdateResource(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CanvasRenderTarget2D.UpdateResource");

	FUpdateResource parms{};	

	ProcessEvent(fn, &parms);
}

void UCanvasRenderTarget2D::ReceiveUpdate(struct UCanvas* Canvas, int32_t Width, int32_t Height){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CanvasRenderTarget2D.ReceiveUpdate");

	FReceiveUpdate parms{};	
	parms.Canvas = Canvas;
	parms.Width = Width;
	parms.Height = Height;

	ProcessEvent(fn, &parms);
}

void UCanvasRenderTarget2D::GetSize(int32_t& Width, int32_t& Height){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CanvasRenderTarget2D.GetSize");

	FGetSize parms{};	
	parms.Width = Width;
	parms.Height = Height;

	ProcessEvent(fn, &parms);
}

struct UCanvasRenderTarget2D* UCanvasRenderTarget2D::CreateCanvasRenderTarget2D(struct UObject* WorldContextObject, UCanvasRenderTarget2D* CanvasRenderTarget2DClass, int32_t Width, int32_t Height){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CanvasRenderTarget2D.CreateCanvasRenderTarget2D");

	FCreateCanvasRenderTarget2D parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.CanvasRenderTarget2DClass = CanvasRenderTarget2DClass;
	parms.Width = Width;
	parms.Height = Height;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UTimelineComponent::Stop(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TimelineComponent.Stop");

	FStop parms{};	

	ProcessEvent(fn, &parms);
}

void UTimelineComponent::SetVectorCurve(struct UCurveVector* NewVectorCurve, struct FName VectorTrackName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetVectorCurve");

	FSetVectorCurve parms{};	
	parms.NewVectorCurve = NewVectorCurve;
	parms.VectorTrackName = VectorTrackName;

	ProcessEvent(fn, &parms);
}

void UTimelineComponent::SetTimelineLengthMode(enum class ETimelineLengthMode NewLengthMode){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetTimelineLengthMode");

	FSetTimelineLengthMode parms{};	
	parms.NewLengthMode = NewLengthMode;

	ProcessEvent(fn, &parms);
}

void UTimelineComponent::SetTimelineLength(float NewLength){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetTimelineLength");

	FSetTimelineLength parms{};	
	parms.NewLength = NewLength;

	ProcessEvent(fn, &parms);
}

void UTimelineComponent::SetPlayRate(float NewRate){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetPlayRate");

	FSetPlayRate parms{};	
	parms.NewRate = NewRate;

	ProcessEvent(fn, &parms);
}

void UTimelineComponent::SetPlaybackPosition(float NewPosition, bool bFireEvents, bool bFireUpdate){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetPlaybackPosition");

	FSetPlaybackPosition parms{};	
	parms.NewPosition = NewPosition;
	parms.bFireEvents = bFireEvents;
	parms.bFireUpdate = bFireUpdate;

	ProcessEvent(fn, &parms);
}

void UTimelineComponent::SetNewTime(float NewTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetNewTime");

	FSetNewTime parms{};	
	parms.NewTime = NewTime;

	ProcessEvent(fn, &parms);
}

void UTimelineComponent::SetLooping(bool bNewLooping){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetLooping");

	FSetLooping parms{};	
	parms.bNewLooping = bNewLooping;

	ProcessEvent(fn, &parms);
}

void UTimelineComponent::SetLinearColorCurve(struct UCurveLinearColor* NewLinearColorCurve, struct FName LinearColorTrackName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetLinearColorCurve");

	FSetLinearColorCurve parms{};	
	parms.NewLinearColorCurve = NewLinearColorCurve;
	parms.LinearColorTrackName = LinearColorTrackName;

	ProcessEvent(fn, &parms);
}

void UTimelineComponent::SetIgnoreTimeDilation(bool bNewIgnoreTimeDilation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetIgnoreTimeDilation");

	FSetIgnoreTimeDilation parms{};	
	parms.bNewIgnoreTimeDilation = bNewIgnoreTimeDilation;

	ProcessEvent(fn, &parms);
}

void UTimelineComponent::SetFloatCurve(struct UCurveFloat* NewFloatCurve, struct FName FloatTrackName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetFloatCurve");

	FSetFloatCurve parms{};	
	parms.NewFloatCurve = NewFloatCurve;
	parms.FloatTrackName = FloatTrackName;

	ProcessEvent(fn, &parms);
}

void UTimelineComponent::ReverseFromEnd(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TimelineComponent.ReverseFromEnd");

	FReverseFromEnd parms{};	

	ProcessEvent(fn, &parms);
}

void UTimelineComponent::Reverse(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TimelineComponent.Reverse");

	FReverse parms{};	

	ProcessEvent(fn, &parms);
}

void UTimelineComponent::PlayFromStart(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TimelineComponent.PlayFromStart");

	FPlayFromStart parms{};	

	ProcessEvent(fn, &parms);
}

void UTimelineComponent::Play(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TimelineComponent.Play");

	FPlay parms{};	

	ProcessEvent(fn, &parms);
}

void UTimelineComponent::OnRep_Timeline(struct FTimeline& OldTimeline){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TimelineComponent.OnRep_Timeline");

	FOnRep_Timeline parms{};	
	parms.OldTimeline = OldTimeline;

	ProcessEvent(fn, &parms);
}

bool UTimelineComponent::IsReversing(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TimelineComponent.IsReversing");

	FIsReversing parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UTimelineComponent::IsPlaying(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TimelineComponent.IsPlaying");

	FIsPlaying parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UTimelineComponent::IsLooping(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TimelineComponent.IsLooping");

	FIsLooping parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UTimelineComponent::GetTimelineLength(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TimelineComponent.GetTimelineLength");

	FGetTimelineLength parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UTimelineComponent::GetScaledTimelineLength(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TimelineComponent.GetScaledTimelineLength");

	FGetScaledTimelineLength parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UTimelineComponent::GetPlayRate(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TimelineComponent.GetPlayRate");

	FGetPlayRate parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UTimelineComponent::GetPlaybackPosition(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TimelineComponent.GetPlaybackPosition");

	FGetPlaybackPosition parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UTimelineComponent::GetIgnoreTimeDilation(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TimelineComponent.GetIgnoreTimeDilation");

	FGetIgnoreTimeDilation parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UBlendProfile* USkeleton::GetBlendProfile(struct FName& InProfileName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Skeleton.GetBlendProfile");

	FGetBlendProfile parms{};	
	parms.InProfileName = InProfileName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void USkeleton::AddCompatibleSkeleton(struct USkeleton* SourceSkeleton){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Skeleton.AddCompatibleSkeleton");

	FAddCompatibleSkeleton parms{};	
	parms.SourceSkeleton = SourceSkeleton;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::SetProjectionParams(struct FConstraintInstanceAccessor& Accessor, bool bEnableProjection, float ProjectionLinearAlpha, float ProjectionAngularAlpha){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.SetProjectionParams");

	FSetProjectionParams parms{};	
	parms.Accessor = Accessor;
	parms.bEnableProjection = bEnableProjection;
	parms.ProjectionLinearAlpha = ProjectionLinearAlpha;
	parms.ProjectionAngularAlpha = ProjectionAngularAlpha;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::SetParentDominates(struct FConstraintInstanceAccessor& Accessor, bool bParentDominates){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.SetParentDominates");

	FSetParentDominates parms{};	
	parms.Accessor = Accessor;
	parms.bParentDominates = bParentDominates;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::SetOrientationDriveTwistAndSwing(struct FConstraintInstanceAccessor& Accessor, bool bEnableTwistDrive, bool bEnableSwingDrive){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.SetOrientationDriveTwistAndSwing");

	FSetOrientationDriveTwistAndSwing parms{};	
	parms.Accessor = Accessor;
	parms.bEnableTwistDrive = bEnableTwistDrive;
	parms.bEnableSwingDrive = bEnableSwingDrive;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::SetOrientationDriveSLERP(struct FConstraintInstanceAccessor& Accessor, bool bEnableSLERP){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.SetOrientationDriveSLERP");

	FSetOrientationDriveSLERP parms{};	
	parms.Accessor = Accessor;
	parms.bEnableSLERP = bEnableSLERP;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::SetLinearVelocityTarget(struct FConstraintInstanceAccessor& Accessor, struct FVector& InVelTarget){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.SetLinearVelocityTarget");

	FSetLinearVelocityTarget parms{};	
	parms.Accessor = Accessor;
	parms.InVelTarget = InVelTarget;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::SetLinearVelocityDrive(struct FConstraintInstanceAccessor& Accessor, bool bEnableDriveX, bool bEnableDriveY, bool bEnableDriveZ){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.SetLinearVelocityDrive");

	FSetLinearVelocityDrive parms{};	
	parms.Accessor = Accessor;
	parms.bEnableDriveX = bEnableDriveX;
	parms.bEnableDriveY = bEnableDriveY;
	parms.bEnableDriveZ = bEnableDriveZ;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::SetLinearSoftLimitParams(struct FConstraintInstanceAccessor& Accessor, bool bSoftLinearLimit, float LinearLimitStiffness, float LinearLimitDamping, float LinearLimitRestitution, float LinearLimitContactDistance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.SetLinearSoftLimitParams");

	FSetLinearSoftLimitParams parms{};	
	parms.Accessor = Accessor;
	parms.bSoftLinearLimit = bSoftLinearLimit;
	parms.LinearLimitStiffness = LinearLimitStiffness;
	parms.LinearLimitDamping = LinearLimitDamping;
	parms.LinearLimitRestitution = LinearLimitRestitution;
	parms.LinearLimitContactDistance = LinearLimitContactDistance;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::SetLinearPositionTarget(struct FConstraintInstanceAccessor& Accessor, struct FVector& InPosTarget){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.SetLinearPositionTarget");

	FSetLinearPositionTarget parms{};	
	parms.Accessor = Accessor;
	parms.InPosTarget = InPosTarget;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::SetLinearPositionDrive(struct FConstraintInstanceAccessor& Accessor, bool bEnableDriveX, bool bEnableDriveY, bool bEnableDriveZ){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.SetLinearPositionDrive");

	FSetLinearPositionDrive parms{};	
	parms.Accessor = Accessor;
	parms.bEnableDriveX = bEnableDriveX;
	parms.bEnableDriveY = bEnableDriveY;
	parms.bEnableDriveZ = bEnableDriveZ;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::SetLinearPlasticity(struct FConstraintInstanceAccessor& Accessor, bool bLinearPlasticity, float LinearPlasticityThreshold, enum class EConstraintPlasticityType PlasticityType){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.SetLinearPlasticity");

	FSetLinearPlasticity parms{};	
	parms.Accessor = Accessor;
	parms.bLinearPlasticity = bLinearPlasticity;
	parms.LinearPlasticityThreshold = LinearPlasticityThreshold;
	parms.PlasticityType = PlasticityType;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::SetLinearLimits(struct FConstraintInstanceAccessor& Accessor, enum class ELinearConstraintMotion XMotion, enum class ELinearConstraintMotion YMotion, enum class ELinearConstraintMotion ZMotion, float Limit){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.SetLinearLimits");

	FSetLinearLimits parms{};	
	parms.Accessor = Accessor;
	parms.XMotion = XMotion;
	parms.YMotion = YMotion;
	parms.ZMotion = ZMotion;
	parms.Limit = Limit;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::SetLinearDriveParams(struct FConstraintInstanceAccessor& Accessor, float PositionStrength, float VelocityStrength, float InForceLimit){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.SetLinearDriveParams");

	FSetLinearDriveParams parms{};	
	parms.Accessor = Accessor;
	parms.PositionStrength = PositionStrength;
	parms.VelocityStrength = VelocityStrength;
	parms.InForceLimit = InForceLimit;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::SetLinearBreakable(struct FConstraintInstanceAccessor& Accessor, bool bLinearBreakable, float LinearBreakThreshold){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.SetLinearBreakable");

	FSetLinearBreakable parms{};	
	parms.Accessor = Accessor;
	parms.bLinearBreakable = bLinearBreakable;
	parms.LinearBreakThreshold = LinearBreakThreshold;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::SetDisableCollision(struct FConstraintInstanceAccessor& Accessor, bool bDisableCollision){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.SetDisableCollision");

	FSetDisableCollision parms{};	
	parms.Accessor = Accessor;
	parms.bDisableCollision = bDisableCollision;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::SetContactTransferScale(struct FConstraintInstanceAccessor& Accessor, float ContactTransferScale){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.SetContactTransferScale");

	FSetContactTransferScale parms{};	
	parms.Accessor = Accessor;
	parms.ContactTransferScale = ContactTransferScale;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::SetAngularVelocityTarget(struct FConstraintInstanceAccessor& Accessor, struct FVector& InVelTarget){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.SetAngularVelocityTarget");

	FSetAngularVelocityTarget parms{};	
	parms.Accessor = Accessor;
	parms.InVelTarget = InVelTarget;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::SetAngularVelocityDriveTwistAndSwing(struct FConstraintInstanceAccessor& Accessor, bool bEnableTwistDrive, bool bEnableSwingDrive){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.SetAngularVelocityDriveTwistAndSwing");

	FSetAngularVelocityDriveTwistAndSwing parms{};	
	parms.Accessor = Accessor;
	parms.bEnableTwistDrive = bEnableTwistDrive;
	parms.bEnableSwingDrive = bEnableSwingDrive;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::SetAngularVelocityDriveSLERP(struct FConstraintInstanceAccessor& Accessor, bool bEnableSLERP){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.SetAngularVelocityDriveSLERP");

	FSetAngularVelocityDriveSLERP parms{};	
	parms.Accessor = Accessor;
	parms.bEnableSLERP = bEnableSLERP;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::SetAngularSoftTwistLimitParams(struct FConstraintInstanceAccessor& Accessor, bool bSoftTwistLimit, float TwistLimitStiffness, float TwistLimitDamping, float TwistLimitRestitution, float TwistLimitContactDistance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.SetAngularSoftTwistLimitParams");

	FSetAngularSoftTwistLimitParams parms{};	
	parms.Accessor = Accessor;
	parms.bSoftTwistLimit = bSoftTwistLimit;
	parms.TwistLimitStiffness = TwistLimitStiffness;
	parms.TwistLimitDamping = TwistLimitDamping;
	parms.TwistLimitRestitution = TwistLimitRestitution;
	parms.TwistLimitContactDistance = TwistLimitContactDistance;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::SetAngularSoftSwingLimitParams(struct FConstraintInstanceAccessor& Accessor, bool bSoftSwingLimit, float SwingLimitStiffness, float SwingLimitDamping, float SwingLimitRestitution, float SwingLimitContactDistance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.SetAngularSoftSwingLimitParams");

	FSetAngularSoftSwingLimitParams parms{};	
	parms.Accessor = Accessor;
	parms.bSoftSwingLimit = bSoftSwingLimit;
	parms.SwingLimitStiffness = SwingLimitStiffness;
	parms.SwingLimitDamping = SwingLimitDamping;
	parms.SwingLimitRestitution = SwingLimitRestitution;
	parms.SwingLimitContactDistance = SwingLimitContactDistance;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::SetAngularPlasticity(struct FConstraintInstanceAccessor& Accessor, bool bAngularPlasticity, float AngularPlasticityThreshold){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.SetAngularPlasticity");

	FSetAngularPlasticity parms{};	
	parms.Accessor = Accessor;
	parms.bAngularPlasticity = bAngularPlasticity;
	parms.AngularPlasticityThreshold = AngularPlasticityThreshold;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::SetAngularOrientationTarget(struct FConstraintInstanceAccessor& Accessor, struct FRotator& InPosTarget){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.SetAngularOrientationTarget");

	FSetAngularOrientationTarget parms{};	
	parms.Accessor = Accessor;
	parms.InPosTarget = InPosTarget;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::SetAngularLimits(struct FConstraintInstanceAccessor& Accessor, enum class EAngularConstraintMotion Swing1MotionType, float Swing1LimitAngle, enum class EAngularConstraintMotion Swing2MotionType, float Swing2LimitAngle, enum class EAngularConstraintMotion TwistMotionType, float TwistLimitAngle){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.SetAngularLimits");

	FSetAngularLimits parms{};	
	parms.Accessor = Accessor;
	parms.Swing1MotionType = Swing1MotionType;
	parms.Swing1LimitAngle = Swing1LimitAngle;
	parms.Swing2MotionType = Swing2MotionType;
	parms.Swing2LimitAngle = Swing2LimitAngle;
	parms.TwistMotionType = TwistMotionType;
	parms.TwistLimitAngle = TwistLimitAngle;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::SetAngularDriveParams(struct FConstraintInstanceAccessor& Accessor, float PositionStrength, float VelocityStrength, float InForceLimit){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.SetAngularDriveParams");

	FSetAngularDriveParams parms{};	
	parms.Accessor = Accessor;
	parms.PositionStrength = PositionStrength;
	parms.VelocityStrength = VelocityStrength;
	parms.InForceLimit = InForceLimit;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::SetAngularDriveMode(struct FConstraintInstanceAccessor& Accessor, enum class EAngularDriveMode DriveMode){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.SetAngularDriveMode");

	FSetAngularDriveMode parms{};	
	parms.Accessor = Accessor;
	parms.DriveMode = DriveMode;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::SetAngularBreakable(struct FConstraintInstanceAccessor& Accessor, bool bAngularBreakable, float AngularBreakThreshold){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.SetAngularBreakable");

	FSetAngularBreakable parms{};	
	parms.Accessor = Accessor;
	parms.bAngularBreakable = bAngularBreakable;
	parms.AngularBreakThreshold = AngularBreakThreshold;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::GetProjectionParams(struct FConstraintInstanceAccessor& Accessor, bool& bEnableProjection, float& ProjectionLinearAlpha, float& ProjectionAngularAlpha){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.GetProjectionParams");

	FGetProjectionParams parms{};	
	parms.Accessor = Accessor;
	parms.bEnableProjection = bEnableProjection;
	parms.ProjectionLinearAlpha = ProjectionLinearAlpha;
	parms.ProjectionAngularAlpha = ProjectionAngularAlpha;

	ProcessEvent(fn, &parms);
}

bool UConstraintInstanceBlueprintLibrary::GetParentDominates(struct FConstraintInstanceAccessor& Accessor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.GetParentDominates");

	FGetParentDominates parms{};	
	parms.Accessor = Accessor;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UConstraintInstanceBlueprintLibrary::GetOrientationDriveTwistAndSwing(struct FConstraintInstanceAccessor& Accessor, bool& bOutEnableTwistDrive, bool& bOutEnableSwingDrive){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.GetOrientationDriveTwistAndSwing");

	FGetOrientationDriveTwistAndSwing parms{};	
	parms.Accessor = Accessor;
	parms.bOutEnableTwistDrive = bOutEnableTwistDrive;
	parms.bOutEnableSwingDrive = bOutEnableSwingDrive;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::GetOrientationDriveSLERP(struct FConstraintInstanceAccessor& Accessor, bool& bOutEnableSLERP){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.GetOrientationDriveSLERP");

	FGetOrientationDriveSLERP parms{};	
	parms.Accessor = Accessor;
	parms.bOutEnableSLERP = bOutEnableSLERP;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::GetLinearVelocityTarget(struct FConstraintInstanceAccessor& Accessor, struct FVector& OutVelTarget){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.GetLinearVelocityTarget");

	FGetLinearVelocityTarget parms{};	
	parms.Accessor = Accessor;
	parms.OutVelTarget = OutVelTarget;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::GetLinearVelocityDrive(struct FConstraintInstanceAccessor& Accessor, bool& bOutEnableDriveX, bool& bOutEnableDriveY, bool& bOutEnableDriveZ){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.GetLinearVelocityDrive");

	FGetLinearVelocityDrive parms{};	
	parms.Accessor = Accessor;
	parms.bOutEnableDriveX = bOutEnableDriveX;
	parms.bOutEnableDriveY = bOutEnableDriveY;
	parms.bOutEnableDriveZ = bOutEnableDriveZ;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::GetLinearSoftLimitParams(struct FConstraintInstanceAccessor& Accessor, bool& bSoftLinearLimit, float& LinearLimitStiffness, float& LinearLimitDamping, float& LinearLimitRestitution, float& LinearLimitContactDistance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.GetLinearSoftLimitParams");

	FGetLinearSoftLimitParams parms{};	
	parms.Accessor = Accessor;
	parms.bSoftLinearLimit = bSoftLinearLimit;
	parms.LinearLimitStiffness = LinearLimitStiffness;
	parms.LinearLimitDamping = LinearLimitDamping;
	parms.LinearLimitRestitution = LinearLimitRestitution;
	parms.LinearLimitContactDistance = LinearLimitContactDistance;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::GetLinearPositionTarget(struct FConstraintInstanceAccessor& Accessor, struct FVector& OutPosTarget){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.GetLinearPositionTarget");

	FGetLinearPositionTarget parms{};	
	parms.Accessor = Accessor;
	parms.OutPosTarget = OutPosTarget;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::GetLinearPositionDrive(struct FConstraintInstanceAccessor& Accessor, bool& bOutEnableDriveX, bool& bOutEnableDriveY, bool& bOutEnableDriveZ){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.GetLinearPositionDrive");

	FGetLinearPositionDrive parms{};	
	parms.Accessor = Accessor;
	parms.bOutEnableDriveX = bOutEnableDriveX;
	parms.bOutEnableDriveY = bOutEnableDriveY;
	parms.bOutEnableDriveZ = bOutEnableDriveZ;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::GetLinearPlasticity(struct FConstraintInstanceAccessor& Accessor, bool& bLinearPlasticity, float& LinearPlasticityThreshold, enum class EConstraintPlasticityType& PlasticityType){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.GetLinearPlasticity");

	FGetLinearPlasticity parms{};	
	parms.Accessor = Accessor;
	parms.bLinearPlasticity = bLinearPlasticity;
	parms.LinearPlasticityThreshold = LinearPlasticityThreshold;
	parms.PlasticityType = PlasticityType;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::GetLinearLimits(struct FConstraintInstanceAccessor& Accessor, enum class ELinearConstraintMotion& XMotion, enum class ELinearConstraintMotion& YMotion, enum class ELinearConstraintMotion& ZMotion, float& Limit){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.GetLinearLimits");

	FGetLinearLimits parms{};	
	parms.Accessor = Accessor;
	parms.XMotion = XMotion;
	parms.YMotion = YMotion;
	parms.ZMotion = ZMotion;
	parms.Limit = Limit;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::GetLinearDriveParams(struct FConstraintInstanceAccessor& Accessor, float& OutPositionStrength, float& OutVelocityStrength, float& OutForceLimit){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.GetLinearDriveParams");

	FGetLinearDriveParams parms{};	
	parms.Accessor = Accessor;
	parms.OutPositionStrength = OutPositionStrength;
	parms.OutVelocityStrength = OutVelocityStrength;
	parms.OutForceLimit = OutForceLimit;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::GetLinearBreakable(struct FConstraintInstanceAccessor& Accessor, bool& bLinearBreakable, float& LinearBreakThreshold){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.GetLinearBreakable");

	FGetLinearBreakable parms{};	
	parms.Accessor = Accessor;
	parms.bLinearBreakable = bLinearBreakable;
	parms.LinearBreakThreshold = LinearBreakThreshold;

	ProcessEvent(fn, &parms);
}

bool UConstraintInstanceBlueprintLibrary::GetDisableCollsion(struct FConstraintInstanceAccessor& Accessor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.GetDisableCollsion");

	FGetDisableCollsion parms{};	
	parms.Accessor = Accessor;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UConstraintInstanceBlueprintLibrary::GetContactTransferScale(struct FConstraintInstanceAccessor& Accessor, float& ContactTransferScale){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.GetContactTransferScale");

	FGetContactTransferScale parms{};	
	parms.Accessor = Accessor;
	parms.ContactTransferScale = ContactTransferScale;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::GetAttachedBodyNames(struct FConstraintInstanceAccessor& Accessor, struct FName& ParentBody, struct FName& ChildBody){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.GetAttachedBodyNames");

	FGetAttachedBodyNames parms{};	
	parms.Accessor = Accessor;
	parms.ParentBody = ParentBody;
	parms.ChildBody = ChildBody;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::GetAngularVelocityTarget(struct FConstraintInstanceAccessor& Accessor, struct FVector& OutVelTarget){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.GetAngularVelocityTarget");

	FGetAngularVelocityTarget parms{};	
	parms.Accessor = Accessor;
	parms.OutVelTarget = OutVelTarget;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::GetAngularVelocityDriveTwistAndSwing(struct FConstraintInstanceAccessor& Accessor, bool& bOutEnableTwistDrive, bool& bOutEnableSwingDrive){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.GetAngularVelocityDriveTwistAndSwing");

	FGetAngularVelocityDriveTwistAndSwing parms{};	
	parms.Accessor = Accessor;
	parms.bOutEnableTwistDrive = bOutEnableTwistDrive;
	parms.bOutEnableSwingDrive = bOutEnableSwingDrive;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::GetAngularVelocityDriveSLERP(struct FConstraintInstanceAccessor& Accessor, bool& bOutEnableSLERP){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.GetAngularVelocityDriveSLERP");

	FGetAngularVelocityDriveSLERP parms{};	
	parms.Accessor = Accessor;
	parms.bOutEnableSLERP = bOutEnableSLERP;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::GetAngularSoftTwistLimitParams(struct FConstraintInstanceAccessor& Accessor, bool& bSoftTwistLimit, float& TwistLimitStiffness, float& TwistLimitDamping, float& TwistLimitRestitution, float& TwistLimitContactDistance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.GetAngularSoftTwistLimitParams");

	FGetAngularSoftTwistLimitParams parms{};	
	parms.Accessor = Accessor;
	parms.bSoftTwistLimit = bSoftTwistLimit;
	parms.TwistLimitStiffness = TwistLimitStiffness;
	parms.TwistLimitDamping = TwistLimitDamping;
	parms.TwistLimitRestitution = TwistLimitRestitution;
	parms.TwistLimitContactDistance = TwistLimitContactDistance;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::GetAngularSoftSwingLimitParams(struct FConstraintInstanceAccessor& Accessor, bool& bSoftSwingLimit, float& SwingLimitStiffness, float& SwingLimitDamping, float& SwingLimitRestitution, float& SwingLimitContactDistance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.GetAngularSoftSwingLimitParams");

	FGetAngularSoftSwingLimitParams parms{};	
	parms.Accessor = Accessor;
	parms.bSoftSwingLimit = bSoftSwingLimit;
	parms.SwingLimitStiffness = SwingLimitStiffness;
	parms.SwingLimitDamping = SwingLimitDamping;
	parms.SwingLimitRestitution = SwingLimitRestitution;
	parms.SwingLimitContactDistance = SwingLimitContactDistance;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::GetAngularPlasticity(struct FConstraintInstanceAccessor& Accessor, bool& bAngularPlasticity, float& AngularPlasticityThreshold){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.GetAngularPlasticity");

	FGetAngularPlasticity parms{};	
	parms.Accessor = Accessor;
	parms.bAngularPlasticity = bAngularPlasticity;
	parms.AngularPlasticityThreshold = AngularPlasticityThreshold;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::GetAngularOrientationTarget(struct FConstraintInstanceAccessor& Accessor, struct FRotator& OutPosTarget){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.GetAngularOrientationTarget");

	FGetAngularOrientationTarget parms{};	
	parms.Accessor = Accessor;
	parms.OutPosTarget = OutPosTarget;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::GetAngularLimits(struct FConstraintInstanceAccessor& Accessor, enum class EAngularConstraintMotion& Swing1MotionType, float& Swing1LimitAngle, enum class EAngularConstraintMotion& Swing2MotionType, float& Swing2LimitAngle, enum class EAngularConstraintMotion& TwistMotionType, float& TwistLimitAngle){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.GetAngularLimits");

	FGetAngularLimits parms{};	
	parms.Accessor = Accessor;
	parms.Swing1MotionType = Swing1MotionType;
	parms.Swing1LimitAngle = Swing1LimitAngle;
	parms.Swing2MotionType = Swing2MotionType;
	parms.Swing2LimitAngle = Swing2LimitAngle;
	parms.TwistMotionType = TwistMotionType;
	parms.TwistLimitAngle = TwistLimitAngle;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::GetAngularDriveParams(struct FConstraintInstanceAccessor& Accessor, float& OutPositionStrength, float& OutVelocityStrength, float& OutForceLimit){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.GetAngularDriveParams");

	FGetAngularDriveParams parms{};	
	parms.Accessor = Accessor;
	parms.OutPositionStrength = OutPositionStrength;
	parms.OutVelocityStrength = OutVelocityStrength;
	parms.OutForceLimit = OutForceLimit;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::GetAngularDriveMode(struct FConstraintInstanceAccessor& Accessor, enum class EAngularDriveMode& OutDriveMode){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.GetAngularDriveMode");

	FGetAngularDriveMode parms{};	
	parms.Accessor = Accessor;
	parms.OutDriveMode = OutDriveMode;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::GetAngularBreakable(struct FConstraintInstanceAccessor& Accessor, bool& bAngularBreakable, float& AngularBreakThreshold){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.GetAngularBreakable");

	FGetAngularBreakable parms{};	
	parms.Accessor = Accessor;
	parms.bAngularBreakable = bAngularBreakable;
	parms.AngularBreakThreshold = AngularBreakThreshold;

	ProcessEvent(fn, &parms);
}

void UConstraintInstanceBlueprintLibrary::CopyParams(struct FConstraintInstanceAccessor& Accessor, struct FConstraintInstanceAccessor& SourceAccessor, bool bKeepPosition, bool bKeepRotation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ConstraintInstanceBlueprintLibrary.CopyParams");

	FCopyParams parms{};	
	parms.Accessor = Accessor;
	parms.SourceAccessor = SourceAccessor;
	parms.bKeepPosition = bKeepPosition;
	parms.bKeepRotation = bKeepRotation;

	ProcessEvent(fn, &parms);
}

void APostProcessVolume::AddOrUpdateBlendable(struct TScriptInterface<IBlendableInterface> InBlendableObject, float InWeight){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PostProcessVolume.AddOrUpdateBlendable");

	FAddOrUpdateBlendable parms{};	
	parms.InBlendableObject = InBlendableObject;
	parms.InWeight = InWeight;

	ProcessEvent(fn, &parms);
}

int32_t UKismetMathLibrary::Xor_IntInt(int32_t A, int32_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Xor_IntInt");

	FXor_IntInt parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int64_t UKismetMathLibrary::Xor_Int64Int64(int64_t A, int64_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Xor_Int64Int64");

	FXor_Int64Int64 parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::Wrap(int32_t Value, int32_t Min, int32_t Max){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Wrap");

	FWrap parms{};	
	parms.Value = Value;
	parms.Min = Min;
	parms.Max = Max;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::WeightedMovingAverage_FVector(struct FVector CurrentSample, struct FVector PreviousSample, float Weight){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.WeightedMovingAverage_FVector");

	FWeightedMovingAverage_FVector parms{};	
	parms.CurrentSample = CurrentSample;
	parms.PreviousSample = PreviousSample;
	parms.Weight = Weight;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator UKismetMathLibrary::WeightedMovingAverage_FRotator(struct FRotator CurrentSample, struct FRotator PreviousSample, float Weight){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.WeightedMovingAverage_FRotator");

	FWeightedMovingAverage_FRotator parms{};	
	parms.CurrentSample = CurrentSample;
	parms.PreviousSample = PreviousSample;
	parms.Weight = Weight;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetMathLibrary::WeightedMovingAverage_Float(float CurrentSample, float PreviousSample, float Weight){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.WeightedMovingAverage_Float");

	FWeightedMovingAverage_Float parms{};	
	parms.CurrentSample = CurrentSample;
	parms.PreviousSample = PreviousSample;
	parms.Weight = Weight;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::VSizeXYSquared(struct FVector A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VSizeXYSquared");

	FVSizeXYSquared parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::VSizeXY(struct FVector A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VSizeXY");

	FVSizeXY parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::VSizeSquared(struct FVector A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VSizeSquared");

	FVSizeSquared parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::VSize2DSquared(struct FVector2D A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VSize2DSquared");

	FVSize2DSquared parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::VSize2D(struct FVector2D A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VSize2D");

	FVSize2D parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::VSize(struct FVector A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VSize");

	FVSize parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::VLerp(struct FVector A, struct FVector B, float Alpha){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VLerp");

	FVLerp parms{};	
	parms.A = A;
	parms.B = B;
	parms.Alpha = Alpha;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::VInterpTo_Constant(struct FVector Current, struct FVector Target, float DeltaTime, float InterpSpeed){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VInterpTo_Constant");

	FVInterpTo_Constant parms{};	
	parms.Current = Current;
	parms.Target = Target;
	parms.DeltaTime = DeltaTime;
	parms.InterpSpeed = InterpSpeed;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::VInterpTo(struct FVector Current, struct FVector Target, float DeltaTime, float InterpSpeed){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VInterpTo");

	FVInterpTo parms{};	
	parms.Current = Current;
	parms.Target = Target;
	parms.DeltaTime = DeltaTime;
	parms.InterpSpeed = InterpSpeed;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::VectorSpringInterp(struct FVector Current, struct FVector Target, struct FVectorSpringState& SpringState, float Stiffness, float CriticalDampingFactor, float DeltaTime, float Mass, float TargetVelocityAmount, bool bClamp, struct FVector MinValue, struct FVector MaxValue, bool bInitializeFromTarget){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VectorSpringInterp");

	FVectorSpringInterp parms{};	
	parms.Current = Current;
	parms.Target = Target;
	parms.SpringState = SpringState;
	parms.Stiffness = Stiffness;
	parms.CriticalDampingFactor = CriticalDampingFactor;
	parms.DeltaTime = DeltaTime;
	parms.Mass = Mass;
	parms.TargetVelocityAmount = TargetVelocityAmount;
	parms.bClamp = bClamp;
	parms.MinValue = MinValue;
	parms.MaxValue = MaxValue;
	parms.bInitializeFromTarget = bInitializeFromTarget;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Vector_Zero(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Zero");

	FVector_Zero parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Vector_Up(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Up");

	FVector_Up parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetMathLibrary::Vector_UnwindEuler(struct FVector& A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_UnwindEuler");

	FVector_UnwindEuler parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);
}

struct FVector2D UKismetMathLibrary::Vector_UnitCartesianToSpherical(struct FVector A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_UnitCartesianToSpherical");

	FVector_UnitCartesianToSpherical parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Vector_ToRadians(struct FVector A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_ToRadians");

	FVector_ToRadians parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Vector_ToDegrees(struct FVector A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_ToDegrees");

	FVector_ToDegrees parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Vector_SnappedToGrid(struct FVector InVect, float InGridSize){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_SnappedToGrid");

	FVector_SnappedToGrid parms{};	
	parms.InVect = InVect;
	parms.InGridSize = InGridSize;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetMathLibrary::Vector_Set(struct FVector& A, double X, double Y, double Z){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Set");

	FVector_Set parms{};	
	parms.A = A;
	parms.X = X;
	parms.Y = Y;
	parms.Z = Z;

	ProcessEvent(fn, &parms);
}

struct FVector UKismetMathLibrary::Vector_Right(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Right");

	FVector_Right parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Vector_Reciprocal(struct FVector& A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Reciprocal");

	FVector_Reciprocal parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Vector_ProjectOnToNormal(struct FVector V, struct FVector InNormal){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_ProjectOnToNormal");

	FVector_ProjectOnToNormal parms{};	
	parms.V = V;
	parms.InNormal = InNormal;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Vector_One(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_One");

	FVector_One parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Vector_NormalUnsafe(struct FVector& A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_NormalUnsafe");

	FVector_NormalUnsafe parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetMathLibrary::Vector_Normalize(struct FVector& A, float Tolerance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Normalize");

	FVector_Normalize parms{};	
	parms.A = A;
	parms.Tolerance = Tolerance;

	ProcessEvent(fn, &parms);
}

struct FVector UKismetMathLibrary::Vector_Normal2D(struct FVector A, float Tolerance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Normal2D");

	FVector_Normal2D parms{};	
	parms.A = A;
	parms.Tolerance = Tolerance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Vector_MirrorByPlane(struct FVector A, struct FPlane& InPlane){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_MirrorByPlane");

	FVector_MirrorByPlane parms{};	
	parms.A = A;
	parms.InPlane = InPlane;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Vector_Left(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Left");

	FVector_Left parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::Vector_IsZero(struct FVector& A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_IsZero");

	FVector_IsZero parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::Vector_IsUnit(struct FVector& A, float SquaredLenthTolerance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_IsUnit");

	FVector_IsUnit parms{};	
	parms.A = A;
	parms.SquaredLenthTolerance = SquaredLenthTolerance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::Vector_IsUniform(struct FVector& A, float Tolerance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_IsUniform");

	FVector_IsUniform parms{};	
	parms.A = A;
	parms.Tolerance = Tolerance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::Vector_IsNormal(struct FVector& A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_IsNormal");

	FVector_IsNormal parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::Vector_IsNearlyZero(struct FVector& A, float Tolerance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_IsNearlyZero");

	FVector_IsNearlyZero parms{};	
	parms.A = A;
	parms.Tolerance = Tolerance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::Vector_IsNAN(struct FVector& A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_IsNAN");

	FVector_IsNAN parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Vector_HeadingAngle(struct FVector A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_HeadingAngle");

	FVector_HeadingAngle parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Vector_GetSignVector(struct FVector A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_GetSignVector");

	FVector_GetSignVector parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Vector_GetProjection(struct FVector A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_GetProjection");

	FVector_GetProjection parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Vector_GetAbsMin(struct FVector A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_GetAbsMin");

	FVector_GetAbsMin parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Vector_GetAbsMax(struct FVector A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_GetAbsMax");

	FVector_GetAbsMax parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Vector_GetAbs(struct FVector A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_GetAbs");

	FVector_GetAbs parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Vector_Forward(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Forward");

	FVector_Forward parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Vector_Down(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Down");

	FVector_Down parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Vector_DistanceSquared(struct FVector v1, struct FVector v2){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_DistanceSquared");

	FVector_DistanceSquared parms{};	
	parms.v1 = v1;
	parms.v2 = v2;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Vector_Distance2DSquared(struct FVector v1, struct FVector v2){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Distance2DSquared");

	FVector_Distance2DSquared parms{};	
	parms.v1 = v1;
	parms.v2 = v2;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Vector_Distance2D(struct FVector v1, struct FVector v2){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Distance2D");

	FVector_Distance2D parms{};	
	parms.v1 = v1;
	parms.v2 = v2;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Vector_Distance(struct FVector v1, struct FVector v2){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Distance");

	FVector_Distance parms{};	
	parms.v1 = v1;
	parms.v2 = v2;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Vector_CosineAngle2D(struct FVector A, struct FVector B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_CosineAngle2D");

	FVector_CosineAngle2D parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Vector_ComponentMin(struct FVector A, struct FVector B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_ComponentMin");

	FVector_ComponentMin parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Vector_ComponentMax(struct FVector A, struct FVector B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_ComponentMax");

	FVector_ComponentMax parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Vector_ClampSizeMax2D(struct FVector A, double Max){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_ClampSizeMax2D");

	FVector_ClampSizeMax2D parms{};	
	parms.A = A;
	parms.Max = Max;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Vector_ClampSizeMax(struct FVector A, double Max){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_ClampSizeMax");

	FVector_ClampSizeMax parms{};	
	parms.A = A;
	parms.Max = Max;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Vector_ClampSize2D(struct FVector A, double Min, double Max){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_ClampSize2D");

	FVector_ClampSize2D parms{};	
	parms.A = A;
	parms.Min = Min;
	parms.Max = Max;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Vector_BoundedToCube(struct FVector InVect, float InRadius){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_BoundedToCube");

	FVector_BoundedToCube parms{};	
	parms.InVect = InVect;
	parms.InRadius = InRadius;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Vector_BoundedToBox(struct FVector InVect, struct FVector InBoxMin, struct FVector InBoxMax){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_BoundedToBox");

	FVector_BoundedToBox parms{};	
	parms.InVect = InVect;
	parms.InBoxMin = InBoxMin;
	parms.InBoxMax = InBoxMax;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Vector_Backward(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Backward");

	FVector_Backward parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetMathLibrary::Vector_Assign(struct FVector& A, struct FVector& InVector){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Assign");

	FVector_Assign parms{};	
	parms.A = A;
	parms.InVector = InVector;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::Vector_AddBounded(struct FVector& A, struct FVector InAddVect, float InRadius){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_AddBounded");

	FVector_AddBounded parms{};	
	parms.A = A;
	parms.InAddVect = InAddVect;
	parms.InRadius = InRadius;

	ProcessEvent(fn, &parms);
}

struct FVector4 UKismetMathLibrary::Vector4_Zero(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_Zero");

	FVector4_Zero parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Vector4_SizeSquared3(struct FVector4& A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_SizeSquared3");

	FVector4_SizeSquared3 parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Vector4_SizeSquared(struct FVector4& A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_SizeSquared");

	FVector4_SizeSquared parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Vector4_Size3(struct FVector4& A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_Size3");

	FVector4_Size3 parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Vector4_Size(struct FVector4& A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_Size");

	FVector4_Size parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetMathLibrary::Vector4_Set(struct FVector4& A, double X, double Y, double Z, double W){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_Set");

	FVector4_Set parms{};	
	parms.A = A;
	parms.X = X;
	parms.Y = Y;
	parms.Z = Z;
	parms.W = W;

	ProcessEvent(fn, &parms);
}

struct FVector4 UKismetMathLibrary::Vector4_NormalUnsafe3(struct FVector4& A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_NormalUnsafe3");

	FVector4_NormalUnsafe3 parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetMathLibrary::Vector4_Normalize3(struct FVector4& A, float Tolerance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_Normalize3");

	FVector4_Normalize3 parms{};	
	parms.A = A;
	parms.Tolerance = Tolerance;

	ProcessEvent(fn, &parms);
}

struct FVector4 UKismetMathLibrary::Vector4_Normal3(struct FVector4& A, float Tolerance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_Normal3");

	FVector4_Normal3 parms{};	
	parms.A = A;
	parms.Tolerance = Tolerance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector4 UKismetMathLibrary::Vector4_Negated(struct FVector4& A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_Negated");

	FVector4_Negated parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector4 UKismetMathLibrary::Vector4_MirrorByVector3(struct FVector4& Direction, struct FVector4& SurfaceNormal){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_MirrorByVector3");

	FVector4_MirrorByVector3 parms{};	
	parms.Direction = Direction;
	parms.SurfaceNormal = SurfaceNormal;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::Vector4_IsZero(struct FVector4& A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_IsZero");

	FVector4_IsZero parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::Vector4_IsUnit3(struct FVector4& A, float SquaredLenthTolerance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_IsUnit3");

	FVector4_IsUnit3 parms{};	
	parms.A = A;
	parms.SquaredLenthTolerance = SquaredLenthTolerance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::Vector4_IsNormal3(struct FVector4& A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_IsNormal3");

	FVector4_IsNormal3 parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::Vector4_IsNearlyZero3(struct FVector4& A, float Tolerance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_IsNearlyZero3");

	FVector4_IsNearlyZero3 parms{};	
	parms.A = A;
	parms.Tolerance = Tolerance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::Vector4_IsNAN(struct FVector4& A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_IsNAN");

	FVector4_IsNAN parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Vector4_DotProduct3(struct FVector4& A, struct FVector4& B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_DotProduct3");

	FVector4_DotProduct3 parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Vector4_DotProduct(struct FVector4& A, struct FVector4& B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_DotProduct");

	FVector4_DotProduct parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector4 UKismetMathLibrary::Vector4_CrossProduct3(struct FVector4& A, struct FVector4& B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_CrossProduct3");

	FVector4_CrossProduct3 parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetMathLibrary::Vector4_Assign(struct FVector4& A, struct FVector4& InVector){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_Assign");

	FVector4_Assign parms{};	
	parms.A = A;
	parms.InVector = InVector;

	ProcessEvent(fn, &parms);
}

struct FVector2D UKismetMathLibrary::Vector2DInterpTo_Constant(struct FVector2D Current, struct FVector2D Target, float DeltaTime, float InterpSpeed){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector2DInterpTo_Constant");

	FVector2DInterpTo_Constant parms{};	
	parms.Current = Current;
	parms.Target = Target;
	parms.DeltaTime = DeltaTime;
	parms.InterpSpeed = InterpSpeed;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector2D UKismetMathLibrary::Vector2DInterpTo(struct FVector2D Current, struct FVector2D Target, float DeltaTime, float InterpSpeed){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector2DInterpTo");

	FVector2DInterpTo parms{};	
	parms.Current = Current;
	parms.Target = Target;
	parms.DeltaTime = DeltaTime;
	parms.InterpSpeed = InterpSpeed;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector2D UKismetMathLibrary::Vector2D_Zero(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector2D_Zero");

	FVector2D_Zero parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector2D UKismetMathLibrary::Vector2D_Unit45Deg(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector2D_Unit45Deg");

	FVector2D_Unit45Deg parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector2D UKismetMathLibrary::Vector2D_One(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector2D_One");

	FVector2D_One parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::VEase(struct FVector A, struct FVector B, float Alpha, enum class EEasingFunc EasingFunc, float BlendExp, int32_t Steps){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VEase");

	FVEase parms{};	
	parms.A = A;
	parms.B = B;
	parms.Alpha = Alpha;
	parms.EasingFunc = EasingFunc;
	parms.BlendExp = BlendExp;
	parms.Steps = Steps;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FDateTime UKismetMathLibrary::UtcNow(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.UtcNow");

	FUtcNow parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector4 UKismetMathLibrary::TransformVector4(struct FMatrix& Matrix, struct FVector4& Vec4){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TransformVector4");

	FTransformVector4 parms{};	
	parms.Matrix = Matrix;
	parms.Vec4 = Vec4;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator UKismetMathLibrary::TransformRotation(struct FTransform& T, struct FRotator Rotation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TransformRotation");

	FTransformRotation parms{};	
	parms.T = T;
	parms.Rotation = Rotation;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::TransformLocation(struct FTransform& T, struct FVector Location){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TransformLocation");

	FTransformLocation parms{};	
	parms.T = T;
	parms.Location = Location;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::TransformDirection(struct FTransform& T, struct FVector Direction){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TransformDirection");

	FTransformDirection parms{};	
	parms.T = T;
	parms.Direction = Direction;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetMathLibrary::Transform_Determinant(struct FTransform& Transform){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Transform_Determinant");

	FTransform_Determinant parms{};	
	parms.Transform = Transform;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector2D UKismetMathLibrary::ToSign2D(struct FVector2D A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ToSign2D");

	FToSign2D parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector2D UKismetMathLibrary::ToRounded2D(struct FVector2D A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ToRounded2D");

	FToRounded2D parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetMathLibrary::ToDirectionAndLength2D(struct FVector2D A, struct FVector2D& OutDir, double& OutLength){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ToDirectionAndLength2D");

	FToDirectionAndLength2D parms{};	
	parms.A = A;
	parms.OutDir = OutDir;
	parms.OutLength = OutLength;

	ProcessEvent(fn, &parms);
}

struct FDateTime UKismetMathLibrary::Today(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Today");

	FToday parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTransform UKismetMathLibrary::TLerp(struct FTransform& A, struct FTransform& B, float Alpha, enum class ELerpInterpolationMode InterpMode){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TLerp");

	FTLerp parms{};	
	parms.A = A;
	parms.B = B;
	parms.Alpha = Alpha;
	parms.InterpMode = InterpMode;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTransform UKismetMathLibrary::TInterpTo(struct FTransform& Current, struct FTransform& Target, float DeltaTime, float InterpSpeed){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TInterpTo");

	FTInterpTo parms{};	
	parms.Current = Current;
	parms.Target = Target;
	parms.DeltaTime = DeltaTime;
	parms.InterpSpeed = InterpSpeed;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTimespan UKismetMathLibrary::TimespanZeroValue(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TimespanZeroValue");

	FTimespanZeroValue parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetMathLibrary::TimespanRatio(struct FTimespan A, struct FTimespan B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TimespanRatio");

	FTimespanRatio parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTimespan UKismetMathLibrary::TimespanMinValue(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TimespanMinValue");

	FTimespanMinValue parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTimespan UKismetMathLibrary::TimespanMaxValue(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TimespanMaxValue");

	FTimespanMaxValue parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::TimespanFromString(struct FString TimespanString, struct FTimespan& Result){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TimespanFromString");

	FTimespanFromString parms{};	
	parms.TimespanString = TimespanString;
	parms.Result = Result;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTransform UKismetMathLibrary::TEase(struct FTransform& A, struct FTransform& B, float Alpha, enum class EEasingFunc EasingFunc, float BlendExp, int32_t Steps){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TEase");

	FTEase parms{};	
	parms.A = A;
	parms.B = B;
	parms.Alpha = Alpha;
	parms.EasingFunc = EasingFunc;
	parms.BlendExp = BlendExp;
	parms.Steps = Steps;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Tan(double A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Tan");

	FTan parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Subtract_VectorVector(struct FVector A, struct FVector B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_VectorVector");

	FSubtract_VectorVector parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Subtract_VectorInt(struct FVector A, int32_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_VectorInt");

	FSubtract_VectorInt parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Subtract_VectorFloat(struct FVector A, double B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_VectorFloat");

	FSubtract_VectorFloat parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector4 UKismetMathLibrary::Subtract_Vector4Vector4(struct FVector4& A, struct FVector4& B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_Vector4Vector4");

	FSubtract_Vector4Vector4 parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector2D UKismetMathLibrary::Subtract_Vector2DVector2D(struct FVector2D A, struct FVector2D B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_Vector2DVector2D");

	FSubtract_Vector2DVector2D parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector2D UKismetMathLibrary::Subtract_Vector2DFloat(struct FVector2D A, double B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_Vector2DFloat");

	FSubtract_Vector2DFloat parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTimespan UKismetMathLibrary::Subtract_TimespanTimespan(struct FTimespan A, struct FTimespan B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_TimespanTimespan");

	FSubtract_TimespanTimespan parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FQuat UKismetMathLibrary::Subtract_QuatQuat(struct FQuat& A, struct FQuat& B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_QuatQuat");

	FSubtract_QuatQuat parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FLinearColor UKismetMathLibrary::Subtract_LinearColorLinearColor(struct FLinearColor A, struct FLinearColor B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_LinearColorLinearColor");

	FSubtract_LinearColorLinearColor parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FIntPoint UKismetMathLibrary::Subtract_IntPointIntPoint(struct FIntPoint A, struct FIntPoint B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_IntPointIntPoint");

	FSubtract_IntPointIntPoint parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FIntPoint UKismetMathLibrary::Subtract_IntPointInt(struct FIntPoint A, int32_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_IntPointInt");

	FSubtract_IntPointInt parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::Subtract_IntInt(int32_t A, int32_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_IntInt");

	FSubtract_IntInt parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int64_t UKismetMathLibrary::Subtract_Int64Int64(int64_t A, int64_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_Int64Int64");

	FSubtract_Int64Int64 parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Subtract_DoubleDouble(double A, double B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_DoubleDouble");

	FSubtract_DoubleDouble parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FDateTime UKismetMathLibrary::Subtract_DateTimeTimespan(struct FDateTime A, struct FTimespan B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_DateTimeTimespan");

	FSubtract_DateTimeTimespan parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTimespan UKismetMathLibrary::Subtract_DateTimeDateTime(struct FDateTime A, struct FDateTime B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_DateTimeDateTime");

	FSubtract_DateTimeDateTime parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

char UKismetMathLibrary::Subtract_ByteByte(char A, char B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_ByteByte");

	FSubtract_ByteByte parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Square(double A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Square");

	FSquare parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Sqrt(double A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Sqrt");

	FSqrt parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Spherical2DToUnitCartesian(struct FVector2D A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Spherical2DToUnitCartesian");

	FSpherical2DToUnitCartesian parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Sin(double A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Sin");

	FSin parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int64_t UKismetMathLibrary::SignOfInteger64(int64_t A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SignOfInteger64");

	FSignOfInteger64 parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::SignOfInteger(int32_t A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SignOfInteger");

	FSignOfInteger parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::SignOfFloat(double A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SignOfFloat");

	FSignOfFloat parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetMathLibrary::SetVectorSpringStateVelocity(struct FVectorSpringState& SpringState, struct FVector Velocity){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SetVectorSpringStateVelocity");

	FSetVectorSpringStateVelocity parms{};	
	parms.SpringState = SpringState;
	parms.Velocity = Velocity;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::SetRandomStreamSeed(struct FRandomStream& Stream, int32_t NewSeed){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SetRandomStreamSeed");

	FSetRandomStreamSeed parms{};	
	parms.Stream = Stream;
	parms.NewSeed = NewSeed;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::SetQuaternionSpringStateAngularVelocity(struct FQuaternionSpringState& SpringState, struct FVector AngularVelocity){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SetQuaternionSpringStateAngularVelocity");

	FSetQuaternionSpringStateAngularVelocity parms{};	
	parms.SpringState = SpringState;
	parms.AngularVelocity = AngularVelocity;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::SetFloatSpringStateVelocity(struct FFloatSpringState& SpringState, float Velocity){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SetFloatSpringStateVelocity");

	FSetFloatSpringStateVelocity parms{};	
	parms.SpringState = SpringState;
	parms.Velocity = Velocity;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::Set2D(struct FVector2D& A, double X, double Y){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Set2D");

	FSet2D parms{};	
	parms.A = A;
	parms.X = X;
	parms.Y = Y;

	ProcessEvent(fn, &parms);
}

struct FVector UKismetMathLibrary::SelectVector(struct FVector A, struct FVector B, bool bPickA){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectVector");

	FSelectVector parms{};	
	parms.A = A;
	parms.B = B;
	parms.bPickA = bPickA;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTransform UKismetMathLibrary::SelectTransform(struct FTransform& A, struct FTransform& B, bool bPickA){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectTransform");

	FSelectTransform parms{};	
	parms.A = A;
	parms.B = B;
	parms.bPickA = bPickA;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetMathLibrary::SelectString(struct FString A, struct FString B, bool bPickA){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectString");

	FSelectString parms{};	
	parms.A = A;
	parms.B = B;
	parms.bPickA = bPickA;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator UKismetMathLibrary::SelectRotator(struct FRotator A, struct FRotator B, bool bPickA){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectRotator");

	FSelectRotator parms{};	
	parms.A = A;
	parms.B = B;
	parms.bPickA = bPickA;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UObject* UKismetMathLibrary::SelectObject(struct UObject* A, struct UObject* B, bool bSelectA){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectObject");

	FSelectObject parms{};	
	parms.A = A;
	parms.B = B;
	parms.bSelectA = bSelectA;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::SelectInt(int32_t A, int32_t B, bool bPickA){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectInt");

	FSelectInt parms{};	
	parms.A = A;
	parms.B = B;
	parms.bPickA = bPickA;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::SelectFloat(double A, double B, bool bPickA){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectFloat");

	FSelectFloat parms{};	
	parms.A = A;
	parms.B = B;
	parms.bPickA = bPickA;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FLinearColor UKismetMathLibrary::SelectColor(struct FLinearColor A, struct FLinearColor B, bool bPickA){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectColor");

	FSelectColor parms{};	
	parms.A = A;
	parms.B = B;
	parms.bPickA = bPickA;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

UObject* UKismetMathLibrary::SelectClass(UObject* A, UObject* B, bool bSelectA){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectClass");

	FSelectClass parms{};	
	parms.A = A;
	parms.B = B;
	parms.bSelectA = bSelectA;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetMathLibrary::SeedRandomStream(struct FRandomStream& Stream){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SeedRandomStream");

	FSeedRandomStream parms{};	
	parms.Stream = Stream;

	ProcessEvent(fn, &parms);
}

double UKismetMathLibrary::SafeDivide(double A, double B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SafeDivide");

	FSafeDivide parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int64_t UKismetMathLibrary::Round64(double A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Round64");

	FRound64 parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::Round(double A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Round");

	FRound parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator UKismetMathLibrary::RotatorFromAxisAndAngle(struct FVector Axis, float Angle){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RotatorFromAxisAndAngle");

	FRotatorFromAxisAndAngle parms{};	
	parms.Axis = Axis;
	parms.Angle = Angle;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::RotateAngleAxis(struct FVector InVect, float AngleDeg, struct FVector Axis){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RotateAngleAxis");

	FRotateAngleAxis parms{};	
	parms.InVect = InVect;
	parms.AngleDeg = AngleDeg;
	parms.Axis = Axis;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator UKismetMathLibrary::RLerp(struct FRotator A, struct FRotator B, float Alpha, bool bShortestPath){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RLerp");

	FRLerp parms{};	
	parms.A = A;
	parms.B = B;
	parms.Alpha = Alpha;
	parms.bShortestPath = bShortestPath;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator UKismetMathLibrary::RInterpTo_Constant(struct FRotator Current, struct FRotator Target, float DeltaTime, float InterpSpeed){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RInterpTo_Constant");

	FRInterpTo_Constant parms{};	
	parms.Current = Current;
	parms.Target = Target;
	parms.DeltaTime = DeltaTime;
	parms.InterpSpeed = InterpSpeed;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator UKismetMathLibrary::RInterpTo(struct FRotator Current, struct FRotator Target, float DeltaTime, float InterpSpeed){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RInterpTo");

	FRInterpTo parms{};	
	parms.Current = Current;
	parms.Target = Target;
	parms.DeltaTime = DeltaTime;
	parms.InterpSpeed = InterpSpeed;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetMathLibrary::RGBToHSV_Vector(struct FLinearColor RGB, struct FLinearColor& HSV){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RGBToHSV_Vector");

	FRGBToHSV_Vector parms{};	
	parms.RGB = RGB;
	parms.HSV = HSV;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::RGBToHSV(struct FLinearColor InColor, float& H, float& S, float& V, float& A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RGBToHSV");

	FRGBToHSV parms{};	
	parms.InColor = InColor;
	parms.H = H;
	parms.S = S;
	parms.V = V;
	parms.A = A;

	ProcessEvent(fn, &parms);
}

struct FLinearColor UKismetMathLibrary::RGBLinearToHSV(struct FLinearColor RGB){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RGBLinearToHSV");

	FRGBLinearToHSV parms{};	
	parms.RGB = RGB;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetMathLibrary::ResetVectorSpringState(struct FVectorSpringState& SpringState){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ResetVectorSpringState");

	FResetVectorSpringState parms{};	
	parms.SpringState = SpringState;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::ResetRandomStream(struct FRandomStream& Stream){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ResetRandomStream");

	FResetRandomStream parms{};	
	parms.Stream = Stream;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::ResetQuaternionSpringState(struct FQuaternionSpringState& SpringState){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ResetQuaternionSpringState");

	FResetQuaternionSpringState parms{};	
	parms.SpringState = SpringState;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::ResetFloatSpringState(struct FFloatSpringState& SpringState){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ResetFloatSpringState");

	FResetFloatSpringState parms{};	
	parms.SpringState = SpringState;

	ProcessEvent(fn, &parms);
}

struct FRotator UKismetMathLibrary::REase(struct FRotator A, struct FRotator B, float Alpha, bool bShortestPath, enum class EEasingFunc EasingFunc, float BlendExp, int32_t Steps){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.REase");

	FREase parms{};	
	parms.A = A;
	parms.B = B;
	parms.Alpha = Alpha;
	parms.bShortestPath = bShortestPath;
	parms.EasingFunc = EasingFunc;
	parms.BlendExp = BlendExp;
	parms.Steps = Steps;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::RandomUnitVectorInEllipticalConeInRadiansFromStream(struct FVector& ConeDir, float MaxYawInRadians, float MaxPitchInRadians, struct FRandomStream& Stream){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomUnitVectorInEllipticalConeInRadiansFromStream");

	FRandomUnitVectorInEllipticalConeInRadiansFromStream parms{};	
	parms.ConeDir = ConeDir;
	parms.MaxYawInRadians = MaxYawInRadians;
	parms.MaxPitchInRadians = MaxPitchInRadians;
	parms.Stream = Stream;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::RandomUnitVectorInEllipticalConeInRadians(struct FVector ConeDir, float MaxYawInRadians, float MaxPitchInRadians){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomUnitVectorInEllipticalConeInRadians");

	FRandomUnitVectorInEllipticalConeInRadians parms{};	
	parms.ConeDir = ConeDir;
	parms.MaxYawInRadians = MaxYawInRadians;
	parms.MaxPitchInRadians = MaxPitchInRadians;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::RandomUnitVectorInEllipticalConeInDegreesFromStream(struct FVector& ConeDir, float MaxYawInDegrees, float MaxPitchInDegrees, struct FRandomStream& Stream){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomUnitVectorInEllipticalConeInDegreesFromStream");

	FRandomUnitVectorInEllipticalConeInDegreesFromStream parms{};	
	parms.ConeDir = ConeDir;
	parms.MaxYawInDegrees = MaxYawInDegrees;
	parms.MaxPitchInDegrees = MaxPitchInDegrees;
	parms.Stream = Stream;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::RandomUnitVectorInEllipticalConeInDegrees(struct FVector ConeDir, float MaxYawInDegrees, float MaxPitchInDegrees){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomUnitVectorInEllipticalConeInDegrees");

	FRandomUnitVectorInEllipticalConeInDegrees parms{};	
	parms.ConeDir = ConeDir;
	parms.MaxYawInDegrees = MaxYawInDegrees;
	parms.MaxPitchInDegrees = MaxPitchInDegrees;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::RandomUnitVectorInConeInRadiansFromStream(struct FVector& ConeDir, float ConeHalfAngleInRadians, struct FRandomStream& Stream){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomUnitVectorInConeInRadiansFromStream");

	FRandomUnitVectorInConeInRadiansFromStream parms{};	
	parms.ConeDir = ConeDir;
	parms.ConeHalfAngleInRadians = ConeHalfAngleInRadians;
	parms.Stream = Stream;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::RandomUnitVectorInConeInRadians(struct FVector ConeDir, float ConeHalfAngleInRadians){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomUnitVectorInConeInRadians");

	FRandomUnitVectorInConeInRadians parms{};	
	parms.ConeDir = ConeDir;
	parms.ConeHalfAngleInRadians = ConeHalfAngleInRadians;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::RandomUnitVectorInConeInDegreesFromStream(struct FVector& ConeDir, float ConeHalfAngleInDegrees, struct FRandomStream& Stream){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomUnitVectorInConeInDegreesFromStream");

	FRandomUnitVectorInConeInDegreesFromStream parms{};	
	parms.ConeDir = ConeDir;
	parms.ConeHalfAngleInDegrees = ConeHalfAngleInDegrees;
	parms.Stream = Stream;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::RandomUnitVectorInConeInDegrees(struct FVector ConeDir, float ConeHalfAngleInDegrees){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomUnitVectorInConeInDegrees");

	FRandomUnitVectorInConeInDegrees parms{};	
	parms.ConeDir = ConeDir;
	parms.ConeHalfAngleInDegrees = ConeHalfAngleInDegrees;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::RandomUnitVectorFromStream(struct FRandomStream& Stream){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomUnitVectorFromStream");

	FRandomUnitVectorFromStream parms{};	
	parms.Stream = Stream;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::RandomUnitVector(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomUnitVector");

	FRandomUnitVector parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator UKismetMathLibrary::RandomRotatorFromStream(bool bRoll, struct FRandomStream& Stream){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomRotatorFromStream");

	FRandomRotatorFromStream parms{};	
	parms.bRoll = bRoll;
	parms.Stream = Stream;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator UKismetMathLibrary::RandomRotator(bool bRoll){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomRotator");

	FRandomRotator parms{};	
	parms.bRoll = bRoll;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::RandomPointInBoundingBoxFromStream_Box(struct FBox Box, struct FRandomStream& Stream){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomPointInBoundingBoxFromStream_Box");

	FRandomPointInBoundingBoxFromStream_Box parms{};	
	parms.Box = Box;
	parms.Stream = Stream;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::RandomPointInBoundingBoxFromStream(struct FVector Center, struct FVector HalfSize, struct FRandomStream& Stream){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomPointInBoundingBoxFromStream");

	FRandomPointInBoundingBoxFromStream parms{};	
	parms.Center = Center;
	parms.HalfSize = HalfSize;
	parms.Stream = Stream;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::RandomPointInBoundingBox_Box(struct FBox Box){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomPointInBoundingBox_Box");

	FRandomPointInBoundingBox_Box parms{};	
	parms.Box = Box;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::RandomPointInBoundingBox(struct FVector Center, struct FVector HalfSize){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomPointInBoundingBox");

	FRandomPointInBoundingBox parms{};	
	parms.Center = Center;
	parms.HalfSize = HalfSize;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::RandomIntegerInRangeFromStream(int32_t Min, int32_t Max, struct FRandomStream& Stream){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomIntegerInRangeFromStream");

	FRandomIntegerInRangeFromStream parms{};	
	parms.Min = Min;
	parms.Max = Max;
	parms.Stream = Stream;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::RandomIntegerInRange(int32_t Min, int32_t Max){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomIntegerInRange");

	FRandomIntegerInRange parms{};	
	parms.Min = Min;
	parms.Max = Max;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::RandomIntegerFromStream(int32_t Max, struct FRandomStream& Stream){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomIntegerFromStream");

	FRandomIntegerFromStream parms{};	
	parms.Max = Max;
	parms.Stream = Stream;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int64_t UKismetMathLibrary::RandomInteger64InRange(int64_t Min, int64_t Max){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomInteger64InRange");

	FRandomInteger64InRange parms{};	
	parms.Min = Min;
	parms.Max = Max;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int64_t UKismetMathLibrary::RandomInteger64(int64_t Max){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomInteger64");

	FRandomInteger64 parms{};	
	parms.Max = Max;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::RandomInteger(int32_t Max){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomInteger");

	FRandomInteger parms{};	
	parms.Max = Max;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetMathLibrary::RandomFloatInRangeFromStream(float Min, float Max, struct FRandomStream& Stream){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomFloatInRangeFromStream");

	FRandomFloatInRangeFromStream parms{};	
	parms.Min = Min;
	parms.Max = Max;
	parms.Stream = Stream;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::RandomFloatInRange(double Min, double Max){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomFloatInRange");

	FRandomFloatInRange parms{};	
	parms.Min = Min;
	parms.Max = Max;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetMathLibrary::RandomFloatFromStream(struct FRandomStream& Stream){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomFloatFromStream");

	FRandomFloatFromStream parms{};	
	parms.Stream = Stream;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::RandomFloat(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomFloat");

	FRandomFloat parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::RandomBoolWithWeightFromStream(float Weight, struct FRandomStream& RandomStream){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomBoolWithWeightFromStream");

	FRandomBoolWithWeightFromStream parms{};	
	parms.Weight = Weight;
	parms.RandomStream = RandomStream;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::RandomBoolWithWeight(float Weight){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomBoolWithWeight");

	FRandomBoolWithWeight parms{};	
	parms.Weight = Weight;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::RandomBoolFromStream(struct FRandomStream& Stream){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomBoolFromStream");

	FRandomBoolFromStream parms{};	
	parms.Stream = Stream;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::RandomBool(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomBool");

	FRandomBool parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::RadiansToDegrees(double A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RadiansToDegrees");

	FRadiansToDegrees parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FQuat UKismetMathLibrary::QuaternionSpringInterp(struct FQuat Current, struct FQuat Target, struct FQuaternionSpringState& SpringState, float Stiffness, float CriticalDampingFactor, float DeltaTime, float Mass, float TargetVelocityAmount, bool bInitializeFromTarget){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.QuaternionSpringInterp");

	FQuaternionSpringInterp parms{};	
	parms.Current = Current;
	parms.Target = Target;
	parms.SpringState = SpringState;
	parms.Stiffness = Stiffness;
	parms.CriticalDampingFactor = CriticalDampingFactor;
	parms.DeltaTime = DeltaTime;
	parms.Mass = Mass;
	parms.TargetVelocityAmount = TargetVelocityAmount;
	parms.bInitializeFromTarget = bInitializeFromTarget;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Quat_VectorUp(struct FQuat& Q){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_VectorUp");

	FQuat_VectorUp parms{};	
	parms.Q = Q;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Quat_VectorRight(struct FQuat& Q){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_VectorRight");

	FQuat_VectorRight parms{};	
	parms.Q = Q;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Quat_VectorForward(struct FQuat& Q){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_VectorForward");

	FQuat_VectorForward parms{};	
	parms.Q = Q;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Quat_UnrotateVector(struct FQuat& Q, struct FVector& V){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_UnrotateVector");

	FQuat_UnrotateVector parms{};	
	parms.Q = Q;
	parms.V = V;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetMathLibrary::Quat_SizeSquared(struct FQuat& Q){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_SizeSquared");

	FQuat_SizeSquared parms{};	
	parms.Q = Q;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetMathLibrary::Quat_Size(struct FQuat& Q){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_Size");

	FQuat_Size parms{};	
	parms.Q = Q;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetMathLibrary::Quat_SetFromEuler(struct FQuat& Q, struct FVector& Euler){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_SetFromEuler");

	FQuat_SetFromEuler parms{};	
	parms.Q = Q;
	parms.Euler = Euler;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::Quat_SetComponents(struct FQuat& Q, float X, float Y, float Z, float W){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_SetComponents");

	FQuat_SetComponents parms{};	
	parms.Q = Q;
	parms.X = X;
	parms.Y = Y;
	parms.Z = Z;
	parms.W = W;

	ProcessEvent(fn, &parms);
}

struct FRotator UKismetMathLibrary::Quat_Rotator(struct FQuat& Q){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_Rotator");

	FQuat_Rotator parms{};	
	parms.Q = Q;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Quat_RotateVector(struct FQuat& Q, struct FVector& V){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_RotateVector");

	FQuat_RotateVector parms{};	
	parms.Q = Q;
	parms.V = V;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FQuat UKismetMathLibrary::Quat_Normalized(struct FQuat& Q, float Tolerance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_Normalized");

	FQuat_Normalized parms{};	
	parms.Q = Q;
	parms.Tolerance = Tolerance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetMathLibrary::Quat_Normalize(struct FQuat& Q, float Tolerance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_Normalize");

	FQuat_Normalize parms{};	
	parms.Q = Q;
	parms.Tolerance = Tolerance;

	ProcessEvent(fn, &parms);
}

struct FQuat UKismetMathLibrary::Quat_MakeFromEuler(struct FVector& Euler){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_MakeFromEuler");

	FQuat_MakeFromEuler parms{};	
	parms.Euler = Euler;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FQuat UKismetMathLibrary::Quat_Log(struct FQuat& Q){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_Log");

	FQuat_Log parms{};	
	parms.Q = Q;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::Quat_IsNormalized(struct FQuat& Q){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_IsNormalized");

	FQuat_IsNormalized parms{};	
	parms.Q = Q;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::Quat_IsNonFinite(struct FQuat& Q){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_IsNonFinite");

	FQuat_IsNonFinite parms{};	
	parms.Q = Q;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::Quat_IsIdentity(struct FQuat& Q, float Tolerance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_IsIdentity");

	FQuat_IsIdentity parms{};	
	parms.Q = Q;
	parms.Tolerance = Tolerance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::Quat_IsFinite(struct FQuat& Q){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_IsFinite");

	FQuat_IsFinite parms{};	
	parms.Q = Q;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FQuat UKismetMathLibrary::Quat_Inversed(struct FQuat& Q){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_Inversed");

	FQuat_Inversed parms{};	
	parms.Q = Q;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FQuat UKismetMathLibrary::Quat_Identity(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_Identity");

	FQuat_Identity parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Quat_GetRotationAxis(struct FQuat& Q){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_GetRotationAxis");

	FQuat_GetRotationAxis parms{};	
	parms.Q = Q;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Quat_GetAxisZ(struct FQuat& Q){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_GetAxisZ");

	FQuat_GetAxisZ parms{};	
	parms.Q = Q;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Quat_GetAxisY(struct FQuat& Q){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_GetAxisY");

	FQuat_GetAxisY parms{};	
	parms.Q = Q;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Quat_GetAxisX(struct FQuat& Q){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_GetAxisX");

	FQuat_GetAxisX parms{};	
	parms.Q = Q;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetMathLibrary::Quat_GetAngle(struct FQuat& Q){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_GetAngle");

	FQuat_GetAngle parms{};	
	parms.Q = Q;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FQuat UKismetMathLibrary::Quat_Exp(struct FQuat& Q){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_Exp");

	FQuat_Exp parms{};	
	parms.Q = Q;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Quat_Euler(struct FQuat& Q){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_Euler");

	FQuat_Euler parms{};	
	parms.Q = Q;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetMathLibrary::Quat_EnforceShortestArcWith(struct FQuat& A, struct FQuat& B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_EnforceShortestArcWith");

	FQuat_EnforceShortestArcWith parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);
}

float UKismetMathLibrary::Quat_AngularDistance(struct FQuat& A, struct FQuat& B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_AngularDistance");

	FQuat_AngularDistance parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::ProjectVectorOnToVector(struct FVector V, struct FVector Target){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ProjectVectorOnToVector");

	FProjectVectorOnToVector parms{};	
	parms.V = V;
	parms.Target = Target;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::ProjectVectorOnToPlane(struct FVector V, struct FVector PlaneNormal){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ProjectVectorOnToPlane");

	FProjectVectorOnToPlane parms{};	
	parms.V = V;
	parms.PlaneNormal = PlaneNormal;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::ProjectPointOnToPlane(struct FVector Point, struct FVector PlaneBase, struct FVector PlaneNormal){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ProjectPointOnToPlane");

	FProjectPointOnToPlane parms{};	
	parms.Point = Point;
	parms.PlaneBase = PlaneBase;
	parms.PlaneNormal = PlaneNormal;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::PointsAreCoplanar(struct TArray<struct FVector>& Points, float Tolerance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.PointsAreCoplanar");

	FPointsAreCoplanar parms{};	
	parms.Points = Points;
	parms.Tolerance = Tolerance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetMathLibrary::PerlinNoise1D(float Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.PerlinNoise1D");

	FPerlinNoise1D parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::Percent_IntInt(int32_t A, int32_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Percent_IntInt");

	FPercent_IntInt parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int64_t UKismetMathLibrary::Percent_Int64Int64(int64_t A, int64_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Percent_Int64Int64");

	FPercent_Int64Int64 parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Percent_FloatFloat(double A, double B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Percent_FloatFloat");

	FPercent_FloatFloat parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

char UKismetMathLibrary::Percent_ByteByte(char A, char B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Percent_ByteByte");

	FPercent_ByteByte parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::Or_IntInt(int32_t A, int32_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Or_IntInt");

	FOr_IntInt parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int64_t UKismetMathLibrary::Or_Int64Int64(int64_t A, int64_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Or_Int64Int64");

	FOr_Int64Int64 parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FDateTime UKismetMathLibrary::Now(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Now");

	FNow parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::NotEqualExactly_VectorVector(struct FVector A, struct FVector B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqualExactly_VectorVector");

	FNotEqualExactly_VectorVector parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::NotEqualExactly_Vector4Vector4(struct FVector4& A, struct FVector4& B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqualExactly_Vector4Vector4");

	FNotEqualExactly_Vector4Vector4 parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::NotEqualExactly_Vector2DVector2D(struct FVector2D A, struct FVector2D B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqualExactly_Vector2DVector2D");

	FNotEqualExactly_Vector2DVector2D parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::NotEqual_VectorVector(struct FVector A, struct FVector B, float ErrorTolerance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_VectorVector");

	FNotEqual_VectorVector parms{};	
	parms.A = A;
	parms.B = B;
	parms.ErrorTolerance = ErrorTolerance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::NotEqual_Vector4Vector4(struct FVector4& A, struct FVector4& B, float ErrorTolerance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_Vector4Vector4");

	FNotEqual_Vector4Vector4 parms{};	
	parms.A = A;
	parms.B = B;
	parms.ErrorTolerance = ErrorTolerance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::NotEqual_Vector2DVector2D(struct FVector2D A, struct FVector2D B, float ErrorTolerance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_Vector2DVector2D");

	FNotEqual_Vector2DVector2D parms{};	
	parms.A = A;
	parms.B = B;
	parms.ErrorTolerance = ErrorTolerance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::NotEqual_TimespanTimespan(struct FTimespan A, struct FTimespan B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_TimespanTimespan");

	FNotEqual_TimespanTimespan parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::NotEqual_RotatorRotator(struct FRotator A, struct FRotator B, float ErrorTolerance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_RotatorRotator");

	FNotEqual_RotatorRotator parms{};	
	parms.A = A;
	parms.B = B;
	parms.ErrorTolerance = ErrorTolerance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::NotEqual_QuatQuat(struct FQuat& A, struct FQuat& B, float ErrorTolerance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_QuatQuat");

	FNotEqual_QuatQuat parms{};	
	parms.A = A;
	parms.B = B;
	parms.ErrorTolerance = ErrorTolerance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::NotEqual_ObjectObject(struct UObject* A, struct UObject* B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_ObjectObject");

	FNotEqual_ObjectObject parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::NotEqual_NameName(struct FName A, struct FName B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_NameName");

	FNotEqual_NameName parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::NotEqual_MatrixMatrix(struct FMatrix& A, struct FMatrix& B, float Tolerance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_MatrixMatrix");

	FNotEqual_MatrixMatrix parms{};	
	parms.A = A;
	parms.B = B;
	parms.Tolerance = Tolerance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::NotEqual_LinearColorLinearColor(struct FLinearColor A, struct FLinearColor B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_LinearColorLinearColor");

	FNotEqual_LinearColorLinearColor parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::NotEqual_IntPointIntPoint(struct FIntPoint A, struct FIntPoint B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_IntPointIntPoint");

	FNotEqual_IntPointIntPoint parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::NotEqual_IntInt(int32_t A, int32_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_IntInt");

	FNotEqual_IntInt parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::NotEqual_Int64Int64(int64_t A, int64_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_Int64Int64");

	FNotEqual_Int64Int64 parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::NotEqual_DoubleDouble(double A, double B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_DoubleDouble");

	FNotEqual_DoubleDouble parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::NotEqual_DateTimeDateTime(struct FDateTime A, struct FDateTime B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_DateTimeDateTime");

	FNotEqual_DateTimeDateTime parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::NotEqual_ClassClass(UObject* A, UObject* B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_ClassClass");

	FNotEqual_ClassClass parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::NotEqual_ByteByte(char A, char B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_ByteByte");

	FNotEqual_ByteByte parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::NotEqual_BoolBool(bool A, bool B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_BoolBool");

	FNotEqual_BoolBool parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::Not_PreBool(bool A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Not_PreBool");

	FNot_PreBool parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int64_t UKismetMathLibrary::Not_Int64(int64_t A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Not_Int64");

	FNot_Int64 parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::Not_Int(int32_t A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Not_Int");

	FNot_Int parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector2D UKismetMathLibrary::NormalSafe2D(struct FVector2D A, float Tolerance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NormalSafe2D");

	FNormalSafe2D parms{};	
	parms.A = A;
	parms.Tolerance = Tolerance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::NormalizeToRange(double Value, double RangeMin, double RangeMax){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NormalizeToRange");

	FNormalizeToRange parms{};	
	parms.Value = Value;
	parms.RangeMin = RangeMin;
	parms.RangeMax = RangeMax;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator UKismetMathLibrary::NormalizedDeltaRotator(struct FRotator A, struct FRotator B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NormalizedDeltaRotator");

	FNormalizedDeltaRotator parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetMathLibrary::NormalizeAxis(float Angle){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NormalizeAxis");

	FNormalizeAxis parms{};	
	parms.Angle = Angle;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetMathLibrary::Normalize2D(struct FVector2D& A, float Tolerance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Normalize2D");

	FNormalize2D parms{};	
	parms.A = A;
	parms.Tolerance = Tolerance;

	ProcessEvent(fn, &parms);
}

struct FVector2D UKismetMathLibrary::Normal2D(struct FVector2D A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Normal2D");

	FNormal2D parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Normal(struct FVector A, float Tolerance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Normal");

	FNormal parms{};	
	parms.A = A;
	parms.Tolerance = Tolerance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::NegateVector(struct FVector A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NegateVector");

	FNegateVector parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator UKismetMathLibrary::NegateRotator(struct FRotator A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NegateRotator");

	FNegateRotator parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector2D UKismetMathLibrary::Negated2D(struct FVector2D& A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Negated2D");

	FNegated2D parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::NearlyEqual_TransformTransform(struct FTransform& A, struct FTransform& B, float LocationTolerance, float RotationTolerance, float Scale3DTolerance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NearlyEqual_TransformTransform");

	FNearlyEqual_TransformTransform parms{};	
	parms.A = A;
	parms.B = B;
	parms.LocationTolerance = LocationTolerance;
	parms.RotationTolerance = RotationTolerance;
	parms.Scale3DTolerance = Scale3DTolerance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::NearlyEqual_FloatFloat(double A, double B, double ErrorTolerance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NearlyEqual_FloatFloat");

	FNearlyEqual_FloatFloat parms{};	
	parms.A = A;
	parms.B = B;
	parms.ErrorTolerance = ErrorTolerance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::MultiplyMultiply_FloatFloat(double Base, double Exp){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MultiplyMultiply_FloatFloat");

	FMultiplyMultiply_FloatFloat parms{};	
	parms.Base = Base;
	parms.Exp = Exp;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::MultiplyByPi(double Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MultiplyByPi");

	FMultiplyByPi parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Multiply_VectorVector(struct FVector A, struct FVector B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_VectorVector");

	FMultiply_VectorVector parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Multiply_VectorInt(struct FVector A, int32_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_VectorInt");

	FMultiply_VectorInt parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Multiply_VectorFloat(struct FVector A, double B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_VectorFloat");

	FMultiply_VectorFloat parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector4 UKismetMathLibrary::Multiply_Vector4Vector4(struct FVector4& A, struct FVector4& B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_Vector4Vector4");

	FMultiply_Vector4Vector4 parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector2D UKismetMathLibrary::Multiply_Vector2DVector2D(struct FVector2D A, struct FVector2D B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_Vector2DVector2D");

	FMultiply_Vector2DVector2D parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector2D UKismetMathLibrary::Multiply_Vector2DFloat(struct FVector2D A, double B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_Vector2DFloat");

	FMultiply_Vector2DFloat parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTimespan UKismetMathLibrary::Multiply_TimespanFloat(struct FTimespan A, float Scalar){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_TimespanFloat");

	FMultiply_TimespanFloat parms{};	
	parms.A = A;
	parms.Scalar = Scalar;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator UKismetMathLibrary::Multiply_RotatorInt(struct FRotator A, int32_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_RotatorInt");

	FMultiply_RotatorInt parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator UKismetMathLibrary::Multiply_RotatorFloat(struct FRotator A, float B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_RotatorFloat");

	FMultiply_RotatorFloat parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FQuat UKismetMathLibrary::Multiply_QuatQuat(struct FQuat& A, struct FQuat& B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_QuatQuat");

	FMultiply_QuatQuat parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FMatrix UKismetMathLibrary::Multiply_MatrixMatrix(struct FMatrix& A, struct FMatrix& B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_MatrixMatrix");

	FMultiply_MatrixMatrix parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FMatrix UKismetMathLibrary::Multiply_MatrixFloat(struct FMatrix& A, double B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_MatrixFloat");

	FMultiply_MatrixFloat parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FLinearColor UKismetMathLibrary::Multiply_LinearColorLinearColor(struct FLinearColor A, struct FLinearColor B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_LinearColorLinearColor");

	FMultiply_LinearColorLinearColor parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FLinearColor UKismetMathLibrary::Multiply_LinearColorFloat(struct FLinearColor A, float B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_LinearColorFloat");

	FMultiply_LinearColorFloat parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FIntPoint UKismetMathLibrary::Multiply_IntPointIntPoint(struct FIntPoint A, struct FIntPoint B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_IntPointIntPoint");

	FMultiply_IntPointIntPoint parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FIntPoint UKismetMathLibrary::Multiply_IntPointInt(struct FIntPoint A, int32_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_IntPointInt");

	FMultiply_IntPointInt parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::Multiply_IntInt(int32_t A, int32_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_IntInt");

	FMultiply_IntInt parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Multiply_IntFloat(int32_t A, double B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_IntFloat");

	FMultiply_IntFloat parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int64_t UKismetMathLibrary::Multiply_Int64Int64(int64_t A, int64_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_Int64Int64");

	FMultiply_Int64Int64 parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Multiply_DoubleDouble(double A, double B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_DoubleDouble");

	FMultiply_DoubleDouble parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

char UKismetMathLibrary::Multiply_ByteByte(char A, char B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_ByteByte");

	FMultiply_ByteByte parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::MirrorVectorByNormal(struct FVector InVect, struct FVector InNormal){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MirrorVectorByNormal");

	FMirrorVectorByNormal parms{};	
	parms.InVect = InVect;
	parms.InNormal = InNormal;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetMathLibrary::MinOfIntArray(struct TArray<int32_t>& IntArray, int32_t& IndexOfMinValue, int32_t& MinValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MinOfIntArray");

	FMinOfIntArray parms{};	
	parms.IntArray = IntArray;
	parms.IndexOfMinValue = IndexOfMinValue;
	parms.MinValue = MinValue;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::MinOfFloatArray(struct TArray<float>& FloatArray, int32_t& IndexOfMinValue, float& MinValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MinOfFloatArray");

	FMinOfFloatArray parms{};	
	parms.FloatArray = FloatArray;
	parms.IndexOfMinValue = IndexOfMinValue;
	parms.MinValue = MinValue;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::MinOfByteArray(struct TArray<char>& ByteArray, int32_t& IndexOfMinValue, char& MinValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MinOfByteArray");

	FMinOfByteArray parms{};	
	parms.ByteArray = ByteArray;
	parms.IndexOfMinValue = IndexOfMinValue;
	parms.MinValue = MinValue;

	ProcessEvent(fn, &parms);
}

int64_t UKismetMathLibrary::MinInt64(int64_t A, int64_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MinInt64");

	FMinInt64 parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetMathLibrary::MinimumAreaRectangle(struct UObject* WorldContextObject, struct TArray<struct FVector>& InVerts, struct FVector& SampleSurfaceNormal, struct FVector& OutRectCenter, struct FRotator& OutRectRotation, float& OutSideLengthX, float& OutSideLengthY, bool bDebugDraw){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MinimumAreaRectangle");

	FMinimumAreaRectangle parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.InVerts = InVerts;
	parms.SampleSurfaceNormal = SampleSurfaceNormal;
	parms.OutRectCenter = OutRectCenter;
	parms.OutRectRotation = OutRectRotation;
	parms.OutSideLengthX = OutSideLengthX;
	parms.OutSideLengthY = OutSideLengthY;
	parms.bDebugDraw = bDebugDraw;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::MinAreaRectangle(struct UObject* WorldContextObject, struct TArray<struct FVector>& InPoints, struct FVector& SampleSurfaceNormal, struct FVector& OutRectCenter, struct FRotator& OutRectRotation, float& OutRectLengthX, float& OutRectLengthY, bool bDebugDraw){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MinAreaRectangle");

	FMinAreaRectangle parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.InPoints = InPoints;
	parms.SampleSurfaceNormal = SampleSurfaceNormal;
	parms.OutRectCenter = OutRectCenter;
	parms.OutRectRotation = OutRectRotation;
	parms.OutRectLengthX = OutRectLengthX;
	parms.OutRectLengthY = OutRectLengthY;
	parms.bDebugDraw = bDebugDraw;

	ProcessEvent(fn, &parms);
}

int32_t UKismetMathLibrary::Min(int32_t A, int32_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Min");

	FMin parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetMathLibrary::MedianOfIntArray(struct TArray<int32_t> IntArray, float& MedianValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MedianOfIntArray");

	FMedianOfIntArray parms{};	
	parms.IntArray = IntArray;
	parms.MedianValue = MedianValue;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::MaxOfIntArray(struct TArray<int32_t>& IntArray, int32_t& IndexOfMaxValue, int32_t& MaxValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MaxOfIntArray");

	FMaxOfIntArray parms{};	
	parms.IntArray = IntArray;
	parms.IndexOfMaxValue = IndexOfMaxValue;
	parms.MaxValue = MaxValue;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::MaxOfFloatArray(struct TArray<float>& FloatArray, int32_t& IndexOfMaxValue, float& MaxValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MaxOfFloatArray");

	FMaxOfFloatArray parms{};	
	parms.FloatArray = FloatArray;
	parms.IndexOfMaxValue = IndexOfMaxValue;
	parms.MaxValue = MaxValue;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::MaxOfByteArray(struct TArray<char>& ByteArray, int32_t& IndexOfMaxValue, char& MaxValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MaxOfByteArray");

	FMaxOfByteArray parms{};	
	parms.ByteArray = ByteArray;
	parms.IndexOfMaxValue = IndexOfMaxValue;
	parms.MaxValue = MaxValue;

	ProcessEvent(fn, &parms);
}

int64_t UKismetMathLibrary::MaxInt64(int64_t A, int64_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MaxInt64");

	FMaxInt64 parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::Max(int32_t A, int32_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Max");

	FMax parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector4 UKismetMathLibrary::Matrix_TransformVector4(struct FMatrix& M, struct FVector4 V){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_TransformVector4");

	FMatrix_TransformVector4 parms{};	
	parms.M = M;
	parms.V = V;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector4 UKismetMathLibrary::Matrix_TransformVector(struct FMatrix& M, struct FVector V){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_TransformVector");

	FMatrix_TransformVector parms{};	
	parms.M = M;
	parms.V = V;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector4 UKismetMathLibrary::Matrix_TransformPosition(struct FMatrix& M, struct FVector V){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_TransformPosition");

	FMatrix_TransformPosition parms{};	
	parms.M = M;
	parms.V = V;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FQuat UKismetMathLibrary::Matrix_ToQuat(struct FMatrix& M){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_ToQuat");

	FMatrix_ToQuat parms{};	
	parms.M = M;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetMathLibrary::Matrix_SetOrigin(struct FMatrix& M, struct FVector NewOrigin){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_SetOrigin");

	FMatrix_SetOrigin parms{};	
	parms.M = M;
	parms.NewOrigin = NewOrigin;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::Matrix_SetColumn(struct FMatrix& M, enum class EMatrixColumns column, struct FVector Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_SetColumn");

	FMatrix_SetColumn parms{};	
	parms.M = M;
	parms.column = column;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::Matrix_SetAxis(struct FMatrix& M, enum class EAxis Axis, struct FVector AxisVector){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_SetAxis");

	FMatrix_SetAxis parms{};	
	parms.M = M;
	parms.Axis = Axis;
	parms.AxisVector = AxisVector;

	ProcessEvent(fn, &parms);
}

struct FMatrix UKismetMathLibrary::Matrix_ScaleTranslation(struct FMatrix& M, struct FVector Scale3D){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_ScaleTranslation");

	FMatrix_ScaleTranslation parms{};	
	parms.M = M;
	parms.Scale3D = Scale3D;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FMatrix UKismetMathLibrary::Matrix_RemoveTranslation(struct FMatrix& M){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_RemoveTranslation");

	FMatrix_RemoveTranslation parms{};	
	parms.M = M;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetMathLibrary::Matrix_RemoveScaling(struct FMatrix& M, float Tolerance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_RemoveScaling");

	FMatrix_RemoveScaling parms{};	
	parms.M = M;
	parms.Tolerance = Tolerance;

	ProcessEvent(fn, &parms);
}

struct FMatrix UKismetMathLibrary::Matrix_Mirror(struct FMatrix& M, enum class EAxis MirrorAxis, enum class EAxis FlipAxis){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_Mirror");

	FMatrix_Mirror parms{};	
	parms.M = M;
	parms.MirrorAxis = MirrorAxis;
	parms.FlipAxis = FlipAxis;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Matrix_InverseTransformVector(struct FMatrix& M, struct FVector V){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_InverseTransformVector");

	FMatrix_InverseTransformVector parms{};	
	parms.M = M;
	parms.V = V;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Matrix_InverseTransformPosition(struct FMatrix& M, struct FVector V){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_InverseTransformPosition");

	FMatrix_InverseTransformPosition parms{};	
	parms.M = M;
	parms.V = V;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FMatrix UKismetMathLibrary::Matrix_Identity(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_Identity");

	FMatrix_Identity parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Matrix_GetUnitAxis(struct FMatrix& M, enum class EAxis Axis){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetUnitAxis");

	FMatrix_GetUnitAxis parms{};	
	parms.M = M;
	parms.Axis = Axis;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetMathLibrary::Matrix_GetUnitAxes(struct FMatrix& M, struct FVector& X, struct FVector& Y, struct FVector& Z){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetUnitAxes");

	FMatrix_GetUnitAxes parms{};	
	parms.M = M;
	parms.X = X;
	parms.Y = Y;
	parms.Z = Z;

	ProcessEvent(fn, &parms);
}

struct FMatrix UKismetMathLibrary::Matrix_GetTransposed(struct FMatrix& M){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetTransposed");

	FMatrix_GetTransposed parms{};	
	parms.M = M;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FMatrix UKismetMathLibrary::Matrix_GetTransposeAdjoint(struct FMatrix& M){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetTransposeAdjoint");

	FMatrix_GetTransposeAdjoint parms{};	
	parms.M = M;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Matrix_GetScaleVector(struct FMatrix& M, float Tolerance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetScaleVector");

	FMatrix_GetScaleVector parms{};	
	parms.M = M;
	parms.Tolerance = Tolerance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Matrix_GetScaledAxis(struct FMatrix& M, enum class EAxis Axis){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetScaledAxis");

	FMatrix_GetScaledAxis parms{};	
	parms.M = M;
	parms.Axis = Axis;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetMathLibrary::Matrix_GetScaledAxes(struct FMatrix& M, struct FVector& X, struct FVector& Y, struct FVector& Z){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetScaledAxes");

	FMatrix_GetScaledAxes parms{};	
	parms.M = M;
	parms.X = X;
	parms.Y = Y;
	parms.Z = Z;

	ProcessEvent(fn, &parms);
}

float UKismetMathLibrary::Matrix_GetRotDeterminant(struct FMatrix& M){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetRotDeterminant");

	FMatrix_GetRotDeterminant parms{};	
	parms.M = M;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator UKismetMathLibrary::Matrix_GetRotator(struct FMatrix& M){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetRotator");

	FMatrix_GetRotator parms{};	
	parms.M = M;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Matrix_GetOrigin(struct FMatrix& InMatrix){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetOrigin");

	FMatrix_GetOrigin parms{};	
	parms.InMatrix = InMatrix;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetMathLibrary::Matrix_GetMaximumAxisScale(struct FMatrix& M){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetMaximumAxisScale");

	FMatrix_GetMaximumAxisScale parms{};	
	parms.M = M;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FMatrix UKismetMathLibrary::Matrix_GetMatrixWithoutScale(struct FMatrix& M, float Tolerance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetMatrixWithoutScale");

	FMatrix_GetMatrixWithoutScale parms{};	
	parms.M = M;
	parms.Tolerance = Tolerance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FMatrix UKismetMathLibrary::Matrix_GetInverse(struct FMatrix& M){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetInverse");

	FMatrix_GetInverse parms{};	
	parms.M = M;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::Matrix_GetFrustumTopPlane(struct FMatrix& M, struct FPlane& OutPlane){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetFrustumTopPlane");

	FMatrix_GetFrustumTopPlane parms{};	
	parms.M = M;
	parms.OutPlane = OutPlane;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::Matrix_GetFrustumRightPlane(struct FMatrix& M, struct FPlane& OutPlane){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetFrustumRightPlane");

	FMatrix_GetFrustumRightPlane parms{};	
	parms.M = M;
	parms.OutPlane = OutPlane;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::Matrix_GetFrustumNearPlane(struct FMatrix& M, struct FPlane& OutPlane){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetFrustumNearPlane");

	FMatrix_GetFrustumNearPlane parms{};	
	parms.M = M;
	parms.OutPlane = OutPlane;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::Matrix_GetFrustumLeftPlane(struct FMatrix& M, struct FPlane& OutPlane){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetFrustumLeftPlane");

	FMatrix_GetFrustumLeftPlane parms{};	
	parms.M = M;
	parms.OutPlane = OutPlane;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::Matrix_GetFrustumFarPlane(struct FMatrix& M, struct FPlane& OutPlane){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetFrustumFarPlane");

	FMatrix_GetFrustumFarPlane parms{};	
	parms.M = M;
	parms.OutPlane = OutPlane;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::Matrix_GetFrustumBottomPlane(struct FMatrix& M, struct FPlane& OutPlane){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetFrustumBottomPlane");

	FMatrix_GetFrustumBottomPlane parms{};	
	parms.M = M;
	parms.OutPlane = OutPlane;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetMathLibrary::Matrix_GetDeterminant(struct FMatrix& M){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetDeterminant");

	FMatrix_GetDeterminant parms{};	
	parms.M = M;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Matrix_GetColumn(struct FMatrix& M, enum class EMatrixColumns column){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetColumn");

	FMatrix_GetColumn parms{};	
	parms.M = M;
	parms.column = column;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::Matrix_ContainsNaN(struct FMatrix& M){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_ContainsNaN");

	FMatrix_ContainsNaN parms{};	
	parms.M = M;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FMatrix UKismetMathLibrary::Matrix_ConcatenateTranslation(struct FMatrix& M, struct FVector Translation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_ConcatenateTranslation");

	FMatrix_ConcatenateTranslation parms{};	
	parms.M = M;
	parms.Translation = Translation;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FMatrix UKismetMathLibrary::Matrix_ApplyScale(struct FMatrix& M, float Scale){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_ApplyScale");

	FMatrix_ApplyScale parms{};	
	parms.M = M;
	parms.Scale = Scale;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::MapRangeUnclamped(double Value, double InRangeA, double InRangeB, double OutRangeA, double OutRangeB){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MapRangeUnclamped");

	FMapRangeUnclamped parms{};	
	parms.Value = Value;
	parms.InRangeA = InRangeA;
	parms.InRangeB = InRangeB;
	parms.OutRangeA = OutRangeA;
	parms.OutRangeB = OutRangeB;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::MapRangeClamped(double Value, double InRangeA, double InRangeB, double OutRangeA, double OutRangeB){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MapRangeClamped");

	FMapRangeClamped parms{};	
	parms.Value = Value;
	parms.InRangeA = InRangeA;
	parms.InRangeB = InRangeB;
	parms.OutRangeA = OutRangeA;
	parms.OutRangeB = OutRangeB;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector_NetQuantizeNormal UKismetMathLibrary::MakeVector_NetQuantizeNormal(double X, double Y, double Z){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeVector_NetQuantizeNormal");

	FMakeVector_NetQuantizeNormal parms{};	
	parms.X = X;
	parms.Y = Y;
	parms.Z = Z;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector_NetQuantize100 UKismetMathLibrary::MakeVector_NetQuantize100(double X, double Y, double Z){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeVector_NetQuantize100");

	FMakeVector_NetQuantize100 parms{};	
	parms.X = X;
	parms.Y = Y;
	parms.Z = Z;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector_NetQuantize10 UKismetMathLibrary::MakeVector_NetQuantize10(double X, double Y, double Z){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeVector_NetQuantize10");

	FMakeVector_NetQuantize10 parms{};	
	parms.X = X;
	parms.Y = Y;
	parms.Z = Z;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector_NetQuantize UKismetMathLibrary::MakeVector_NetQuantize(double X, double Y, double Z){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeVector_NetQuantize");

	FMakeVector_NetQuantize parms{};	
	parms.X = X;
	parms.Y = Y;
	parms.Z = Z;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector4 UKismetMathLibrary::MakeVector4(double X, double Y, double Z, double W){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeVector4");

	FMakeVector4 parms{};	
	parms.X = X;
	parms.Y = Y;
	parms.Z = Z;
	parms.W = W;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector2D UKismetMathLibrary::MakeVector2D(double X, double Y){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeVector2D");

	FMakeVector2D parms{};	
	parms.X = X;
	parms.Y = Y;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::MakeVector(double X, double Y, double Z){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeVector");

	FMakeVector parms{};	
	parms.X = X;
	parms.Y = Y;
	parms.Z = Z;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTransform UKismetMathLibrary::MakeTransform(struct FVector Location, struct FRotator Rotation, struct FVector Scale){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeTransform");

	FMakeTransform parms{};	
	parms.Location = Location;
	parms.Rotation = Rotation;
	parms.Scale = Scale;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTimespan UKismetMathLibrary::MakeTimespan2(int32_t Days, int32_t Hours, int32_t Minutes, int32_t Seconds, int32_t FractionNano){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeTimespan2");

	FMakeTimespan2 parms{};	
	parms.Days = Days;
	parms.Hours = Hours;
	parms.Minutes = Minutes;
	parms.Seconds = Seconds;
	parms.FractionNano = FractionNano;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTimespan UKismetMathLibrary::MakeTimespan(int32_t Days, int32_t Hours, int32_t Minutes, int32_t Seconds, int32_t Milliseconds){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeTimespan");

	FMakeTimespan parms{};	
	parms.Days = Days;
	parms.Hours = Hours;
	parms.Minutes = Minutes;
	parms.Seconds = Seconds;
	parms.Milliseconds = Milliseconds;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator UKismetMathLibrary::MakeRotFromZY(struct FVector& Z, struct FVector& Y){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromZY");

	FMakeRotFromZY parms{};	
	parms.Z = Z;
	parms.Y = Y;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator UKismetMathLibrary::MakeRotFromZX(struct FVector& Z, struct FVector& X){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromZX");

	FMakeRotFromZX parms{};	
	parms.Z = Z;
	parms.X = X;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator UKismetMathLibrary::MakeRotFromZ(struct FVector& Z){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromZ");

	FMakeRotFromZ parms{};	
	parms.Z = Z;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator UKismetMathLibrary::MakeRotFromYZ(struct FVector& Y, struct FVector& Z){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromYZ");

	FMakeRotFromYZ parms{};	
	parms.Y = Y;
	parms.Z = Z;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator UKismetMathLibrary::MakeRotFromYX(struct FVector& Y, struct FVector& X){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromYX");

	FMakeRotFromYX parms{};	
	parms.Y = Y;
	parms.X = X;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator UKismetMathLibrary::MakeRotFromY(struct FVector& Y){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromY");

	FMakeRotFromY parms{};	
	parms.Y = Y;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator UKismetMathLibrary::MakeRotFromXZ(struct FVector& X, struct FVector& Z){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromXZ");

	FMakeRotFromXZ parms{};	
	parms.X = X;
	parms.Z = Z;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator UKismetMathLibrary::MakeRotFromXY(struct FVector& X, struct FVector& Y){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromXY");

	FMakeRotFromXY parms{};	
	parms.X = X;
	parms.Y = Y;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator UKismetMathLibrary::MakeRotFromX(struct FVector& X){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromX");

	FMakeRotFromX parms{};	
	parms.X = X;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator UKismetMathLibrary::MakeRotator(float Roll, float Pitch, float Yaw){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotator");

	FMakeRotator parms{};	
	parms.Roll = Roll;
	parms.Pitch = Pitch;
	parms.Yaw = Yaw;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator UKismetMathLibrary::MakeRotationFromAxes(struct FVector Forward, struct FVector Right, struct FVector Up){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotationFromAxes");

	FMakeRotationFromAxes parms{};	
	parms.Forward = Forward;
	parms.Right = Right;
	parms.Up = Up;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTransform UKismetMathLibrary::MakeRelativeTransform(struct FTransform& A, struct FTransform& RelativeTo){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRelativeTransform");

	FMakeRelativeTransform parms{};	
	parms.A = A;
	parms.RelativeTo = RelativeTo;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRandomStream UKismetMathLibrary::MakeRandomStream(int32_t InitialSeed){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRandomStream");

	FMakeRandomStream parms{};	
	parms.InitialSeed = InitialSeed;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FQuat UKismetMathLibrary::MakeQuat(float X, float Y, float Z, float W){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeQuat");

	FMakeQuat parms{};	
	parms.X = X;
	parms.Y = Y;
	parms.Z = Z;
	parms.W = W;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FQualifiedFrameTime UKismetMathLibrary::MakeQualifiedFrameTime(struct FFrameNumber Frame, struct FFrameRate FrameRate, float SubFrame){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeQualifiedFrameTime");

	FMakeQualifiedFrameTime parms{};	
	parms.Frame = Frame;
	parms.FrameRate = FrameRate;
	parms.SubFrame = SubFrame;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetMathLibrary::MakePulsatingValue(float InCurrentTime, float InPulsesPerSecond, float InPhase){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakePulsatingValue");

	FMakePulsatingValue parms{};	
	parms.InCurrentTime = InCurrentTime;
	parms.InPulsesPerSecond = InPulsesPerSecond;
	parms.InPhase = InPhase;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FPlane UKismetMathLibrary::MakePlaneFromPointAndNormal(struct FVector Point, struct FVector Normal){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakePlaneFromPointAndNormal");

	FMakePlaneFromPointAndNormal parms{};	
	parms.Point = Point;
	parms.Normal = Normal;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FFrameRate UKismetMathLibrary::MakeFrameRate(int32_t Numerator, int32_t Denominator){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeFrameRate");

	FMakeFrameRate parms{};	
	parms.Numerator = Numerator;
	parms.Denominator = Denominator;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FDateTime UKismetMathLibrary::MakeDateTime(int32_t Year, int32_t Month, int32_t Day, int32_t Hour, int32_t Minute, int32_t Second, int32_t Millisecond){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeDateTime");

	FMakeDateTime parms{};	
	parms.Year = Year;
	parms.Month = Month;
	parms.Day = Day;
	parms.Hour = Hour;
	parms.Minute = Minute;
	parms.Second = Second;
	parms.Millisecond = Millisecond;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FLinearColor UKismetMathLibrary::MakeColor(float R, float G, float B, float A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeColor");

	FMakeColor parms{};	
	parms.R = R;
	parms.G = G;
	parms.B = B;
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FBoxSphereBounds UKismetMathLibrary::MakeBoxSphereBounds(struct FVector Origin, struct FVector BoxExtent, float SphereRadius){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeBoxSphereBounds");

	FMakeBoxSphereBounds parms{};	
	parms.Origin = Origin;
	parms.BoxExtent = BoxExtent;
	parms.SphereRadius = SphereRadius;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FBox2D UKismetMathLibrary::MakeBox2D(struct FVector2D Min, struct FVector2D Max){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeBox2D");

	FMakeBox2D parms{};	
	parms.Min = Min;
	parms.Max = Max;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FBox UKismetMathLibrary::MakeBox(struct FVector Min, struct FVector Max){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeBox");

	FMakeBox parms{};	
	parms.Min = Min;
	parms.Max = Max;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Loge(double A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Loge");

	FLoge parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Log(double A, double Base){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Log");

	FLog parms{};	
	parms.A = A;
	parms.Base = Base;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::LinePlaneIntersection_OriginNormal(struct FVector& LineStart, struct FVector& LineEnd, struct FVector PlaneOrigin, struct FVector PlaneNormal, float& T, struct FVector& Intersection){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinePlaneIntersection_OriginNormal");

	FLinePlaneIntersection_OriginNormal parms{};	
	parms.LineStart = LineStart;
	parms.LineEnd = LineEnd;
	parms.PlaneOrigin = PlaneOrigin;
	parms.PlaneNormal = PlaneNormal;
	parms.T = T;
	parms.Intersection = Intersection;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::LinePlaneIntersection(struct FVector& LineStart, struct FVector& LineEnd, struct FPlane& APlane, float& T, struct FVector& Intersection){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinePlaneIntersection");

	FLinePlaneIntersection parms{};	
	parms.LineStart = LineStart;
	parms.LineEnd = LineEnd;
	parms.APlane = APlane;
	parms.T = T;
	parms.Intersection = Intersection;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FLinearColor UKismetMathLibrary::LinearColorLerpUsingHSV(struct FLinearColor A, struct FLinearColor B, float Alpha){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColorLerpUsingHSV");

	FLinearColorLerpUsingHSV parms{};	
	parms.A = A;
	parms.B = B;
	parms.Alpha = Alpha;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FLinearColor UKismetMathLibrary::LinearColorLerp(struct FLinearColor A, struct FLinearColor B, float Alpha){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColorLerp");

	FLinearColorLerp parms{};	
	parms.A = A;
	parms.B = B;
	parms.Alpha = Alpha;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FLinearColor UKismetMathLibrary::LinearColor_Yellow(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_Yellow");

	FLinearColor_Yellow parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FLinearColor UKismetMathLibrary::LinearColor_White(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_White");

	FLinearColor_White parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FLinearColor UKismetMathLibrary::LinearColor_Transparent(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_Transparent");

	FLinearColor_Transparent parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FColor UKismetMathLibrary::LinearColor_ToRGBE(struct FLinearColor InLinearColor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_ToRGBE");

	FLinearColor_ToRGBE parms{};	
	parms.InLinearColor = InLinearColor;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FLinearColor UKismetMathLibrary::LinearColor_ToNewOpacity(struct FLinearColor InColor, float InOpacity){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_ToNewOpacity");

	FLinearColor_ToNewOpacity parms{};	
	parms.InColor = InColor;
	parms.InOpacity = InOpacity;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetMathLibrary::LinearColor_SetTemperature(struct FLinearColor& InOutColor, float InTemperature){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_SetTemperature");

	FLinearColor_SetTemperature parms{};	
	parms.InOutColor = InOutColor;
	parms.InTemperature = InTemperature;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::LinearColor_SetRGBA(struct FLinearColor& InOutColor, float R, float G, float B, float A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_SetRGBA");

	FLinearColor_SetRGBA parms{};	
	parms.InOutColor = InOutColor;
	parms.R = R;
	parms.G = G;
	parms.B = B;
	parms.A = A;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::LinearColor_SetRandomHue(struct FLinearColor& InOutColor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_SetRandomHue");

	FLinearColor_SetRandomHue parms{};	
	parms.InOutColor = InOutColor;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::LinearColor_SetFromSRGB(struct FLinearColor& InOutColor, struct FColor& InSRGB){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_SetFromSRGB");

	FLinearColor_SetFromSRGB parms{};	
	parms.InOutColor = InOutColor;
	parms.InSRGB = InSRGB;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::LinearColor_SetFromPow22(struct FLinearColor& InOutColor, struct FColor& InColor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_SetFromPow22");

	FLinearColor_SetFromPow22 parms{};	
	parms.InOutColor = InOutColor;
	parms.InColor = InColor;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::LinearColor_SetFromHSV(struct FLinearColor& InOutColor, float H, float S, float V, float A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_SetFromHSV");

	FLinearColor_SetFromHSV parms{};	
	parms.InOutColor = InOutColor;
	parms.H = H;
	parms.S = S;
	parms.V = V;
	parms.A = A;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::LinearColor_Set(struct FLinearColor& InOutColor, struct FLinearColor InColor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_Set");

	FLinearColor_Set parms{};	
	parms.InOutColor = InOutColor;
	parms.InColor = InColor;

	ProcessEvent(fn, &parms);
}

struct FLinearColor UKismetMathLibrary::LinearColor_Red(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_Red");

	FLinearColor_Red parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FColor UKismetMathLibrary::LinearColor_QuantizeRound(struct FLinearColor InColor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_QuantizeRound");

	FLinearColor_QuantizeRound parms{};	
	parms.InColor = InColor;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FColor UKismetMathLibrary::LinearColor_Quantize(struct FLinearColor InColor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_Quantize");

	FLinearColor_Quantize parms{};	
	parms.InColor = InColor;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::LinearColor_IsNearEqual(struct FLinearColor A, struct FLinearColor B, float Tolerance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_IsNearEqual");

	FLinearColor_IsNearEqual parms{};	
	parms.A = A;
	parms.B = B;
	parms.Tolerance = Tolerance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FLinearColor UKismetMathLibrary::LinearColor_Green(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_Green");

	FLinearColor_Green parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FLinearColor UKismetMathLibrary::LinearColor_Gray(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_Gray");

	FLinearColor_Gray parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetMathLibrary::LinearColor_GetMin(struct FLinearColor InColor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_GetMin");

	FLinearColor_GetMin parms{};	
	parms.InColor = InColor;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetMathLibrary::LinearColor_GetMax(struct FLinearColor InColor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_GetMax");

	FLinearColor_GetMax parms{};	
	parms.InColor = InColor;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetMathLibrary::LinearColor_GetLuminance(struct FLinearColor InColor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_GetLuminance");

	FLinearColor_GetLuminance parms{};	
	parms.InColor = InColor;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetMathLibrary::LinearColor_Distance(struct FLinearColor C1, struct FLinearColor C2){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_Distance");

	FLinearColor_Distance parms{};	
	parms.C1 = C1;
	parms.C2 = C2;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FLinearColor UKismetMathLibrary::LinearColor_Desaturated(struct FLinearColor InColor, float InDesaturation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_Desaturated");

	FLinearColor_Desaturated parms{};	
	parms.InColor = InColor;
	parms.InDesaturation = InDesaturation;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FLinearColor UKismetMathLibrary::LinearColor_Blue(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_Blue");

	FLinearColor_Blue parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FLinearColor UKismetMathLibrary::LinearColor_Black(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_Black");

	FLinearColor_Black parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::LessLess_VectorRotator(struct FVector A, struct FRotator B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LessLess_VectorRotator");

	FLessLess_VectorRotator parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::LessEqual_TimespanTimespan(struct FTimespan A, struct FTimespan B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LessEqual_TimespanTimespan");

	FLessEqual_TimespanTimespan parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::LessEqual_IntInt(int32_t A, int32_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LessEqual_IntInt");

	FLessEqual_IntInt parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::LessEqual_Int64Int64(int64_t A, int64_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LessEqual_Int64Int64");

	FLessEqual_Int64Int64 parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::LessEqual_DoubleDouble(double A, double B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LessEqual_DoubleDouble");

	FLessEqual_DoubleDouble parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::LessEqual_DateTimeDateTime(struct FDateTime A, struct FDateTime B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LessEqual_DateTimeDateTime");

	FLessEqual_DateTimeDateTime parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::LessEqual_ByteByte(char A, char B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LessEqual_ByteByte");

	FLessEqual_ByteByte parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::Less_TimespanTimespan(struct FTimespan A, struct FTimespan B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Less_TimespanTimespan");

	FLess_TimespanTimespan parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::Less_IntInt(int32_t A, int32_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Less_IntInt");

	FLess_IntInt parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::Less_Int64Int64(int64_t A, int64_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Less_Int64Int64");

	FLess_Int64Int64 parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::Less_DoubleDouble(double A, double B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Less_DoubleDouble");

	FLess_DoubleDouble parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::Less_DateTimeDateTime(struct FDateTime A, struct FDateTime B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Less_DateTimeDateTime");

	FLess_DateTimeDateTime parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::Less_ByteByte(char A, char B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Less_ByteByte");

	FLess_ByteByte parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Lerp(double A, double B, double Alpha){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Lerp");

	FLerp parms{};	
	parms.A = A;
	parms.B = B;
	parms.Alpha = Alpha;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::IsZero2D(struct FVector2D& A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.IsZero2D");

	FIsZero2D parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::IsPointInBoxWithTransform_Box(struct FVector Point, struct FTransform& BoxWorldTransform, struct FBox BoxExtent){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.IsPointInBoxWithTransform_Box");

	FIsPointInBoxWithTransform_Box parms{};	
	parms.Point = Point;
	parms.BoxWorldTransform = BoxWorldTransform;
	parms.BoxExtent = BoxExtent;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::IsPointInBoxWithTransform(struct FVector Point, struct FTransform& BoxWorldTransform, struct FVector BoxExtent){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.IsPointInBoxWithTransform");

	FIsPointInBoxWithTransform parms{};	
	parms.Point = Point;
	parms.BoxWorldTransform = BoxWorldTransform;
	parms.BoxExtent = BoxExtent;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::IsPointInBox_Box(struct FVector Point, struct FBox Box){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.IsPointInBox_Box");

	FIsPointInBox_Box parms{};	
	parms.Point = Point;
	parms.Box = Box;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::IsPointInBox(struct FVector Point, struct FVector BoxOrigin, struct FVector BoxExtent){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.IsPointInBox");

	FIsPointInBox parms{};	
	parms.Point = Point;
	parms.BoxOrigin = BoxOrigin;
	parms.BoxExtent = BoxExtent;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::IsNearlyZero2D(struct FVector2D& A, float Tolerance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.IsNearlyZero2D");

	FIsNearlyZero2D parms{};	
	parms.A = A;
	parms.Tolerance = Tolerance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::IsMorning(struct FDateTime A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.IsMorning");

	FIsMorning parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::IsLeapYear(int32_t Year){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.IsLeapYear");

	FIsLeapYear parms{};	
	parms.Year = Year;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::IsAfternoon(struct FDateTime A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.IsAfternoon");

	FIsAfternoon parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTransform UKismetMathLibrary::InvertTransform(struct FTransform& T){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.InvertTransform");

	FInvertTransform parms{};	
	parms.T = T;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator UKismetMathLibrary::InverseTransformRotation(struct FTransform& T, struct FRotator Rotation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.InverseTransformRotation");

	FInverseTransformRotation parms{};	
	parms.T = T;
	parms.Rotation = Rotation;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::InverseTransformLocation(struct FTransform& T, struct FVector Location){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.InverseTransformLocation");

	FInverseTransformLocation parms{};	
	parms.T = T;
	parms.Location = Location;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::InverseTransformDirection(struct FTransform& T, struct FVector Direction){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.InverseTransformDirection");

	FInverseTransformDirection parms{};	
	parms.T = T;
	parms.Direction = Direction;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FIntPoint UKismetMathLibrary::IntPoint_Zero(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.IntPoint_Zero");

	FIntPoint_Zero parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FIntPoint UKismetMathLibrary::IntPoint_Up(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.IntPoint_Up");

	FIntPoint_Up parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FIntPoint UKismetMathLibrary::IntPoint_Right(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.IntPoint_Right");

	FIntPoint_Right parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FIntPoint UKismetMathLibrary::IntPoint_One(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.IntPoint_One");

	FIntPoint_One parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FIntPoint UKismetMathLibrary::IntPoint_Left(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.IntPoint_Left");

	FIntPoint_Left parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FIntPoint UKismetMathLibrary::IntPoint_Down(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.IntPoint_Down");

	FIntPoint_Down parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::InRange_IntInt(int32_t Value, int32_t Min, int32_t Max, bool InclusiveMin, bool InclusiveMax){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.InRange_IntInt");

	FInRange_IntInt parms{};	
	parms.Value = Value;
	parms.Min = Min;
	parms.Max = Max;
	parms.InclusiveMin = InclusiveMin;
	parms.InclusiveMax = InclusiveMax;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::InRange_Int64Int64(int64_t Value, int64_t Min, int64_t Max, bool InclusiveMin, bool InclusiveMax){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.InRange_Int64Int64");

	FInRange_Int64Int64 parms{};	
	parms.Value = Value;
	parms.Min = Min;
	parms.Max = Max;
	parms.InclusiveMin = InclusiveMin;
	parms.InclusiveMax = InclusiveMax;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::InRange_FloatFloat(double Value, double Min, double Max, bool InclusiveMin, bool InclusiveMax){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.InRange_FloatFloat");

	FInRange_FloatFloat parms{};	
	parms.Value = Value;
	parms.Min = Min;
	parms.Max = Max;
	parms.InclusiveMin = InclusiveMin;
	parms.InclusiveMax = InclusiveMax;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Hypotenuse(double Width, double Height){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Hypotenuse");

	FHypotenuse parms{};	
	parms.Width = Width;
	parms.Height = Height;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FLinearColor UKismetMathLibrary::HSVToRGBLinear(struct FLinearColor HSV){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.HSVToRGBLinear");

	FHSVToRGBLinear parms{};	
	parms.HSV = HSV;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetMathLibrary::HSVToRGB_Vector(struct FLinearColor HSV, struct FLinearColor& RGB){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.HSVToRGB_Vector");

	FHSVToRGB_Vector parms{};	
	parms.HSV = HSV;
	parms.RGB = RGB;

	ProcessEvent(fn, &parms);
}

struct FLinearColor UKismetMathLibrary::HSVToRGB(float H, float S, float V, float A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.HSVToRGB");

	FHSVToRGB parms{};	
	parms.H = H;
	parms.S = S;
	parms.V = V;
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::GridSnap_Float(double Location, double GridSize){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GridSnap_Float");

	FGridSnap_Float parms{};	
	parms.Location = Location;
	parms.GridSize = GridSize;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::GreaterGreater_VectorRotator(struct FVector A, struct FRotator B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GreaterGreater_VectorRotator");

	FGreaterGreater_VectorRotator parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::GreaterEqual_TimespanTimespan(struct FTimespan A, struct FTimespan B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GreaterEqual_TimespanTimespan");

	FGreaterEqual_TimespanTimespan parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::GreaterEqual_IntInt(int32_t A, int32_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GreaterEqual_IntInt");

	FGreaterEqual_IntInt parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::GreaterEqual_Int64Int64(int64_t A, int64_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GreaterEqual_Int64Int64");

	FGreaterEqual_Int64Int64 parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::GreaterEqual_DoubleDouble(double A, double B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GreaterEqual_DoubleDouble");

	FGreaterEqual_DoubleDouble parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::GreaterEqual_DateTimeDateTime(struct FDateTime A, struct FDateTime B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GreaterEqual_DateTimeDateTime");

	FGreaterEqual_DateTimeDateTime parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::GreaterEqual_ByteByte(char A, char B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GreaterEqual_ByteByte");

	FGreaterEqual_ByteByte parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::Greater_TimespanTimespan(struct FTimespan A, struct FTimespan B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Greater_TimespanTimespan");

	FGreater_TimespanTimespan parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::Greater_IntInt(int32_t A, int32_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Greater_IntInt");

	FGreater_IntInt parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::Greater_Int64Int64(int64_t A, int64_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Greater_Int64Int64");

	FGreater_Int64Int64 parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::Greater_DoubleDouble(double A, double B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Greater_DoubleDouble");

	FGreater_DoubleDouble parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::Greater_DateTimeDateTime(struct FDateTime A, struct FDateTime B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Greater_DateTimeDateTime");

	FGreater_DateTimeDateTime parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::Greater_ByteByte(char A, char B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Greater_ByteByte");

	FGreater_ByteByte parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::GetYear(struct FDateTime A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetYear");

	FGetYear parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetMathLibrary::GetYawPitchFromVector(struct FVector InVec, float& Yaw, float& Pitch){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetYawPitchFromVector");

	FGetYawPitchFromVector parms{};	
	parms.InVec = InVec;
	parms.Yaw = Yaw;
	parms.Pitch = Pitch;

	ProcessEvent(fn, &parms);
}

struct FVector UKismetMathLibrary::GetVectorArrayAverage(struct TArray<struct FVector>& Vectors){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetVectorArrayAverage");

	FGetVectorArrayAverage parms{};	
	parms.Vectors = Vectors;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::GetUpVector(struct FRotator InRot){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetUpVector");

	FGetUpVector parms{};	
	parms.InRot = InRot;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetMathLibrary::GetTotalSeconds(struct FTimespan A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetTotalSeconds");

	FGetTotalSeconds parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetMathLibrary::GetTotalMinutes(struct FTimespan A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetTotalMinutes");

	FGetTotalMinutes parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetMathLibrary::GetTotalMilliseconds(struct FTimespan A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetTotalMilliseconds");

	FGetTotalMilliseconds parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetMathLibrary::GetTotalHours(struct FTimespan A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetTotalHours");

	FGetTotalHours parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetMathLibrary::GetTotalDays(struct FTimespan A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetTotalDays");

	FGetTotalDays parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTimespan UKismetMathLibrary::GetTimeOfDay(struct FDateTime A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetTimeOfDay");

	FGetTimeOfDay parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::GetTAU(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetTAU");

	FGetTAU parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetMathLibrary::GetSlopeDegreeAngles(struct FVector& MyRightYAxis, struct FVector& FloorNormal, struct FVector& UpVector, float& OutSlopePitchDegreeAngle, float& OutSlopeRollDegreeAngle){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetSlopeDegreeAngles");

	FGetSlopeDegreeAngles parms{};	
	parms.MyRightYAxis = MyRightYAxis;
	parms.FloorNormal = FloorNormal;
	parms.UpVector = UpVector;
	parms.OutSlopePitchDegreeAngle = OutSlopePitchDegreeAngle;
	parms.OutSlopeRollDegreeAngle = OutSlopeRollDegreeAngle;

	ProcessEvent(fn, &parms);
}

int32_t UKismetMathLibrary::GetSeconds(struct FTimespan A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetSeconds");

	FGetSeconds parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::GetSecond(struct FDateTime A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetSecond");

	FGetSecond parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector2D UKismetMathLibrary::GetRotated2D(struct FVector2D A, float AngleDeg){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetRotated2D");

	FGetRotated2D parms{};	
	parms.A = A;
	parms.AngleDeg = AngleDeg;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::GetRightVector(struct FRotator InRot){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetRightVector");

	FGetRightVector parms{};	
	parms.InRot = InRot;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::GetReflectionVector(struct FVector Direction, struct FVector SurfaceNormal){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetReflectionVector");

	FGetReflectionVector parms{};	
	parms.Direction = Direction;
	parms.SurfaceNormal = SurfaceNormal;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetMathLibrary::GetPointDistanceToSegment(struct FVector Point, struct FVector SegmentStart, struct FVector SegmentEnd){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetPointDistanceToSegment");

	FGetPointDistanceToSegment parms{};	
	parms.Point = Point;
	parms.SegmentStart = SegmentStart;
	parms.SegmentEnd = SegmentEnd;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetMathLibrary::GetPointDistanceToLine(struct FVector Point, struct FVector LineOrigin, struct FVector LineDirection){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetPointDistanceToLine");

	FGetPointDistanceToLine parms{};	
	parms.Point = Point;
	parms.LineOrigin = LineOrigin;
	parms.LineDirection = LineDirection;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::GetPI(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetPI");

	FGetPI parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::GetMonth(struct FDateTime A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMonth");

	FGetMonth parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::GetMinutes(struct FTimespan A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMinutes");

	FGetMinutes parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::GetMinute(struct FDateTime A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMinute");

	FGetMinute parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::GetMinElement(struct FVector A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMinElement");

	FGetMinElement parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::GetMin2D(struct FVector2D A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMin2D");

	FGetMin2D parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::GetMilliseconds(struct FTimespan A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMilliseconds");

	FGetMilliseconds parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::GetMillisecond(struct FDateTime A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMillisecond");

	FGetMillisecond parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::GetMaxElement(struct FVector A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMaxElement");

	FGetMaxElement parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::GetMax2D(struct FVector2D A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMax2D");

	FGetMax2D parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::GetHours(struct FTimespan A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetHours");

	FGetHours parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::GetHour12(struct FDateTime A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetHour12");

	FGetHour12 parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::GetHour(struct FDateTime A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetHour");

	FGetHour parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::GetForwardVector(struct FRotator InRot){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetForwardVector");

	FGetForwardVector parms{};	
	parms.InRot = InRot;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTimespan UKismetMathLibrary::GetDuration(struct FTimespan A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetDuration");

	FGetDuration parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::GetDirectionUnitVector(struct FVector From, struct FVector To){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetDirectionUnitVector");

	FGetDirectionUnitVector parms{};	
	parms.From = From;
	parms.To = To;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::GetDays(struct FTimespan A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetDays");

	FGetDays parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::GetDayOfYear(struct FDateTime A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetDayOfYear");

	FGetDayOfYear parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::GetDay(struct FDateTime A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetDay");

	FGetDay parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FDateTime UKismetMathLibrary::GetDate(struct FDateTime A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetDate");

	FGetDate parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetMathLibrary::GetAzimuthAndElevation(struct FVector InDirection, struct FTransform& ReferenceFrame, float& Azimuth, float& Elevation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetAzimuthAndElevation");

	FGetAzimuthAndElevation parms{};	
	parms.InDirection = InDirection;
	parms.ReferenceFrame = ReferenceFrame;
	parms.Azimuth = Azimuth;
	parms.Elevation = Elevation;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::GetAxes(struct FRotator A, struct FVector& X, struct FVector& Y, struct FVector& Z){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetAxes");

	FGetAxes parms{};	
	parms.A = A;
	parms.X = X;
	parms.Y = Y;
	parms.Z = Z;

	ProcessEvent(fn, &parms);
}

double UKismetMathLibrary::GetAbsMax2D(struct FVector2D A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetAbsMax2D");

	FGetAbsMax2D parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector2D UKismetMathLibrary::GetAbs2D(struct FVector2D A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetAbs2D");

	FGetAbs2D parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::FWrap(double Value, double Min, double Max){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FWrap");

	FFWrap parms{};	
	parms.Value = Value;
	parms.Min = Min;
	parms.Max = Max;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FIntVector UKismetMathLibrary::FTruncVector(struct FVector& InVector){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FTruncVector");

	FFTruncVector parms{};	
	parms.InVector = InVector;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int64_t UKismetMathLibrary::FTrunc64(double A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FTrunc64");

	FFTrunc64 parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::FTrunc(double A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FTrunc");

	FFTrunc parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTimespan UKismetMathLibrary::FromSeconds(float Seconds){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FromSeconds");

	FFromSeconds parms{};	
	parms.Seconds = Seconds;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTimespan UKismetMathLibrary::FromMinutes(float Minutes){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FromMinutes");

	FFromMinutes parms{};	
	parms.Minutes = Minutes;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTimespan UKismetMathLibrary::FromMilliseconds(float Milliseconds){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FromMilliseconds");

	FFromMilliseconds parms{};	
	parms.Milliseconds = Milliseconds;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTimespan UKismetMathLibrary::FromHours(float Hours){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FromHours");

	FFromHours parms{};	
	parms.Hours = Hours;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTimespan UKismetMathLibrary::FromDays(float Days){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FromDays");

	FFromDays parms{};	
	parms.Days = Days;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Fraction(double A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Fraction");

	FFraction parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int64_t UKismetMathLibrary::FMod64(double Dividend, double Divisor, double& Remainder){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FMod64");

	FFMod64 parms{};	
	parms.Dividend = Dividend;
	parms.Divisor = Divisor;
	parms.Remainder = Remainder;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::FMod(double Dividend, double Divisor, double& Remainder){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FMod");

	FFMod parms{};	
	parms.Dividend = Dividend;
	parms.Divisor = Divisor;
	parms.Remainder = Remainder;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::FMin(double A, double B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FMin");

	FFMin parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::FMax(double A, double B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FMax");

	FFMax parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetMathLibrary::FloatSpringInterp(float Current, float Target, struct FFloatSpringState& SpringState, float Stiffness, float CriticalDampingFactor, float DeltaTime, float Mass, float TargetVelocityAmount, bool bClamp, float MinValue, float MaxValue, bool bInitializeFromTarget){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FloatSpringInterp");

	FFloatSpringInterp parms{};	
	parms.Current = Current;
	parms.Target = Target;
	parms.SpringState = SpringState;
	parms.Stiffness = Stiffness;
	parms.CriticalDampingFactor = CriticalDampingFactor;
	parms.DeltaTime = DeltaTime;
	parms.Mass = Mass;
	parms.TargetVelocityAmount = TargetVelocityAmount;
	parms.bClamp = bClamp;
	parms.MinValue = MinValue;
	parms.MaxValue = MaxValue;
	parms.bInitializeFromTarget = bInitializeFromTarget;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetMathLibrary::FixedTurn(float InCurrent, float InDesired, float InDeltaRate){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FixedTurn");

	FFixedTurn parms{};	
	parms.InCurrent = InCurrent;
	parms.InDesired = InDesired;
	parms.InDeltaRate = InDeltaRate;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::FInterpTo_Constant(double Current, double Target, double DeltaTime, double InterpSpeed){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FInterpTo_Constant");

	FFInterpTo_Constant parms{};	
	parms.Current = Current;
	parms.Target = Target;
	parms.DeltaTime = DeltaTime;
	parms.InterpSpeed = InterpSpeed;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::FInterpTo(double Current, double Target, double DeltaTime, double InterpSpeed){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FInterpTo");

	FFInterpTo parms{};	
	parms.Current = Current;
	parms.Target = Target;
	parms.DeltaTime = DeltaTime;
	parms.InterpSpeed = InterpSpeed;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::FInterpEaseInOut(double A, double B, double Alpha, double Exponent){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FInterpEaseInOut");

	FFInterpEaseInOut parms{};	
	parms.A = A;
	parms.B = B;
	parms.Alpha = Alpha;
	parms.Exponent = Exponent;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator UKismetMathLibrary::FindRelativeLookAtRotation(struct FTransform& StartTransform, struct FVector& TargetLocation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FindRelativeLookAtRotation");

	FFindRelativeLookAtRotation parms{};	
	parms.StartTransform = StartTransform;
	parms.TargetLocation = TargetLocation;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetMathLibrary::FindNearestPointsOnLineSegments(struct FVector Segment1Start, struct FVector Segment1End, struct FVector Segment2Start, struct FVector Segment2End, struct FVector& Segment1Point, struct FVector& Segment2Point){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FindNearestPointsOnLineSegments");

	FFindNearestPointsOnLineSegments parms{};	
	parms.Segment1Start = Segment1Start;
	parms.Segment1End = Segment1End;
	parms.Segment2Start = Segment2Start;
	parms.Segment2End = Segment2End;
	parms.Segment1Point = Segment1Point;
	parms.Segment2Point = Segment2Point;

	ProcessEvent(fn, &parms);
}

struct FRotator UKismetMathLibrary::FindLookAtRotation(struct FVector& Start, struct FVector& Target){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FindLookAtRotation");

	FFindLookAtRotation parms{};	
	parms.Start = Start;
	parms.Target = Target;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::FindClosestPointOnSegment(struct FVector Point, struct FVector SegmentStart, struct FVector SegmentEnd){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FindClosestPointOnSegment");

	FFindClosestPointOnSegment parms{};	
	parms.Point = Point;
	parms.SegmentStart = SegmentStart;
	parms.SegmentEnd = SegmentEnd;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::FindClosestPointOnLine(struct FVector Point, struct FVector LineOrigin, struct FVector LineDirection){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FindClosestPointOnLine");

	FFindClosestPointOnLine parms{};	
	parms.Point = Point;
	parms.LineOrigin = LineOrigin;
	parms.LineDirection = LineDirection;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int64_t UKismetMathLibrary::FFloor64(double A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FFloor64");

	FFFloor64 parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::FFloor(double A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FFloor");

	FFFloor parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::FClamp(double Value, double Min, double Max){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FClamp");

	FFClamp parms{};	
	parms.Value = Value;
	parms.Min = Min;
	parms.Max = Max;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int64_t UKismetMathLibrary::FCeil64(double A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FCeil64");

	FFCeil64 parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::FCeil(double A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FCeil");

	FFCeil parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Exp(double A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Exp");

	FExp parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::EqualExactly_VectorVector(struct FVector A, struct FVector B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualExactly_VectorVector");

	FEqualExactly_VectorVector parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::EqualExactly_Vector4Vector4(struct FVector4& A, struct FVector4& B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualExactly_Vector4Vector4");

	FEqualExactly_Vector4Vector4 parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::EqualExactly_Vector2DVector2D(struct FVector2D A, struct FVector2D B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualExactly_Vector2DVector2D");

	FEqualExactly_Vector2DVector2D parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::EqualEqual_VectorVector(struct FVector A, struct FVector B, float ErrorTolerance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_VectorVector");

	FEqualEqual_VectorVector parms{};	
	parms.A = A;
	parms.B = B;
	parms.ErrorTolerance = ErrorTolerance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::EqualEqual_Vector4Vector4(struct FVector4& A, struct FVector4& B, float ErrorTolerance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_Vector4Vector4");

	FEqualEqual_Vector4Vector4 parms{};	
	parms.A = A;
	parms.B = B;
	parms.ErrorTolerance = ErrorTolerance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::EqualEqual_Vector2DVector2D(struct FVector2D A, struct FVector2D B, float ErrorTolerance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_Vector2DVector2D");

	FEqualEqual_Vector2DVector2D parms{};	
	parms.A = A;
	parms.B = B;
	parms.ErrorTolerance = ErrorTolerance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::EqualEqual_TransformTransform(struct FTransform& A, struct FTransform& B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_TransformTransform");

	FEqualEqual_TransformTransform parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::EqualEqual_TimespanTimespan(struct FTimespan A, struct FTimespan B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_TimespanTimespan");

	FEqualEqual_TimespanTimespan parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::EqualEqual_RotatorRotator(struct FRotator A, struct FRotator B, float ErrorTolerance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_RotatorRotator");

	FEqualEqual_RotatorRotator parms{};	
	parms.A = A;
	parms.B = B;
	parms.ErrorTolerance = ErrorTolerance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::EqualEqual_QuatQuat(struct FQuat& A, struct FQuat& B, float Tolerance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_QuatQuat");

	FEqualEqual_QuatQuat parms{};	
	parms.A = A;
	parms.B = B;
	parms.Tolerance = Tolerance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::EqualEqual_ObjectObject(struct UObject* A, struct UObject* B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_ObjectObject");

	FEqualEqual_ObjectObject parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::EqualEqual_NameName(struct FName A, struct FName B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_NameName");

	FEqualEqual_NameName parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::EqualEqual_MatrixMatrix(struct FMatrix& A, struct FMatrix& B, float Tolerance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_MatrixMatrix");

	FEqualEqual_MatrixMatrix parms{};	
	parms.A = A;
	parms.B = B;
	parms.Tolerance = Tolerance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::EqualEqual_LinearColorLinearColor(struct FLinearColor A, struct FLinearColor B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_LinearColorLinearColor");

	FEqualEqual_LinearColorLinearColor parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::EqualEqual_IntInt(int32_t A, int32_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_IntInt");

	FEqualEqual_IntInt parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::EqualEqual_Int64Int64(int64_t A, int64_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_Int64Int64");

	FEqualEqual_Int64Int64 parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::EqualEqual_DoubleDouble(double A, double B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_DoubleDouble");

	FEqualEqual_DoubleDouble parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::EqualEqual_DateTimeDateTime(struct FDateTime A, struct FDateTime B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_DateTimeDateTime");

	FEqualEqual_DateTimeDateTime parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::EqualEqual_ClassClass(UObject* A, UObject* B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_ClassClass");

	FEqualEqual_ClassClass parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::EqualEqual_ByteByte(char A, char B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_ByteByte");

	FEqualEqual_ByteByte parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::EqualEqual_BoolBool(bool A, bool B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_BoolBool");

	FEqualEqual_BoolBool parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::Equal_IntPointIntPoint(struct FIntPoint A, struct FIntPoint B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Equal_IntPointIntPoint");

	FEqual_IntPointIntPoint parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Ease(double A, double B, double Alpha, enum class EEasingFunc EasingFunc, double BlendExp, int32_t Steps){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Ease");

	FEase parms{};	
	parms.A = A;
	parms.B = B;
	parms.Alpha = Alpha;
	parms.EasingFunc = EasingFunc;
	parms.BlendExp = BlendExp;
	parms.Steps = Steps;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::DynamicWeightedMovingAverage_FVector(struct FVector CurrentSample, struct FVector PreviousSample, float MaxDistance, float MinWeight, float MaxWeight){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DynamicWeightedMovingAverage_FVector");

	FDynamicWeightedMovingAverage_FVector parms{};	
	parms.CurrentSample = CurrentSample;
	parms.PreviousSample = PreviousSample;
	parms.MaxDistance = MaxDistance;
	parms.MinWeight = MinWeight;
	parms.MaxWeight = MaxWeight;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator UKismetMathLibrary::DynamicWeightedMovingAverage_FRotator(struct FRotator CurrentSample, struct FRotator PreviousSample, float MaxDistance, float MinWeight, float MaxWeight){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DynamicWeightedMovingAverage_FRotator");

	FDynamicWeightedMovingAverage_FRotator parms{};	
	parms.CurrentSample = CurrentSample;
	parms.PreviousSample = PreviousSample;
	parms.MaxDistance = MaxDistance;
	parms.MinWeight = MinWeight;
	parms.MaxWeight = MaxWeight;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetMathLibrary::DynamicWeightedMovingAverage_Float(float CurrentSample, float PreviousSample, float MaxDistance, float MinWeight, float MaxWeight){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DynamicWeightedMovingAverage_Float");

	FDynamicWeightedMovingAverage_Float parms{};	
	parms.CurrentSample = CurrentSample;
	parms.PreviousSample = PreviousSample;
	parms.MaxDistance = MaxDistance;
	parms.MinWeight = MinWeight;
	parms.MaxWeight = MaxWeight;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::DotProduct2D(struct FVector2D A, struct FVector2D B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DotProduct2D");

	FDotProduct2D parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Dot_VectorVector(struct FVector A, struct FVector B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Dot_VectorVector");

	FDot_VectorVector parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Divide_VectorVector(struct FVector A, struct FVector B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_VectorVector");

	FDivide_VectorVector parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Divide_VectorInt(struct FVector A, int32_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_VectorInt");

	FDivide_VectorInt parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Divide_VectorFloat(struct FVector A, double B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_VectorFloat");

	FDivide_VectorFloat parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector4 UKismetMathLibrary::Divide_Vector4Vector4(struct FVector4& A, struct FVector4& B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_Vector4Vector4");

	FDivide_Vector4Vector4 parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector2D UKismetMathLibrary::Divide_Vector2DVector2D(struct FVector2D A, struct FVector2D B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_Vector2DVector2D");

	FDivide_Vector2DVector2D parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector2D UKismetMathLibrary::Divide_Vector2DFloat(struct FVector2D A, double B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_Vector2DFloat");

	FDivide_Vector2DFloat parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTimespan UKismetMathLibrary::Divide_TimespanFloat(struct FTimespan A, float Scalar){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_TimespanFloat");

	FDivide_TimespanFloat parms{};	
	parms.A = A;
	parms.Scalar = Scalar;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FLinearColor UKismetMathLibrary::Divide_LinearColorLinearColor(struct FLinearColor A, struct FLinearColor B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_LinearColorLinearColor");

	FDivide_LinearColorLinearColor parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FIntPoint UKismetMathLibrary::Divide_IntPointIntPoint(struct FIntPoint A, struct FIntPoint B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_IntPointIntPoint");

	FDivide_IntPointIntPoint parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FIntPoint UKismetMathLibrary::Divide_IntPointInt(struct FIntPoint A, int32_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_IntPointInt");

	FDivide_IntPointInt parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::Divide_IntInt(int32_t A, int32_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_IntInt");

	FDivide_IntInt parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int64_t UKismetMathLibrary::Divide_Int64Int64(int64_t A, int64_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_Int64Int64");

	FDivide_Int64Int64 parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Divide_DoubleDouble(double A, double B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_DoubleDouble");

	FDivide_DoubleDouble parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

char UKismetMathLibrary::Divide_ByteByte(char A, char B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_ByteByte");

	FDivide_ByteByte parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::DistanceSquared2D(struct FVector2D v1, struct FVector2D v2){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DistanceSquared2D");

	FDistanceSquared2D parms{};	
	parms.v1 = v1;
	parms.v2 = v2;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Distance2D(struct FVector2D v1, struct FVector2D v2){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Distance2D");

	FDistance2D parms{};	
	parms.v1 = v1;
	parms.v2 = v2;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::DegTan(double A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DegTan");

	FDegTan parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::DegSin(double A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DegSin");

	FDegSin parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::DegreesToRadians(double A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DegreesToRadians");

	FDegreesToRadians parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::DegCos(double A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DegCos");

	FDegCos parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::DegAtan2(double Y, double X){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DegAtan2");

	FDegAtan2 parms{};	
	parms.Y = Y;
	parms.X = X;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::DegAtan(double A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DegAtan");

	FDegAtan parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::DegAsin(double A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DegAsin");

	FDegAsin parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::DegAcos(double A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DegAcos");

	FDegAcos parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::DaysInYear(int32_t Year){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DaysInYear");

	FDaysInYear parms{};	
	parms.Year = Year;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::DaysInMonth(int32_t Year, int32_t Month){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DaysInMonth");

	FDaysInMonth parms{};	
	parms.Year = Year;
	parms.Month = Month;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FDateTime UKismetMathLibrary::DateTimeMinValue(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DateTimeMinValue");

	FDateTimeMinValue parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FDateTime UKismetMathLibrary::DateTimeMaxValue(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DateTimeMaxValue");

	FDateTimeMaxValue parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::DateTimeFromString(struct FString DateTimeString, struct FDateTime& Result){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DateTimeFromString");

	FDateTimeFromString parms{};	
	parms.DateTimeString = DateTimeString;
	parms.Result = Result;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::DateTimeFromIsoString(struct FString IsoString, struct FDateTime& Result){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DateTimeFromIsoString");

	FDateTimeFromIsoString parms{};	
	parms.IsoString = IsoString;
	parms.Result = Result;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::CrossProduct2D(struct FVector2D A, struct FVector2D B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.CrossProduct2D");

	FCrossProduct2D parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Cross_VectorVector(struct FVector A, struct FVector B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Cross_VectorVector");

	FCross_VectorVector parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::CreateVectorFromYawPitch(float Yaw, float Pitch, float Length){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.CreateVectorFromYawPitch");

	FCreateVectorFromYawPitch parms{};	
	parms.Yaw = Yaw;
	parms.Pitch = Pitch;
	parms.Length = Length;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Cos(double A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Cos");

	FCos parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTransform UKismetMathLibrary::ConvertTransformToRelative(struct FTransform& Transform, struct FTransform& ParentTransform){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ConvertTransformToRelative");

	FConvertTransformToRelative parms{};	
	parms.Transform = Transform;
	parms.ParentTransform = ParentTransform;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector2D UKismetMathLibrary::Conv_VectorToVector2D(struct FVector InVector){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_VectorToVector2D");

	FConv_VectorToVector2D parms{};	
	parms.InVector = InVector;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTransform UKismetMathLibrary::Conv_VectorToTransform(struct FVector InLocation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_VectorToTransform");

	FConv_VectorToTransform parms{};	
	parms.InLocation = InLocation;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator UKismetMathLibrary::Conv_VectorToRotator(struct FVector InVec){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_VectorToRotator");

	FConv_VectorToRotator parms{};	
	parms.InVec = InVec;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FQuat UKismetMathLibrary::Conv_VectorToQuaternion(struct FVector InVec){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_VectorToQuaternion");

	FConv_VectorToQuaternion parms{};	
	parms.InVec = InVec;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FLinearColor UKismetMathLibrary::Conv_VectorToLinearColor(struct FVector InVec){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_VectorToLinearColor");

	FConv_VectorToLinearColor parms{};	
	parms.InVec = InVec;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Conv_Vector4ToVector(struct FVector4& InVector4){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_Vector4ToVector");

	FConv_Vector4ToVector parms{};	
	parms.InVector4 = InVector4;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator UKismetMathLibrary::Conv_Vector4ToRotator(struct FVector4& InVec){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_Vector4ToRotator");

	FConv_Vector4ToRotator parms{};	
	parms.InVec = InVec;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FQuat UKismetMathLibrary::Conv_Vector4ToQuaternion(struct FVector4& InVec){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_Vector4ToQuaternion");

	FConv_Vector4ToQuaternion parms{};	
	parms.InVec = InVec;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Conv_Vector2DToVector(struct FVector2D InVector2D, float Z){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_Vector2DToVector");

	FConv_Vector2DToVector parms{};	
	parms.InVector2D = InVector2D;
	parms.Z = Z;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FIntPoint UKismetMathLibrary::Conv_Vector2DToIntPoint(struct FVector2D InVector2D){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_Vector2DToIntPoint");

	FConv_Vector2DToIntPoint parms{};	
	parms.InVector2D = InVector2D;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FMatrix UKismetMathLibrary::Conv_TransformToMatrix(struct FTransform& Transform){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_TransformToMatrix");

	FConv_TransformToMatrix parms{};	
	parms.Transform = Transform;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Conv_RotatorToVector(struct FRotator InRot){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_RotatorToVector");

	FConv_RotatorToVector parms{};	
	parms.InRot = InRot;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTransform UKismetMathLibrary::Conv_RotatorToTransform(struct FRotator& InRotator){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_RotatorToTransform");

	FConv_RotatorToTransform parms{};	
	parms.InRotator = InRotator;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FQuat UKismetMathLibrary::Conv_RotatorToQuaternion(struct FRotator InRot){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_RotatorToQuaternion");

	FConv_RotatorToQuaternion parms{};	
	parms.InRot = InRot;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTransform UKismetMathLibrary::Conv_MatrixToTransform(struct FMatrix& InMatrix){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_MatrixToTransform");

	FConv_MatrixToTransform parms{};	
	parms.InMatrix = InMatrix;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator UKismetMathLibrary::Conv_MatrixToRotator(struct FMatrix& InMatrix){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_MatrixToRotator");

	FConv_MatrixToRotator parms{};	
	parms.InMatrix = InMatrix;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Conv_LinearColorToVector(struct FLinearColor InLinearColor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_LinearColorToVector");

	FConv_LinearColorToVector parms{};	
	parms.InLinearColor = InLinearColor;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FColor UKismetMathLibrary::Conv_LinearColorToColor(struct FLinearColor InLinearColor, bool InUseSRGB){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_LinearColorToColor");

	FConv_LinearColorToColor parms{};	
	parms.InLinearColor = InLinearColor;
	parms.InUseSRGB = InUseSRGB;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Conv_IntVectorToVector(struct FIntVector& InIntVector){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_IntVectorToVector");

	FConv_IntVectorToVector parms{};	
	parms.InIntVector = InIntVector;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Conv_IntToVector(int32_t inInt){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_IntToVector");

	FConv_IntToVector parms{};	
	parms.inInt = inInt;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FIntVector UKismetMathLibrary::Conv_IntToIntVector(int32_t inInt){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_IntToIntVector");

	FConv_IntToIntVector parms{};	
	parms.inInt = inInt;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int64_t UKismetMathLibrary::Conv_IntToInt64(int32_t inInt){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_IntToInt64");

	FConv_IntToInt64 parms{};	
	parms.inInt = inInt;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetMathLibrary::Conv_IntToFloat(int32_t inInt){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_IntToFloat");

	FConv_IntToFloat parms{};	
	parms.inInt = inInt;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Conv_IntToDouble(int32_t inInt){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_IntToDouble");

	FConv_IntToDouble parms{};	
	parms.inInt = inInt;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

char UKismetMathLibrary::Conv_IntToByte(int32_t inInt){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_IntToByte");

	FConv_IntToByte parms{};	
	parms.inInt = inInt;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::Conv_IntToBool(int32_t inInt){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_IntToBool");

	FConv_IntToBool parms{};	
	parms.inInt = inInt;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector2D UKismetMathLibrary::Conv_IntPointToVector2D(struct FIntPoint InIntPoint){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_IntPointToVector2D");

	FConv_IntPointToVector2D parms{};	
	parms.InIntPoint = InIntPoint;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::Conv_Int64ToInt(int64_t inInt){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_Int64ToInt");

	FConv_Int64ToInt parms{};	
	parms.inInt = inInt;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Conv_Int64ToDouble(int64_t inInt){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_Int64ToDouble");

	FConv_Int64ToDouble parms{};	
	parms.inInt = inInt;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

char UKismetMathLibrary::Conv_Int64ToByte(int64_t inInt){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_Int64ToByte");

	FConv_Int64ToByte parms{};	
	parms.inInt = inInt;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Conv_FloatToVector(float InFloat){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_FloatToVector");

	FConv_FloatToVector parms{};	
	parms.InFloat = InFloat;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FLinearColor UKismetMathLibrary::Conv_FloatToLinearColor(float InFloat){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_FloatToLinearColor");

	FConv_FloatToLinearColor parms{};	
	parms.InFloat = InFloat;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Conv_FloatToDouble(float InFloat){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_FloatToDouble");

	FConv_FloatToDouble parms{};	
	parms.InFloat = InFloat;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Conv_DoubleToVector(double InDouble){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_DoubleToVector");

	FConv_DoubleToVector parms{};	
	parms.InDouble = InDouble;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FLinearColor UKismetMathLibrary::Conv_DoubleToLinearColor(double InDouble){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_DoubleToLinearColor");

	FConv_DoubleToLinearColor parms{};	
	parms.InDouble = InDouble;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int64_t UKismetMathLibrary::Conv_DoubleToInt64(double InDouble){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_DoubleToInt64");

	FConv_DoubleToInt64 parms{};	
	parms.InDouble = InDouble;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetMathLibrary::Conv_DoubleToFloat(double InDouble){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_DoubleToFloat");

	FConv_DoubleToFloat parms{};	
	parms.InDouble = InDouble;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FLinearColor UKismetMathLibrary::Conv_ColorToLinearColor(struct FColor InColor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_ColorToLinearColor");

	FConv_ColorToLinearColor parms{};	
	parms.InColor = InColor;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int64_t UKismetMathLibrary::Conv_ByteToInt64(char InByte){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_ByteToInt64");

	FConv_ByteToInt64 parms{};	
	parms.InByte = InByte;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::Conv_ByteToInt(char InByte){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_ByteToInt");

	FConv_ByteToInt parms{};	
	parms.InByte = InByte;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetMathLibrary::Conv_ByteToFloat(char InByte){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_ByteToFloat");

	FConv_ByteToFloat parms{};	
	parms.InByte = InByte;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Conv_ByteToDouble(char InByte){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_ByteToDouble");

	FConv_ByteToDouble parms{};	
	parms.InByte = InByte;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::Conv_BoolToInt(bool InBool){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_BoolToInt");

	FConv_BoolToInt parms{};	
	parms.InBool = InBool;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetMathLibrary::Conv_BoolToFloat(bool InBool){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_BoolToFloat");

	FConv_BoolToFloat parms{};	
	parms.InBool = InBool;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

char UKismetMathLibrary::Conv_BoolToByte(bool InBool){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_BoolToByte");

	FConv_BoolToByte parms{};	
	parms.InBool = InBool;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTransform UKismetMathLibrary::ComposeTransforms(struct FTransform& A, struct FTransform& B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ComposeTransforms");

	FComposeTransforms parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator UKismetMathLibrary::ComposeRotators(struct FRotator A, struct FRotator B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ComposeRotators");

	FComposeRotators parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::ClassIsChildOf(UObject* TestClass, UObject* ParentClass){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ClassIsChildOf");

	FClassIsChildOf parms{};	
	parms.TestClass = TestClass;
	parms.ParentClass = ParentClass;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::ClampVectorSize(struct FVector A, double Min, double Max){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ClampVectorSize");

	FClampVectorSize parms{};	
	parms.A = A;
	parms.Min = Min;
	parms.Max = Max;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int64_t UKismetMathLibrary::ClampInt64(int64_t Value, int64_t Min, int64_t Max){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ClampInt64");

	FClampInt64 parms{};	
	parms.Value = Value;
	parms.Min = Min;
	parms.Max = Max;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetMathLibrary::ClampAxis(float Angle){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ClampAxis");

	FClampAxis parms{};	
	parms.Angle = Angle;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector2D UKismetMathLibrary::ClampAxes2D(struct FVector2D A, double MinAxisVal, double MaxAxisVal){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ClampAxes2D");

	FClampAxes2D parms{};	
	parms.A = A;
	parms.MinAxisVal = MinAxisVal;
	parms.MaxAxisVal = MaxAxisVal;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::ClampAngle(double AngleDegrees, double MinAngleDegrees, double MaxAngleDegrees){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ClampAngle");

	FClampAngle parms{};	
	parms.AngleDegrees = AngleDegrees;
	parms.MinAngleDegrees = MinAngleDegrees;
	parms.MaxAngleDegrees = MaxAngleDegrees;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::Clamp(int32_t Value, int32_t Min, int32_t Max){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Clamp");

	FClamp parms{};	
	parms.Value = Value;
	parms.Min = Min;
	parms.Max = Max;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FLinearColor UKismetMathLibrary::CInterpTo(struct FLinearColor Current, struct FLinearColor Target, float DeltaTime, float InterpSpeed){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.CInterpTo");

	FCInterpTo parms{};	
	parms.Current = Current;
	parms.Target = Target;
	parms.DeltaTime = DeltaTime;
	parms.InterpSpeed = InterpSpeed;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetMathLibrary::BreakVector_NetQuantizeNormal(struct FVector_NetQuantizeNormal InVec, double& X, double& Y, double& Z){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakVector_NetQuantizeNormal");

	FBreakVector_NetQuantizeNormal parms{};	
	parms.InVec = InVec;
	parms.X = X;
	parms.Y = Y;
	parms.Z = Z;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::BreakVector_NetQuantize100(struct FVector_NetQuantize100 InVec, double& X, double& Y, double& Z){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakVector_NetQuantize100");

	FBreakVector_NetQuantize100 parms{};	
	parms.InVec = InVec;
	parms.X = X;
	parms.Y = Y;
	parms.Z = Z;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::BreakVector_NetQuantize10(struct FVector_NetQuantize10 InVec, double& X, double& Y, double& Z){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakVector_NetQuantize10");

	FBreakVector_NetQuantize10 parms{};	
	parms.InVec = InVec;
	parms.X = X;
	parms.Y = Y;
	parms.Z = Z;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::BreakVector_NetQuantize(struct FVector_NetQuantize InVec, double& X, double& Y, double& Z){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakVector_NetQuantize");

	FBreakVector_NetQuantize parms{};	
	parms.InVec = InVec;
	parms.X = X;
	parms.Y = Y;
	parms.Z = Z;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::BreakVector4(struct FVector4& InVec, double& X, double& Y, double& Z, double& W){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakVector4");

	FBreakVector4 parms{};	
	parms.InVec = InVec;
	parms.X = X;
	parms.Y = Y;
	parms.Z = Z;
	parms.W = W;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::BreakVector3f(struct FVector3f InVec, float& X, float& Y, float& Z){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakVector3f");

	FBreakVector3f parms{};	
	parms.InVec = InVec;
	parms.X = X;
	parms.Y = Y;
	parms.Z = Z;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::BreakVector2D(struct FVector2D InVec, double& X, double& Y){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakVector2D");

	FBreakVector2D parms{};	
	parms.InVec = InVec;
	parms.X = X;
	parms.Y = Y;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::BreakVector(struct FVector InVec, double& X, double& Y, double& Z){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakVector");

	FBreakVector parms{};	
	parms.InVec = InVec;
	parms.X = X;
	parms.Y = Y;
	parms.Z = Z;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::BreakTransform(struct FTransform& InTransform, struct FVector& Location, struct FRotator& Rotation, struct FVector& Scale){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakTransform");

	FBreakTransform parms{};	
	parms.InTransform = InTransform;
	parms.Location = Location;
	parms.Rotation = Rotation;
	parms.Scale = Scale;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::BreakTimespan2(struct FTimespan InTimespan, int32_t& Days, int32_t& Hours, int32_t& Minutes, int32_t& Seconds, int32_t& FractionNano){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakTimespan2");

	FBreakTimespan2 parms{};	
	parms.InTimespan = InTimespan;
	parms.Days = Days;
	parms.Hours = Hours;
	parms.Minutes = Minutes;
	parms.Seconds = Seconds;
	parms.FractionNano = FractionNano;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::BreakTimespan(struct FTimespan InTimespan, int32_t& Days, int32_t& Hours, int32_t& Minutes, int32_t& Seconds, int32_t& Milliseconds){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakTimespan");

	FBreakTimespan parms{};	
	parms.InTimespan = InTimespan;
	parms.Days = Days;
	parms.Hours = Hours;
	parms.Minutes = Minutes;
	parms.Seconds = Seconds;
	parms.Milliseconds = Milliseconds;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::BreakRotIntoAxes(struct FRotator& InRot, struct FVector& X, struct FVector& Y, struct FVector& Z){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakRotIntoAxes");

	FBreakRotIntoAxes parms{};	
	parms.InRot = InRot;
	parms.X = X;
	parms.Y = Y;
	parms.Z = Z;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::BreakRotator(struct FRotator InRot, float& Roll, float& Pitch, float& Yaw){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakRotator");

	FBreakRotator parms{};	
	parms.InRot = InRot;
	parms.Roll = Roll;
	parms.Pitch = Pitch;
	parms.Yaw = Yaw;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::BreakRandomStream(struct FRandomStream& InRandomStream, int32_t& InitialSeed){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakRandomStream");

	FBreakRandomStream parms{};	
	parms.InRandomStream = InRandomStream;
	parms.InitialSeed = InitialSeed;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::BreakQuat(struct FQuat& InQuat, float& X, float& Y, float& Z, float& W){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakQuat");

	FBreakQuat parms{};	
	parms.InQuat = InQuat;
	parms.X = X;
	parms.Y = Y;
	parms.Z = Z;
	parms.W = W;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::BreakQualifiedFrameTime(struct FQualifiedFrameTime& InFrameTime, struct FFrameNumber& Frame, struct FFrameRate& FrameRate, float& SubFrame){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakQualifiedFrameTime");

	FBreakQualifiedFrameTime parms{};	
	parms.InFrameTime = InFrameTime;
	parms.Frame = Frame;
	parms.FrameRate = FrameRate;
	parms.SubFrame = SubFrame;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::BreakFrameRate(struct FFrameRate& InFrameRate, int32_t& Numerator, int32_t& Denominator){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakFrameRate");

	FBreakFrameRate parms{};	
	parms.InFrameRate = InFrameRate;
	parms.Numerator = Numerator;
	parms.Denominator = Denominator;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::BreakDateTime(struct FDateTime InDateTime, int32_t& Year, int32_t& Month, int32_t& Day, int32_t& Hour, int32_t& Minute, int32_t& Second, int32_t& Millisecond){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakDateTime");

	FBreakDateTime parms{};	
	parms.InDateTime = InDateTime;
	parms.Year = Year;
	parms.Month = Month;
	parms.Day = Day;
	parms.Hour = Hour;
	parms.Minute = Minute;
	parms.Second = Second;
	parms.Millisecond = Millisecond;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::BreakColor(struct FLinearColor InColor, float& R, float& G, float& B, float& A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakColor");

	FBreakColor parms{};	
	parms.InColor = InColor;
	parms.R = R;
	parms.G = G;
	parms.B = B;
	parms.A = A;

	ProcessEvent(fn, &parms);
}

void UKismetMathLibrary::BreakBoxSphereBounds(struct FBoxSphereBounds& InBoxSphereBounds, struct FVector& Origin, struct FVector& BoxExtent, float& SphereRadius){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakBoxSphereBounds");

	FBreakBoxSphereBounds parms{};	
	parms.InBoxSphereBounds = InBoxSphereBounds;
	parms.Origin = Origin;
	parms.BoxExtent = BoxExtent;
	parms.SphereRadius = SphereRadius;

	ProcessEvent(fn, &parms);
}

bool UKismetMathLibrary::BooleanXOR(bool A, bool B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BooleanXOR");

	FBooleanXOR parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::BooleanOR(bool A, bool B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BooleanOR");

	FBooleanOR parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::BooleanNOR(bool A, bool B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BooleanNOR");

	FBooleanNOR parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::BooleanNAND(bool A, bool B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BooleanNAND");

	FBooleanNAND parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetMathLibrary::BooleanAND(bool A, bool B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BooleanAND");

	FBooleanAND parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

char UKismetMathLibrary::BMin(char A, char B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BMin");

	FBMin parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

char UKismetMathLibrary::BMax(char A, char B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BMax");

	FBMax parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetMathLibrary::AverageOfIntArray(struct TArray<int32_t>& IntArray, float& AverageValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.AverageOfIntArray");

	FAverageOfIntArray parms{};	
	parms.IntArray = IntArray;
	parms.AverageValue = AverageValue;

	ProcessEvent(fn, &parms);
}

double UKismetMathLibrary::Atan2(double Y, double X){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Atan2");

	FAtan2 parms{};	
	parms.Y = Y;
	parms.X = X;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Atan(double A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Atan");

	FAtan parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Asin(double A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Asin");

	FAsin parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::And_IntInt(int32_t A, int32_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.And_IntInt");

	FAnd_IntInt parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int64_t UKismetMathLibrary::And_Int64Int64(int64_t A, int64_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.And_Int64Int64");

	FAnd_Int64Int64 parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Add_VectorVector(struct FVector A, struct FVector B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_VectorVector");

	FAdd_VectorVector parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Add_VectorInt(struct FVector A, int32_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_VectorInt");

	FAdd_VectorInt parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UKismetMathLibrary::Add_VectorFloat(struct FVector A, double B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_VectorFloat");

	FAdd_VectorFloat parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector4 UKismetMathLibrary::Add_Vector4Vector4(struct FVector4& A, struct FVector4& B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_Vector4Vector4");

	FAdd_Vector4Vector4 parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector2D UKismetMathLibrary::Add_Vector2DVector2D(struct FVector2D A, struct FVector2D B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_Vector2DVector2D");

	FAdd_Vector2DVector2D parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector2D UKismetMathLibrary::Add_Vector2DFloat(struct FVector2D A, double B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_Vector2DFloat");

	FAdd_Vector2DFloat parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTimespan UKismetMathLibrary::Add_TimespanTimespan(struct FTimespan A, struct FTimespan B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_TimespanTimespan");

	FAdd_TimespanTimespan parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FQuat UKismetMathLibrary::Add_QuatQuat(struct FQuat& A, struct FQuat& B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_QuatQuat");

	FAdd_QuatQuat parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FMatrix UKismetMathLibrary::Add_MatrixMatrix(struct FMatrix& A, struct FMatrix& B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_MatrixMatrix");

	FAdd_MatrixMatrix parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FLinearColor UKismetMathLibrary::Add_LinearColorLinearColor(struct FLinearColor A, struct FLinearColor B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_LinearColorLinearColor");

	FAdd_LinearColorLinearColor parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FIntPoint UKismetMathLibrary::Add_IntPointIntPoint(struct FIntPoint A, struct FIntPoint B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_IntPointIntPoint");

	FAdd_IntPointIntPoint parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FIntPoint UKismetMathLibrary::Add_IntPointInt(struct FIntPoint A, int32_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_IntPointInt");

	FAdd_IntPointInt parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::Add_IntInt(int32_t A, int32_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_IntInt");

	FAdd_IntInt parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int64_t UKismetMathLibrary::Add_Int64Int64(int64_t A, int64_t B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_Int64Int64");

	FAdd_Int64Int64 parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Add_DoubleDouble(double A, double B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_DoubleDouble");

	FAdd_DoubleDouble parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FDateTime UKismetMathLibrary::Add_DateTimeTimespan(struct FDateTime A, struct FTimespan B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_DateTimeTimespan");

	FAdd_DateTimeTimespan parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FDateTime UKismetMathLibrary::Add_DateTimeDateTime(struct FDateTime A, struct FDateTime B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_DateTimeDateTime");

	FAdd_DateTimeDateTime parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

char UKismetMathLibrary::Add_ByteByte(char A, char B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_ByteByte");

	FAdd_ByteByte parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Acos(double A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Acos");

	FAcos parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int64_t UKismetMathLibrary::Abs_Int64(int64_t A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Abs_Int64");

	FAbs_Int64 parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetMathLibrary::Abs_Int(int32_t A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Abs_Int");

	FAbs_Int parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetMathLibrary::Abs(double A){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Abs");

	FAbs parms{};	
	parms.A = A;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetInputLibrary::PointerEvent_IsTouchEvent(struct FPointerEvent& Input){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_IsTouchEvent");

	FPointerEvent_IsTouchEvent parms{};	
	parms.Input = Input;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetInputLibrary::PointerEvent_IsMouseButtonDown(struct FPointerEvent& Input, struct FKey MouseButton){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_IsMouseButtonDown");

	FPointerEvent_IsMouseButtonDown parms{};	
	parms.Input = Input;
	parms.MouseButton = MouseButton;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetInputLibrary::PointerEvent_GetWheelDelta(struct FPointerEvent& Input){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetWheelDelta");

	FPointerEvent_GetWheelDelta parms{};	
	parms.Input = Input;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetInputLibrary::PointerEvent_GetUserIndex(struct FPointerEvent& Input){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetUserIndex");

	FPointerEvent_GetUserIndex parms{};	
	parms.Input = Input;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetInputLibrary::PointerEvent_GetTouchpadIndex(struct FPointerEvent& Input){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetTouchpadIndex");

	FPointerEvent_GetTouchpadIndex parms{};	
	parms.Input = Input;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector2D UKismetInputLibrary::PointerEvent_GetScreenSpacePosition(struct FPointerEvent& Input){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetScreenSpacePosition");

	FPointerEvent_GetScreenSpacePosition parms{};	
	parms.Input = Input;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetInputLibrary::PointerEvent_GetPointerIndex(struct FPointerEvent& Input){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetPointerIndex");

	FPointerEvent_GetPointerIndex parms{};	
	parms.Input = Input;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector2D UKismetInputLibrary::PointerEvent_GetLastScreenSpacePosition(struct FPointerEvent& Input){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetLastScreenSpacePosition");

	FPointerEvent_GetLastScreenSpacePosition parms{};	
	parms.Input = Input;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

uint8_t UKismetInputLibrary::PointerEvent_GetGestureType(struct FPointerEvent& Input){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetGestureType");

	FPointerEvent_GetGestureType parms{};	
	parms.Input = Input;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector2D UKismetInputLibrary::PointerEvent_GetGestureDelta(struct FPointerEvent& Input){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetGestureDelta");

	FPointerEvent_GetGestureDelta parms{};	
	parms.Input = Input;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FKey UKismetInputLibrary::PointerEvent_GetEffectingButton(struct FPointerEvent& Input){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetEffectingButton");

	FPointerEvent_GetEffectingButton parms{};	
	parms.Input = Input;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector2D UKismetInputLibrary::PointerEvent_GetCursorDelta(struct FPointerEvent& Input){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetCursorDelta");

	FPointerEvent_GetCursorDelta parms{};	
	parms.Input = Input;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetInputLibrary::ModifierKeysState_IsShiftDown(struct FSlateModifierKeysState& KeysState){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.ModifierKeysState_IsShiftDown");

	FModifierKeysState_IsShiftDown parms{};	
	parms.KeysState = KeysState;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetInputLibrary::ModifierKeysState_IsControlDown(struct FSlateModifierKeysState& KeysState){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.ModifierKeysState_IsControlDown");

	FModifierKeysState_IsControlDown parms{};	
	parms.KeysState = KeysState;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetInputLibrary::ModifierKeysState_IsCommandDown(struct FSlateModifierKeysState& KeysState){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.ModifierKeysState_IsCommandDown");

	FModifierKeysState_IsCommandDown parms{};	
	parms.KeysState = KeysState;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetInputLibrary::ModifierKeysState_IsAltDown(struct FSlateModifierKeysState& KeysState){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.ModifierKeysState_IsAltDown");

	FModifierKeysState_IsAltDown parms{};	
	parms.KeysState = KeysState;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetInputLibrary::Key_IsVectorAxis(struct FKey& Key){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_IsVectorAxis");

	FKey_IsVectorAxis parms{};	
	parms.Key = Key;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetInputLibrary::Key_IsValid(struct FKey& Key){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_IsValid");

	FKey_IsValid parms{};	
	parms.Key = Key;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetInputLibrary::Key_IsMouseButton(struct FKey& Key){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_IsMouseButton");

	FKey_IsMouseButton parms{};	
	parms.Key = Key;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetInputLibrary::Key_IsModifierKey(struct FKey& Key){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_IsModifierKey");

	FKey_IsModifierKey parms{};	
	parms.Key = Key;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetInputLibrary::Key_IsKeyboardKey(struct FKey& Key){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_IsKeyboardKey");

	FKey_IsKeyboardKey parms{};	
	parms.Key = Key;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetInputLibrary::Key_IsGamepadKey(struct FKey& Key){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_IsGamepadKey");

	FKey_IsGamepadKey parms{};	
	parms.Key = Key;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetInputLibrary::Key_IsDigital(struct FKey& Key){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_IsDigital");

	FKey_IsDigital parms{};	
	parms.Key = Key;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetInputLibrary::Key_IsButtonAxis(struct FKey& Key){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_IsButtonAxis");

	FKey_IsButtonAxis parms{};	
	parms.Key = Key;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetInputLibrary::Key_IsAxis3D(struct FKey& Key){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_IsAxis3D");

	FKey_IsAxis3D parms{};	
	parms.Key = Key;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetInputLibrary::Key_IsAxis2D(struct FKey& Key){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_IsAxis2D");

	FKey_IsAxis2D parms{};	
	parms.Key = Key;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetInputLibrary::Key_IsAxis1D(struct FKey& Key){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_IsAxis1D");

	FKey_IsAxis1D parms{};	
	parms.Key = Key;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetInputLibrary::Key_IsAnalog(struct FKey& Key){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_IsAnalog");

	FKey_IsAnalog parms{};	
	parms.Key = Key;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

uint8_t UKismetInputLibrary::Key_GetNavigationDirectionFromKey(struct FKeyEvent& InKeyEvent){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_GetNavigationDirectionFromKey");

	FKey_GetNavigationDirectionFromKey parms{};	
	parms.InKeyEvent = InKeyEvent;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

uint8_t UKismetInputLibrary::Key_GetNavigationDirectionFromAnalog(struct FAnalogInputEvent& InAnalogEvent){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_GetNavigationDirectionFromAnalog");

	FKey_GetNavigationDirectionFromAnalog parms{};	
	parms.InAnalogEvent = InAnalogEvent;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

uint8_t UKismetInputLibrary::Key_GetNavigationActionFromKey(struct FKeyEvent& InKeyEvent){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_GetNavigationActionFromKey");

	FKey_GetNavigationActionFromKey parms{};	
	parms.InKeyEvent = InKeyEvent;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

uint8_t UKismetInputLibrary::Key_GetNavigationAction(struct FKey& InKey){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_GetNavigationAction");

	FKey_GetNavigationAction parms{};	
	parms.InKey = InKey;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FText UKismetInputLibrary::Key_GetDisplayName(struct FKey& Key, bool bLongDisplayName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_GetDisplayName");

	FKey_GetDisplayName parms{};	
	parms.Key = Key;
	parms.bLongDisplayName = bLongDisplayName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetInputLibrary::InputEvent_IsShiftDown(struct FInputEvent& Input){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsShiftDown");

	FInputEvent_IsShiftDown parms{};	
	parms.Input = Input;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetInputLibrary::InputEvent_IsRightShiftDown(struct FInputEvent& Input){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsRightShiftDown");

	FInputEvent_IsRightShiftDown parms{};	
	parms.Input = Input;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetInputLibrary::InputEvent_IsRightControlDown(struct FInputEvent& Input){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsRightControlDown");

	FInputEvent_IsRightControlDown parms{};	
	parms.Input = Input;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetInputLibrary::InputEvent_IsRightCommandDown(struct FInputEvent& Input){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsRightCommandDown");

	FInputEvent_IsRightCommandDown parms{};	
	parms.Input = Input;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetInputLibrary::InputEvent_IsRightAltDown(struct FInputEvent& Input){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsRightAltDown");

	FInputEvent_IsRightAltDown parms{};	
	parms.Input = Input;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetInputLibrary::InputEvent_IsRepeat(struct FInputEvent& Input){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsRepeat");

	FInputEvent_IsRepeat parms{};	
	parms.Input = Input;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetInputLibrary::InputEvent_IsLeftShiftDown(struct FInputEvent& Input){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsLeftShiftDown");

	FInputEvent_IsLeftShiftDown parms{};	
	parms.Input = Input;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetInputLibrary::InputEvent_IsLeftControlDown(struct FInputEvent& Input){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsLeftControlDown");

	FInputEvent_IsLeftControlDown parms{};	
	parms.Input = Input;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetInputLibrary::InputEvent_IsLeftCommandDown(struct FInputEvent& Input){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsLeftCommandDown");

	FInputEvent_IsLeftCommandDown parms{};	
	parms.Input = Input;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetInputLibrary::InputEvent_IsLeftAltDown(struct FInputEvent& Input){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsLeftAltDown");

	FInputEvent_IsLeftAltDown parms{};	
	parms.Input = Input;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetInputLibrary::InputEvent_IsControlDown(struct FInputEvent& Input){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsControlDown");

	FInputEvent_IsControlDown parms{};	
	parms.Input = Input;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetInputLibrary::InputEvent_IsCommandDown(struct FInputEvent& Input){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsCommandDown");

	FInputEvent_IsCommandDown parms{};	
	parms.Input = Input;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetInputLibrary::InputEvent_IsAltDown(struct FInputEvent& Input){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsAltDown");

	FInputEvent_IsAltDown parms{};	
	parms.Input = Input;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FText UKismetInputLibrary::InputChord_GetDisplayName(struct FInputChord& Key){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputChord_GetDisplayName");

	FInputChord_GetDisplayName parms{};	
	parms.Key = Key;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetInputLibrary::GetUserIndex(struct FKeyEvent& Input){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.GetUserIndex");

	FGetUserIndex parms{};	
	parms.Input = Input;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FSlateModifierKeysState UKismetInputLibrary::GetModifierKeysState(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.GetModifierKeysState");

	FGetModifierKeysState parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FKey UKismetInputLibrary::GetKey(struct FKeyEvent& Input){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.GetKey");

	FGetKey parms{};	
	parms.Input = Input;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetInputLibrary::GetAnalogValue(struct FAnalogInputEvent& Input){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.GetAnalogValue");

	FGetAnalogValue parms{};	
	parms.Input = Input;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetInputLibrary::EqualEqual_KeyKey(struct FKey A, struct FKey B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.EqualEqual_KeyKey");

	FEqualEqual_KeyKey parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetInputLibrary::EqualEqual_InputChordInputChord(struct FInputChord A, struct FInputChord B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.EqualEqual_InputChordInputChord");

	FEqualEqual_InputChordInputChord parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetInputLibrary::CalibrateTilt(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.CalibrateTilt");

	FCalibrateTilt parms{};	

	ProcessEvent(fn, &parms);
}

void UVOIPTalker::RegisterWithPlayerState(struct APlayerState* OwningState){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.VOIPTalker.RegisterWithPlayerState");

	FRegisterWithPlayerState parms{};	
	parms.OwningState = OwningState;

	ProcessEvent(fn, &parms);
}

float UVOIPTalker::GetVoiceLevel(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.VOIPTalker.GetVoiceLevel");

	FGetVoiceLevel parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UVOIPTalker* UVOIPTalker::CreateTalkerForPlayer(struct APlayerState* OwningState){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.VOIPTalker.CreateTalkerForPlayer");

	FCreateTalkerForPlayer parms{};	
	parms.OwningState = OwningState;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UVOIPTalker::BPOnTalkingEnd(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.VOIPTalker.BPOnTalkingEnd");

	FBPOnTalkingEnd parms{};	

	ProcessEvent(fn, &parms);
}

void UVOIPTalker::BPOnTalkingBegin(struct UAudioComponent* AudioComponent){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.VOIPTalker.BPOnTalkingBegin");

	FBPOnTalkingBegin parms{};	
	parms.AudioComponent = AudioComponent;

	ProcessEvent(fn, &parms);
}

bool UCurveLinearColorAtlas::GetCurvePosition(struct UCurveLinearColor* InCurve, float& Position){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CurveLinearColorAtlas.GetCurvePosition");

	FGetCurvePosition parms{};	
	parms.InCurve = InCurve;
	parms.Position = Position;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::VideoCaptureDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.VideoCaptureDir");

	FVideoCaptureDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UBlueprintPathsLibrary::ValidatePath(struct FString InPath, bool& bDidSucceed, struct FText& OutReason){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ValidatePath");

	FValidatePath parms{};	
	parms.InPath = InPath;
	parms.bDidSucceed = bDidSucceed;
	parms.OutReason = OutReason;

	ProcessEvent(fn, &parms);
}

void UBlueprintPathsLibrary::Split(struct FString InPath, struct FString& PathPart, struct FString& FilenamePart, struct FString& ExtensionPart){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.Split");

	FSplit parms{};	
	parms.InPath = InPath;
	parms.PathPart = PathPart;
	parms.FilenamePart = FilenamePart;
	parms.ExtensionPart = ExtensionPart;

	ProcessEvent(fn, &parms);
}

struct FString UBlueprintPathsLibrary::SourceConfigDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.SourceConfigDir");

	FSourceConfigDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UBlueprintPathsLibrary::ShouldSaveToUserDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ShouldSaveToUserDir");

	FShouldSaveToUserDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::ShaderWorkingDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ShaderWorkingDir");

	FShaderWorkingDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UBlueprintPathsLibrary::SetProjectFilePath(struct FString NewGameProjectFilePath){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.SetProjectFilePath");

	FSetProjectFilePath parms{};	
	parms.NewGameProjectFilePath = NewGameProjectFilePath;

	ProcessEvent(fn, &parms);
}

struct FString UBlueprintPathsLibrary::SetExtension(struct FString InPath, struct FString InNewExtension){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.SetExtension");

	FSetExtension parms{};	
	parms.InPath = InPath;
	parms.InNewExtension = InNewExtension;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::ScreenShotDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ScreenShotDir");

	FScreenShotDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::SandboxesDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.SandboxesDir");

	FSandboxesDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::RootDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.RootDir");

	FRootDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UBlueprintPathsLibrary::RemoveDuplicateSlashes(struct FString InPath, struct FString& OutPath){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.RemoveDuplicateSlashes");

	FRemoveDuplicateSlashes parms{};	
	parms.InPath = InPath;
	parms.OutPath = OutPath;

	ProcessEvent(fn, &parms);
}

struct FString UBlueprintPathsLibrary::ProjectUserDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ProjectUserDir");

	FProjectUserDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::ProjectSavedDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ProjectSavedDir");

	FProjectSavedDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::ProjectPluginsDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ProjectPluginsDir");

	FProjectPluginsDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::ProjectPersistentDownloadDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ProjectPersistentDownloadDir");

	FProjectPersistentDownloadDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::ProjectModsDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ProjectModsDir");

	FProjectModsDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::ProjectLogDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ProjectLogDir");

	FProjectLogDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::ProjectIntermediateDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ProjectIntermediateDir");

	FProjectIntermediateDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::ProjectDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ProjectDir");

	FProjectDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::ProjectContentDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ProjectContentDir");

	FProjectContentDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::ProjectConfigDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ProjectConfigDir");

	FProjectConfigDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::ProfilingDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ProfilingDir");

	FProfilingDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UBlueprintPathsLibrary::NormalizeFilename(struct FString InPath, struct FString& OutPath){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.NormalizeFilename");

	FNormalizeFilename parms{};	
	parms.InPath = InPath;
	parms.OutPath = OutPath;

	ProcessEvent(fn, &parms);
}

void UBlueprintPathsLibrary::NormalizeDirectoryName(struct FString InPath, struct FString& OutPath){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.NormalizeDirectoryName");

	FNormalizeDirectoryName parms{};	
	parms.InPath = InPath;
	parms.OutPath = OutPath;

	ProcessEvent(fn, &parms);
}

struct FString UBlueprintPathsLibrary::MakeValidFileName(struct FString InString, struct FString InReplacementChar){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.MakeValidFileName");

	FMakeValidFileName parms{};	
	parms.InString = InString;
	parms.InReplacementChar = InReplacementChar;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UBlueprintPathsLibrary::MakeStandardFilename(struct FString InPath, struct FString& OutPath){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.MakeStandardFilename");

	FMakeStandardFilename parms{};	
	parms.InPath = InPath;
	parms.OutPath = OutPath;

	ProcessEvent(fn, &parms);
}

void UBlueprintPathsLibrary::MakePlatformFilename(struct FString InPath, struct FString& OutPath){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.MakePlatformFilename");

	FMakePlatformFilename parms{};	
	parms.InPath = InPath;
	parms.OutPath = OutPath;

	ProcessEvent(fn, &parms);
}

bool UBlueprintPathsLibrary::MakePathRelativeTo(struct FString InPath, struct FString InRelativeTo, struct FString& OutPath){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.MakePathRelativeTo");

	FMakePathRelativeTo parms{};	
	parms.InPath = InPath;
	parms.InRelativeTo = InRelativeTo;
	parms.OutPath = OutPath;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::LaunchDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.LaunchDir");

	FLaunchDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UBlueprintPathsLibrary::IsSamePath(struct FString PathA, struct FString PathB){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.IsSamePath");

	FIsSamePath parms{};	
	parms.PathA = PathA;
	parms.PathB = PathB;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UBlueprintPathsLibrary::IsRestrictedPath(struct FString InPath){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.IsRestrictedPath");

	FIsRestrictedPath parms{};	
	parms.InPath = InPath;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UBlueprintPathsLibrary::IsRelative(struct FString InPath){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.IsRelative");

	FIsRelative parms{};	
	parms.InPath = InPath;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UBlueprintPathsLibrary::IsProjectFilePathSet(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.IsProjectFilePathSet");

	FIsProjectFilePathSet parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UBlueprintPathsLibrary::IsDrive(struct FString InPath){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.IsDrive");

	FIsDrive parms{};	
	parms.InPath = InPath;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UBlueprintPathsLibrary::HasProjectPersistentDownloadDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.HasProjectPersistentDownloadDir");

	FHasProjectPersistentDownloadDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<struct FString> UBlueprintPathsLibrary::GetToolTipLocalizationPaths(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GetToolTipLocalizationPaths");

	FGetToolTipLocalizationPaths parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<struct FString> UBlueprintPathsLibrary::GetRestrictedFolderNames(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GetRestrictedFolderNames");

	FGetRestrictedFolderNames parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::GetRelativePathToRoot(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GetRelativePathToRoot");

	FGetRelativePathToRoot parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<struct FString> UBlueprintPathsLibrary::GetPropertyNameLocalizationPaths(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GetPropertyNameLocalizationPaths");

	FGetPropertyNameLocalizationPaths parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::GetProjectFilePath(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GetProjectFilePath");

	FGetProjectFilePath parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::GetPath(struct FString InPath){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GetPath");

	FGetPath parms{};	
	parms.InPath = InPath;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::GetInvalidFileSystemChars(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GetInvalidFileSystemChars");

	FGetInvalidFileSystemChars parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<struct FString> UBlueprintPathsLibrary::GetGameLocalizationPaths(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GetGameLocalizationPaths");

	FGetGameLocalizationPaths parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::GetExtension(struct FString InPath, bool bIncludeDot){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GetExtension");

	FGetExtension parms{};	
	parms.InPath = InPath;
	parms.bIncludeDot = bIncludeDot;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<struct FString> UBlueprintPathsLibrary::GetEngineLocalizationPaths(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GetEngineLocalizationPaths");

	FGetEngineLocalizationPaths parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<struct FString> UBlueprintPathsLibrary::GetEditorLocalizationPaths(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GetEditorLocalizationPaths");

	FGetEditorLocalizationPaths parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::GetCleanFilename(struct FString InPath){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GetCleanFilename");

	FGetCleanFilename parms{};	
	parms.InPath = InPath;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::GetBaseFilename(struct FString InPath, bool bRemovePath){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GetBaseFilename");

	FGetBaseFilename parms{};	
	parms.InPath = InPath;
	parms.bRemovePath = bRemovePath;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::GeneratedConfigDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GeneratedConfigDir");

	FGeneratedConfigDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::GameUserDeveloperDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GameUserDeveloperDir");

	FGameUserDeveloperDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::GameSourceDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GameSourceDir");

	FGameSourceDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::GameDevelopersDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GameDevelopersDir");

	FGameDevelopersDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::GameAgnosticSavedDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GameAgnosticSavedDir");

	FGameAgnosticSavedDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UBlueprintPathsLibrary::FileExists(struct FString InPath){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.FileExists");

	FFileExists parms{};	
	parms.InPath = InPath;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::FeaturePackDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.FeaturePackDir");

	FFeaturePackDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::EnterprisePluginsDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.EnterprisePluginsDir");

	FEnterprisePluginsDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::EnterpriseFeaturePackDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.EnterpriseFeaturePackDir");

	FEnterpriseFeaturePackDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::EnterpriseDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.EnterpriseDir");

	FEnterpriseDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::EngineVersionAgnosticUserDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.EngineVersionAgnosticUserDir");

	FEngineVersionAgnosticUserDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::EngineUserDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.EngineUserDir");

	FEngineUserDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::EngineSourceDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.EngineSourceDir");

	FEngineSourceDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::EngineSavedDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.EngineSavedDir");

	FEngineSavedDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::EnginePluginsDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.EnginePluginsDir");

	FEnginePluginsDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::EngineIntermediateDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.EngineIntermediateDir");

	FEngineIntermediateDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::EngineDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.EngineDir");

	FEngineDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::EngineContentDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.EngineContentDir");

	FEngineContentDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::EngineConfigDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.EngineConfigDir");

	FEngineConfigDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UBlueprintPathsLibrary::DirectoryExists(struct FString InPath){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.DirectoryExists");

	FDirectoryExists parms{};	
	parms.InPath = InPath;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::DiffDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.DiffDir");

	FDiffDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::CreateTempFilename(struct FString Path, struct FString Prefix, struct FString Extension){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.CreateTempFilename");

	FCreateTempFilename parms{};	
	parms.Path = Path;
	parms.Prefix = Prefix;
	parms.Extension = Extension;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::ConvertToSandboxPath(struct FString InPath, struct FString InSandboxName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ConvertToSandboxPath");

	FConvertToSandboxPath parms{};	
	parms.InPath = InPath;
	parms.InSandboxName = InSandboxName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::ConvertRelativePathToFull(struct FString InPath, struct FString InBasePath){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ConvertRelativePathToFull");

	FConvertRelativePathToFull parms{};	
	parms.InPath = InPath;
	parms.InBasePath = InBasePath;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::ConvertFromSandboxPath(struct FString InPath, struct FString InSandboxName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ConvertFromSandboxPath");

	FConvertFromSandboxPath parms{};	
	parms.InPath = InPath;
	parms.InSandboxName = InSandboxName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::Combine(struct TArray<struct FString>& InPaths){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.Combine");

	FCombine parms{};	
	parms.InPaths = InPaths;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UBlueprintPathsLibrary::CollapseRelativeDirectories(struct FString InPath, struct FString& OutPath){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.CollapseRelativeDirectories");

	FCollapseRelativeDirectories parms{};	
	parms.InPath = InPath;
	parms.OutPath = OutPath;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::CloudDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.CloudDir");

	FCloudDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::ChangeExtension(struct FString InPath, struct FString InNewExtension){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ChangeExtension");

	FChangeExtension parms{};	
	parms.InPath = InPath;
	parms.InNewExtension = InNewExtension;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::BugItDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.BugItDir");

	FBugItDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::AutomationTransientDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.AutomationTransientDir");

	FAutomationTransientDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::AutomationLogDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.AutomationLogDir");

	FAutomationLogDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UBlueprintPathsLibrary::AutomationDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.AutomationDir");

	FAutomationDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<struct FString> UAnimationSettings::GetBoneCustomAttributeNamesToImport(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationSettings.GetBoneCustomAttributeNamesToImport");

	FGetBoneCustomAttributeNamesToImport parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void ALevelScriptActor::WorldOriginLocationChanged(struct FIntVector OldOriginLocation, struct FIntVector NewOriginLocation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LevelScriptActor.WorldOriginLocationChanged");

	FWorldOriginLocationChanged parms{};	
	parms.OldOriginLocation = OldOriginLocation;
	parms.NewOriginLocation = NewOriginLocation;

	ProcessEvent(fn, &parms);
}

void ALevelScriptActor::SetCinematicMode(bool bCinematicMode, bool bHidePlayer, bool bAffectsHUD, bool bAffectsMovement, bool bAffectsTurning){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LevelScriptActor.SetCinematicMode");

	FSetCinematicMode parms{};	
	parms.bCinematicMode = bCinematicMode;
	parms.bHidePlayer = bHidePlayer;
	parms.bAffectsHUD = bAffectsHUD;
	parms.bAffectsMovement = bAffectsMovement;
	parms.bAffectsTurning = bAffectsTurning;

	ProcessEvent(fn, &parms);
}

bool ALevelScriptActor::RemoteEvent(struct FName EventName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LevelScriptActor.RemoteEvent");

	FRemoteEvent parms{};	
	parms.EventName = EventName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void ALevelScriptActor::LevelReset(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LevelScriptActor.LevelReset");

	FLevelReset parms{};	

	ProcessEvent(fn, &parms);
}

void ADebugCameraController::ToggleDisplay(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DebugCameraController.ToggleDisplay");

	FToggleDisplay parms{};	

	ProcessEvent(fn, &parms);
}

void ADebugCameraController::ShowDebugSelectedInfo(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DebugCameraController.ShowDebugSelectedInfo");

	FShowDebugSelectedInfo parms{};	

	ProcessEvent(fn, &parms);
}

void ADebugCameraController::SetPawnMovementSpeedScale(float NewSpeedScale){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DebugCameraController.SetPawnMovementSpeedScale");

	FSetPawnMovementSpeedScale parms{};	
	parms.NewSpeedScale = NewSpeedScale;

	ProcessEvent(fn, &parms);
}

void ADebugCameraController::ReceiveOnDeactivate(struct APlayerController* RestoredPC){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DebugCameraController.ReceiveOnDeactivate");

	FReceiveOnDeactivate parms{};	
	parms.RestoredPC = RestoredPC;

	ProcessEvent(fn, &parms);
}

void ADebugCameraController::ReceiveOnActorSelected(struct AActor* NewSelectedActor, struct FVector& SelectHitLocation, struct FVector& SelectHitNormal, struct FHitResult& Hit){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DebugCameraController.ReceiveOnActorSelected");

	FReceiveOnActorSelected parms{};	
	parms.NewSelectedActor = NewSelectedActor;
	parms.SelectHitLocation = SelectHitLocation;
	parms.SelectHitNormal = SelectHitNormal;
	parms.Hit = Hit;

	ProcessEvent(fn, &parms);
}

void ADebugCameraController::ReceiveOnActivate(struct APlayerController* OriginalPC){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DebugCameraController.ReceiveOnActivate");

	FReceiveOnActivate parms{};	
	parms.OriginalPC = OriginalPC;

	ProcessEvent(fn, &parms);
}

struct AActor* ADebugCameraController::GetSelectedActor(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DebugCameraController.GetSelectedActor");

	FGetSelectedActor parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UViewportStatsSubsystem::RemoveDisplayDelegate(int32_t IndexToRemove){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ViewportStatsSubsystem.RemoveDisplayDelegate");

	FRemoveDisplayDelegate parms{};	
	parms.IndexToRemove = IndexToRemove;

	ProcessEvent(fn, &parms);
}

void UViewportStatsSubsystem::AddTimedDisplay(struct FText Text, struct FLinearColor Color, float Duration, struct FVector2D& DisplayOffset){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ViewportStatsSubsystem.AddTimedDisplay");

	FAddTimedDisplay parms{};	
	parms.Text = Text;
	parms.Color = Color;
	parms.Duration = Duration;
	parms.DisplayOffset = DisplayOffset;

	ProcessEvent(fn, &parms);
}

int32_t UViewportStatsSubsystem::AddDisplayDelegate(struct FDelegate& Delegate){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ViewportStatsSubsystem.AddDisplayDelegate");

	FAddDisplayDelegate parms{};	
	parms.Delegate = Delegate;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UParticleSystem::ContainsEmitterType(UObject* TypeData){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ParticleSystem.ContainsEmitterType");

	FContainsEmitterType parms{};	
	parms.TypeData = TypeData;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UGameplayStatics::UnRetainAllSoundsInSoundClass(struct USoundClass* InSoundClass){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.UnRetainAllSoundsInSoundClass");

	FUnRetainAllSoundsInSoundClass parms{};	
	parms.InSoundClass = InSoundClass;

	ProcessEvent(fn, &parms);
}

void UGameplayStatics::UnloadStreamLevelBySoftObjectPtr(struct UObject* WorldContextObject, struct TSoftObjectPtr<UWorld> Level, struct FLatentActionInfo LatentInfo, bool bShouldBlockOnUnload){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.UnloadStreamLevelBySoftObjectPtr");

	FUnloadStreamLevelBySoftObjectPtr parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Level = Level;
	parms.LatentInfo = LatentInfo;
	parms.bShouldBlockOnUnload = bShouldBlockOnUnload;

	ProcessEvent(fn, &parms);
}

void UGameplayStatics::UnloadStreamLevel(struct UObject* WorldContextObject, struct FName LevelName, struct FLatentActionInfo LatentInfo, bool bShouldBlockOnUnload){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.UnloadStreamLevel");

	FUnloadStreamLevel parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.LevelName = LevelName;
	parms.LatentInfo = LatentInfo;
	parms.bShouldBlockOnUnload = bShouldBlockOnUnload;

	ProcessEvent(fn, &parms);
}

bool UGameplayStatics::SuggestProjectileVelocity_CustomArc(struct UObject* WorldContextObject, struct FVector& OutLaunchVelocity, struct FVector StartPos, struct FVector EndPos, float OverrideGravityZ, float ArcParam){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SuggestProjectileVelocity_CustomArc");

	FSuggestProjectileVelocity_CustomArc parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.OutLaunchVelocity = OutLaunchVelocity;
	parms.StartPos = StartPos;
	parms.EndPos = EndPos;
	parms.OverrideGravityZ = OverrideGravityZ;
	parms.ArcParam = ArcParam;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UAudioComponent* UGameplayStatics::SpawnSoundAttached(struct USoundBase* Sound, struct USceneComponent* AttachToComponent, struct FName AttachPointName, struct FVector Location, struct FRotator Rotation, enum class EAttachLocation LocationType, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, struct USoundAttenuation* AttenuationSettings, struct USoundConcurrency* ConcurrencySettings, bool bAutoDestroy){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnSoundAttached");

	FSpawnSoundAttached parms{};	
	parms.Sound = Sound;
	parms.AttachToComponent = AttachToComponent;
	parms.AttachPointName = AttachPointName;
	parms.Location = Location;
	parms.Rotation = Rotation;
	parms.LocationType = LocationType;
	parms.bStopWhenAttachedToDestroyed = bStopWhenAttachedToDestroyed;
	parms.VolumeMultiplier = VolumeMultiplier;
	parms.PitchMultiplier = PitchMultiplier;
	parms.StartTime = StartTime;
	parms.AttenuationSettings = AttenuationSettings;
	parms.ConcurrencySettings = ConcurrencySettings;
	parms.bAutoDestroy = bAutoDestroy;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UAudioComponent* UGameplayStatics::SpawnSoundAtLocation(struct UObject* WorldContextObject, struct USoundBase* Sound, struct FVector Location, struct FRotator Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, struct USoundAttenuation* AttenuationSettings, struct USoundConcurrency* ConcurrencySettings, bool bAutoDestroy){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnSoundAtLocation");

	FSpawnSoundAtLocation parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Sound = Sound;
	parms.Location = Location;
	parms.Rotation = Rotation;
	parms.VolumeMultiplier = VolumeMultiplier;
	parms.PitchMultiplier = PitchMultiplier;
	parms.StartTime = StartTime;
	parms.AttenuationSettings = AttenuationSettings;
	parms.ConcurrencySettings = ConcurrencySettings;
	parms.bAutoDestroy = bAutoDestroy;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UAudioComponent* UGameplayStatics::SpawnSound2D(struct UObject* WorldContextObject, struct USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier, float StartTime, struct USoundConcurrency* ConcurrencySettings, bool bPersistAcrossLevelTransition, bool bAutoDestroy){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnSound2D");

	FSpawnSound2D parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Sound = Sound;
	parms.VolumeMultiplier = VolumeMultiplier;
	parms.PitchMultiplier = PitchMultiplier;
	parms.StartTime = StartTime;
	parms.ConcurrencySettings = ConcurrencySettings;
	parms.bPersistAcrossLevelTransition = bPersistAcrossLevelTransition;
	parms.bAutoDestroy = bAutoDestroy;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UObject* UGameplayStatics::SpawnObject(UObject* ObjectClass, struct UObject* Outer){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnObject");

	FSpawnObject parms{};	
	parms.ObjectClass = ObjectClass;
	parms.Outer = Outer;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UForceFeedbackComponent* UGameplayStatics::SpawnForceFeedbackAttached(struct UForceFeedbackEffect* ForceFeedbackEffect, struct USceneComponent* AttachToComponent, struct FName AttachPointName, struct FVector Location, struct FRotator Rotation, enum class EAttachLocation LocationType, bool bStopWhenAttachedToDestroyed, bool bLooping, float IntensityMultiplier, float StartTime, struct UForceFeedbackAttenuation* AttenuationSettings, bool bAutoDestroy){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnForceFeedbackAttached");

	FSpawnForceFeedbackAttached parms{};	
	parms.ForceFeedbackEffect = ForceFeedbackEffect;
	parms.AttachToComponent = AttachToComponent;
	parms.AttachPointName = AttachPointName;
	parms.Location = Location;
	parms.Rotation = Rotation;
	parms.LocationType = LocationType;
	parms.bStopWhenAttachedToDestroyed = bStopWhenAttachedToDestroyed;
	parms.bLooping = bLooping;
	parms.IntensityMultiplier = IntensityMultiplier;
	parms.StartTime = StartTime;
	parms.AttenuationSettings = AttenuationSettings;
	parms.bAutoDestroy = bAutoDestroy;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UForceFeedbackComponent* UGameplayStatics::SpawnForceFeedbackAtLocation(struct UObject* WorldContextObject, struct UForceFeedbackEffect* ForceFeedbackEffect, struct FVector Location, struct FRotator Rotation, bool bLooping, float IntensityMultiplier, float StartTime, struct UForceFeedbackAttenuation* AttenuationSettings, bool bAutoDestroy){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnForceFeedbackAtLocation");

	FSpawnForceFeedbackAtLocation parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.ForceFeedbackEffect = ForceFeedbackEffect;
	parms.Location = Location;
	parms.Rotation = Rotation;
	parms.bLooping = bLooping;
	parms.IntensityMultiplier = IntensityMultiplier;
	parms.StartTime = StartTime;
	parms.AttenuationSettings = AttenuationSettings;
	parms.bAutoDestroy = bAutoDestroy;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UParticleSystemComponent* UGameplayStatics::SpawnEmitterAttached(struct UParticleSystem* EmitterTemplate, struct USceneComponent* AttachToComponent, struct FName AttachPointName, struct FVector Location, struct FRotator Rotation, struct FVector Scale, enum class EAttachLocation LocationType, bool bAutoDestroy, uint8_t PoolingMethod, bool bAutoActivate){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnEmitterAttached");

	FSpawnEmitterAttached parms{};	
	parms.EmitterTemplate = EmitterTemplate;
	parms.AttachToComponent = AttachToComponent;
	parms.AttachPointName = AttachPointName;
	parms.Location = Location;
	parms.Rotation = Rotation;
	parms.Scale = Scale;
	parms.LocationType = LocationType;
	parms.bAutoDestroy = bAutoDestroy;
	parms.PoolingMethod = PoolingMethod;
	parms.bAutoActivate = bAutoActivate;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UParticleSystemComponent* UGameplayStatics::SpawnEmitterAtLocation(struct UObject* WorldContextObject, struct UParticleSystem* EmitterTemplate, struct FVector Location, struct FRotator Rotation, struct FVector Scale, bool bAutoDestroy, uint8_t PoolingMethod, bool bAutoActivateSystem){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnEmitterAtLocation");

	FSpawnEmitterAtLocation parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.EmitterTemplate = EmitterTemplate;
	parms.Location = Location;
	parms.Rotation = Rotation;
	parms.Scale = Scale;
	parms.bAutoDestroy = bAutoDestroy;
	parms.PoolingMethod = PoolingMethod;
	parms.bAutoActivateSystem = bAutoActivateSystem;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UAudioComponent* UGameplayStatics::SpawnDialogueAttached(struct UDialogueWave* Dialogue, struct FDialogueContext& Context, struct USceneComponent* AttachToComponent, struct FName AttachPointName, struct FVector Location, struct FRotator Rotation, enum class EAttachLocation LocationType, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, struct USoundAttenuation* AttenuationSettings, bool bAutoDestroy){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnDialogueAttached");

	FSpawnDialogueAttached parms{};	
	parms.Dialogue = Dialogue;
	parms.Context = Context;
	parms.AttachToComponent = AttachToComponent;
	parms.AttachPointName = AttachPointName;
	parms.Location = Location;
	parms.Rotation = Rotation;
	parms.LocationType = LocationType;
	parms.bStopWhenAttachedToDestroyed = bStopWhenAttachedToDestroyed;
	parms.VolumeMultiplier = VolumeMultiplier;
	parms.PitchMultiplier = PitchMultiplier;
	parms.StartTime = StartTime;
	parms.AttenuationSettings = AttenuationSettings;
	parms.bAutoDestroy = bAutoDestroy;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UAudioComponent* UGameplayStatics::SpawnDialogueAtLocation(struct UObject* WorldContextObject, struct UDialogueWave* Dialogue, struct FDialogueContext& Context, struct FVector Location, struct FRotator Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, struct USoundAttenuation* AttenuationSettings, bool bAutoDestroy){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnDialogueAtLocation");

	FSpawnDialogueAtLocation parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Dialogue = Dialogue;
	parms.Context = Context;
	parms.Location = Location;
	parms.Rotation = Rotation;
	parms.VolumeMultiplier = VolumeMultiplier;
	parms.PitchMultiplier = PitchMultiplier;
	parms.StartTime = StartTime;
	parms.AttenuationSettings = AttenuationSettings;
	parms.bAutoDestroy = bAutoDestroy;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UAudioComponent* UGameplayStatics::SpawnDialogue2D(struct UObject* WorldContextObject, struct UDialogueWave* Dialogue, struct FDialogueContext& Context, float VolumeMultiplier, float PitchMultiplier, float StartTime, bool bAutoDestroy){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnDialogue2D");

	FSpawnDialogue2D parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Dialogue = Dialogue;
	parms.Context = Context;
	parms.VolumeMultiplier = VolumeMultiplier;
	parms.PitchMultiplier = PitchMultiplier;
	parms.StartTime = StartTime;
	parms.bAutoDestroy = bAutoDestroy;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UDecalComponent* UGameplayStatics::SpawnDecalAttached(struct UMaterialInterface* DecalMaterial, struct FVector DecalSize, struct USceneComponent* AttachToComponent, struct FName AttachPointName, struct FVector Location, struct FRotator Rotation, enum class EAttachLocation LocationType, float LifeSpan){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnDecalAttached");

	FSpawnDecalAttached parms{};	
	parms.DecalMaterial = DecalMaterial;
	parms.DecalSize = DecalSize;
	parms.AttachToComponent = AttachToComponent;
	parms.AttachPointName = AttachPointName;
	parms.Location = Location;
	parms.Rotation = Rotation;
	parms.LocationType = LocationType;
	parms.LifeSpan = LifeSpan;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UDecalComponent* UGameplayStatics::SpawnDecalAtLocation(struct UObject* WorldContextObject, struct UMaterialInterface* DecalMaterial, struct FVector DecalSize, struct FVector Location, struct FRotator Rotation, float LifeSpan){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnDecalAtLocation");

	FSpawnDecalAtLocation parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.DecalMaterial = DecalMaterial;
	parms.DecalSize = DecalSize;
	parms.Location = Location;
	parms.Rotation = Rotation;
	parms.LifeSpan = LifeSpan;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UGameplayStatics::SetWorldOriginLocation(struct UObject* WorldContextObject, struct FIntVector NewLocation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetWorldOriginLocation");

	FSetWorldOriginLocation parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.NewLocation = NewLocation;

	ProcessEvent(fn, &parms);
}

void UGameplayStatics::SetViewportMouseCaptureMode(struct UObject* WorldContextObject, uint8_t MouseCaptureMode){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetViewportMouseCaptureMode");

	FSetViewportMouseCaptureMode parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.MouseCaptureMode = MouseCaptureMode;

	ProcessEvent(fn, &parms);
}

void UGameplayStatics::SetSubtitlesEnabled(bool bEnabled){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetSubtitlesEnabled");

	FSetSubtitlesEnabled parms{};	
	parms.bEnabled = bEnabled;

	ProcessEvent(fn, &parms);
}

void UGameplayStatics::SetSoundMixClassOverride(struct UObject* WorldContextObject, struct USoundMix* InSoundMixModifier, struct USoundClass* InSoundClass, float Volume, float Pitch, float FadeInTime, bool bApplyToChildren){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetSoundMixClassOverride");

	FSetSoundMixClassOverride parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.InSoundMixModifier = InSoundMixModifier;
	parms.InSoundClass = InSoundClass;
	parms.Volume = Volume;
	parms.Pitch = Pitch;
	parms.FadeInTime = FadeInTime;
	parms.bApplyToChildren = bApplyToChildren;

	ProcessEvent(fn, &parms);
}

void UGameplayStatics::SetSoundClassDistanceScale(struct UObject* WorldContextObject, struct USoundClass* SoundClass, float DistanceAttenuationScale, float TimeSec){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetSoundClassDistanceScale");

	FSetSoundClassDistanceScale parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.SoundClass = SoundClass;
	parms.DistanceAttenuationScale = DistanceAttenuationScale;
	parms.TimeSec = TimeSec;

	ProcessEvent(fn, &parms);
}

void UGameplayStatics::SetPlayerPlatformUserId(struct APlayerController* PlayerController, struct FPlatformUserId userID){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetPlayerPlatformUserId");

	FSetPlayerPlatformUserId parms{};	
	parms.PlayerController = PlayerController;
	parms.userID = userID;

	ProcessEvent(fn, &parms);
}

void UGameplayStatics::SetPlayerControllerID(struct APlayerController* Player, int32_t ControllerId){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetPlayerControllerID");

	FSetPlayerControllerID parms{};	
	parms.Player = Player;
	parms.ControllerId = ControllerId;

	ProcessEvent(fn, &parms);
}

void UGameplayStatics::SetMaxAudioChannelsScaled(struct UObject* WorldContextObject, float MaxChannelCountScale){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetMaxAudioChannelsScaled");

	FSetMaxAudioChannelsScaled parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.MaxChannelCountScale = MaxChannelCountScale;

	ProcessEvent(fn, &parms);
}

void UGameplayStatics::SetGlobalTimeDilation(struct UObject* WorldContextObject, float TimeDilation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetGlobalTimeDilation");

	FSetGlobalTimeDilation parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.TimeDilation = TimeDilation;

	ProcessEvent(fn, &parms);
}

void UGameplayStatics::SetGlobalPitchModulation(struct UObject* WorldContextObject, float PitchModulation, float TimeSec){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetGlobalPitchModulation");

	FSetGlobalPitchModulation parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.PitchModulation = PitchModulation;
	parms.TimeSec = TimeSec;

	ProcessEvent(fn, &parms);
}

void UGameplayStatics::SetGlobalListenerFocusParameters(struct UObject* WorldContextObject, float FocusAzimuthScale, float NonFocusAzimuthScale, float FocusDistanceScale, float NonFocusDistanceScale, float FocusVolumeScale, float NonFocusVolumeScale, float FocusPriorityScale, float NonFocusPriorityScale){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetGlobalListenerFocusParameters");

	FSetGlobalListenerFocusParameters parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.FocusAzimuthScale = FocusAzimuthScale;
	parms.NonFocusAzimuthScale = NonFocusAzimuthScale;
	parms.FocusDistanceScale = FocusDistanceScale;
	parms.NonFocusDistanceScale = NonFocusDistanceScale;
	parms.FocusVolumeScale = FocusVolumeScale;
	parms.NonFocusVolumeScale = NonFocusVolumeScale;
	parms.FocusPriorityScale = FocusPriorityScale;
	parms.NonFocusPriorityScale = NonFocusPriorityScale;

	ProcessEvent(fn, &parms);
}

bool UGameplayStatics::SetGamePaused(struct UObject* WorldContextObject, bool bPaused){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetGamePaused");

	FSetGamePaused parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.bPaused = bPaused;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UGameplayStatics::SetForceDisableSplitscreen(struct UObject* WorldContextObject, bool bDisable){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetForceDisableSplitscreen");

	FSetForceDisableSplitscreen parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.bDisable = bDisable;

	ProcessEvent(fn, &parms);
}

void UGameplayStatics::SetEnableWorldRendering(struct UObject* WorldContextObject, bool bEnable){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetEnableWorldRendering");

	FSetEnableWorldRendering parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.bEnable = bEnable;

	ProcessEvent(fn, &parms);
}

void UGameplayStatics::SetBaseSoundMix(struct UObject* WorldContextObject, struct USoundMix* InSoundMix){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetBaseSoundMix");

	FSetBaseSoundMix parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.InSoundMix = InSoundMix;

	ProcessEvent(fn, &parms);
}

bool UGameplayStatics::SetActiveSpatialPluginByName(struct UObject* WorldContextObject, struct FName InPluginName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetActiveSpatialPluginByName");

	FSetActiveSpatialPluginByName parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.InPluginName = InPluginName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UGameplayStatics::SaveGameToSlot(struct USaveGame* SaveGameObject, struct FString SlotName, int32_t UserIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SaveGameToSlot");

	FSaveGameToSlot parms{};	
	parms.SaveGameObject = SaveGameObject;
	parms.SlotName = SlotName;
	parms.UserIndex = UserIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UGameplayStatics::RemovePlayer(struct APlayerController* Player, bool bDestroyPawn){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.RemovePlayer");

	FRemovePlayer parms{};	
	parms.Player = Player;
	parms.bDestroyPawn = bDestroyPawn;

	ProcessEvent(fn, &parms);
}

struct FVector UGameplayStatics::RebaseZeroOriginOntoLocal(struct UObject* WorldContextObject, struct FVector WorldLocation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.RebaseZeroOriginOntoLocal");

	FRebaseZeroOriginOntoLocal parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.WorldLocation = WorldLocation;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UGameplayStatics::RebaseLocalOriginOntoZero(struct UObject* WorldContextObject, struct FVector WorldLocation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.RebaseLocalOriginOntoZero");

	FRebaseLocalOriginOntoZero parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.WorldLocation = WorldLocation;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UGameplayStatics::PushSoundMixModifier(struct UObject* WorldContextObject, struct USoundMix* InSoundMixModifier){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.PushSoundMixModifier");

	FPushSoundMixModifier parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.InSoundMixModifier = InSoundMixModifier;

	ProcessEvent(fn, &parms);
}

bool UGameplayStatics::ProjectWorldToScreen(struct APlayerController* Player, struct FVector& WorldPosition, struct FVector2D& ScreenPosition, bool bPlayerViewportRelative){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ProjectWorldToScreen");

	FProjectWorldToScreen parms{};	
	parms.Player = Player;
	parms.WorldPosition = WorldPosition;
	parms.ScreenPosition = ScreenPosition;
	parms.bPlayerViewportRelative = bPlayerViewportRelative;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UGameplayStatics::PrimeSound(struct USoundBase* InSound){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.PrimeSound");

	FPrimeSound parms{};	
	parms.InSound = InSound;

	ProcessEvent(fn, &parms);
}

void UGameplayStatics::PrimeAllSoundsInSoundClass(struct USoundClass* InSoundClass){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.PrimeAllSoundsInSoundClass");

	FPrimeAllSoundsInSoundClass parms{};	
	parms.InSoundClass = InSoundClass;

	ProcessEvent(fn, &parms);
}

void UGameplayStatics::PopSoundMixModifier(struct UObject* WorldContextObject, struct USoundMix* InSoundMixModifier){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.PopSoundMixModifier");

	FPopSoundMixModifier parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.InSoundMixModifier = InSoundMixModifier;

	ProcessEvent(fn, &parms);
}

void UGameplayStatics::PlayWorldCameraShake(struct UObject* WorldContextObject, UCameraShakeBase* Shake, struct FVector Epicenter, float InnerRadius, float OuterRadius, float Falloff, bool bOrientShakeTowardsEpicenter){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.PlayWorldCameraShake");

	FPlayWorldCameraShake parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Shake = Shake;
	parms.Epicenter = Epicenter;
	parms.InnerRadius = InnerRadius;
	parms.OuterRadius = OuterRadius;
	parms.Falloff = Falloff;
	parms.bOrientShakeTowardsEpicenter = bOrientShakeTowardsEpicenter;

	ProcessEvent(fn, &parms);
}

void UGameplayStatics::PlaySoundAtLocation(struct UObject* WorldContextObject, struct USoundBase* Sound, struct FVector Location, struct FRotator Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, struct USoundAttenuation* AttenuationSettings, struct USoundConcurrency* ConcurrencySettings, struct AActor* OwningActor, struct UInitialActiveSoundParams* InitialParams){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.PlaySoundAtLocation");

	FPlaySoundAtLocation parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Sound = Sound;
	parms.Location = Location;
	parms.Rotation = Rotation;
	parms.VolumeMultiplier = VolumeMultiplier;
	parms.PitchMultiplier = PitchMultiplier;
	parms.StartTime = StartTime;
	parms.AttenuationSettings = AttenuationSettings;
	parms.ConcurrencySettings = ConcurrencySettings;
	parms.OwningActor = OwningActor;
	parms.InitialParams = InitialParams;

	ProcessEvent(fn, &parms);
}

void UGameplayStatics::PlaySound2D(struct UObject* WorldContextObject, struct USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier, float StartTime, struct USoundConcurrency* ConcurrencySettings, struct AActor* OwningActor, bool bIsUISound){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.PlaySound2D");

	FPlaySound2D parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Sound = Sound;
	parms.VolumeMultiplier = VolumeMultiplier;
	parms.PitchMultiplier = PitchMultiplier;
	parms.StartTime = StartTime;
	parms.ConcurrencySettings = ConcurrencySettings;
	parms.OwningActor = OwningActor;
	parms.bIsUISound = bIsUISound;

	ProcessEvent(fn, &parms);
}

void UGameplayStatics::PlayDialogueAtLocation(struct UObject* WorldContextObject, struct UDialogueWave* Dialogue, struct FDialogueContext& Context, struct FVector Location, struct FRotator Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, struct USoundAttenuation* AttenuationSettings){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.PlayDialogueAtLocation");

	FPlayDialogueAtLocation parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Dialogue = Dialogue;
	parms.Context = Context;
	parms.Location = Location;
	parms.Rotation = Rotation;
	parms.VolumeMultiplier = VolumeMultiplier;
	parms.PitchMultiplier = PitchMultiplier;
	parms.StartTime = StartTime;
	parms.AttenuationSettings = AttenuationSettings;

	ProcessEvent(fn, &parms);
}

void UGameplayStatics::PlayDialogue2D(struct UObject* WorldContextObject, struct UDialogueWave* Dialogue, struct FDialogueContext& Context, float VolumeMultiplier, float PitchMultiplier, float StartTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.PlayDialogue2D");

	FPlayDialogue2D parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Dialogue = Dialogue;
	parms.Context = Context;
	parms.VolumeMultiplier = VolumeMultiplier;
	parms.PitchMultiplier = PitchMultiplier;
	parms.StartTime = StartTime;

	ProcessEvent(fn, &parms);
}

struct FString UGameplayStatics::ParseOption(struct FString Options, struct FString Key){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ParseOption");

	FParseOption parms{};	
	parms.Options = Options;
	parms.Key = Key;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UGameplayStatics::OpenLevelBySoftObjectPtr(struct UObject* WorldContextObject, struct TSoftObjectPtr<UWorld> Level, bool bAbsolute, struct FString Options){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.OpenLevelBySoftObjectPtr");

	FOpenLevelBySoftObjectPtr parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Level = Level;
	parms.bAbsolute = bAbsolute;
	parms.Options = Options;

	ProcessEvent(fn, &parms);
}

void UGameplayStatics::OpenLevel(struct UObject* WorldContextObject, struct FName LevelName, bool bAbsolute, struct FString Options){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.OpenLevel");

	FOpenLevel parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.LevelName = LevelName;
	parms.bAbsolute = bAbsolute;
	parms.Options = Options;

	ProcessEvent(fn, &parms);
}

bool UGameplayStatics::ObjectIsA(struct UObject* Object, UObject* ObjectClass){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ObjectIsA");

	FObjectIsA parms{};	
	parms.Object = Object;
	parms.ObjectClass = ObjectClass;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FHitResult UGameplayStatics::MakeHitResult(bool bBlockingHit, bool bInitialOverlap, float Time, float Distance, struct FVector Location, struct FVector ImpactPoint, struct FVector Normal, struct FVector ImpactNormal, struct UPhysicalMaterial* PhysMat, struct AActor* HitActor, struct UPrimitiveComponent* HitComponent, struct FName HitBoneName, struct FName BoneName, int32_t HitItem, int32_t ElementIndex, int32_t FaceIndex, struct FVector TraceStart, struct FVector TraceEnd){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.MakeHitResult");

	FMakeHitResult parms{};	
	parms.bBlockingHit = bBlockingHit;
	parms.bInitialOverlap = bInitialOverlap;
	parms.Time = Time;
	parms.Distance = Distance;
	parms.Location = Location;
	parms.ImpactPoint = ImpactPoint;
	parms.Normal = Normal;
	parms.ImpactNormal = ImpactNormal;
	parms.PhysMat = PhysMat;
	parms.HitActor = HitActor;
	parms.HitComponent = HitComponent;
	parms.HitBoneName = HitBoneName;
	parms.BoneName = BoneName;
	parms.HitItem = HitItem;
	parms.ElementIndex = ElementIndex;
	parms.FaceIndex = FaceIndex;
	parms.TraceStart = TraceStart;
	parms.TraceEnd = TraceEnd;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UGameplayStatics::LoadStreamLevelBySoftObjectPtr(struct UObject* WorldContextObject, struct TSoftObjectPtr<UWorld> Level, bool bMakeVisibleAfterLoad, bool bShouldBlockOnLoad, struct FLatentActionInfo LatentInfo){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.LoadStreamLevelBySoftObjectPtr");

	FLoadStreamLevelBySoftObjectPtr parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Level = Level;
	parms.bMakeVisibleAfterLoad = bMakeVisibleAfterLoad;
	parms.bShouldBlockOnLoad = bShouldBlockOnLoad;
	parms.LatentInfo = LatentInfo;

	ProcessEvent(fn, &parms);
}

void UGameplayStatics::LoadStreamLevel(struct UObject* WorldContextObject, struct FName LevelName, bool bMakeVisibleAfterLoad, bool bShouldBlockOnLoad, struct FLatentActionInfo LatentInfo){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.LoadStreamLevel");

	FLoadStreamLevel parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.LevelName = LevelName;
	parms.bMakeVisibleAfterLoad = bMakeVisibleAfterLoad;
	parms.bShouldBlockOnLoad = bShouldBlockOnLoad;
	parms.LatentInfo = LatentInfo;

	ProcessEvent(fn, &parms);
}

struct USaveGame* UGameplayStatics::LoadGameFromSlot(struct FString SlotName, int32_t UserIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.LoadGameFromSlot");

	FLoadGameFromSlot parms{};	
	parms.SlotName = SlotName;
	parms.UserIndex = UserIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UGameplayStatics::IsSplitscreenForceDisabled(struct UObject* WorldContextObject){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.IsSplitscreenForceDisabled");

	FIsSplitscreenForceDisabled parms{};	
	parms.WorldContextObject = WorldContextObject;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UGameplayStatics::IsGamePaused(struct UObject* WorldContextObject){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.IsGamePaused");

	FIsGamePaused parms{};	
	parms.WorldContextObject = WorldContextObject;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UGameplayStatics::HasOption(struct FString Options, struct FString InKey){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.HasOption");

	FHasOption parms{};	
	parms.Options = Options;
	parms.InKey = InKey;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UGameplayStatics::HasLaunchOption(struct FString OptionToCheck){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.HasLaunchOption");

	FHasLaunchOption parms{};	
	parms.OptionToCheck = OptionToCheck;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UGameplayStatics::GrassOverlappingSphereCount(struct UObject* WorldContextObject, struct UStaticMesh* StaticMesh, struct FVector CenterPosition, float Radius){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GrassOverlappingSphereCount");

	FGrassOverlappingSphereCount parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.StaticMesh = StaticMesh;
	parms.CenterPosition = CenterPosition;
	parms.Radius = Radius;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FIntVector UGameplayStatics::GetWorldOriginLocation(struct UObject* WorldContextObject){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetWorldOriginLocation");

	FGetWorldOriginLocation parms{};	
	parms.WorldContextObject = WorldContextObject;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UGameplayStatics::GetWorldDeltaSeconds(struct UObject* WorldContextObject){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetWorldDeltaSeconds");

	FGetWorldDeltaSeconds parms{};	
	parms.WorldContextObject = WorldContextObject;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UGameplayStatics::GetViewProjectionMatrix(struct FMinimalViewInfo DesiredView, struct FMatrix& ViewMatrix, struct FMatrix& ProjectionMatrix, struct FMatrix& ViewProjectionMatrix){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetViewProjectionMatrix");

	FGetViewProjectionMatrix parms{};	
	parms.DesiredView = DesiredView;
	parms.ViewMatrix = ViewMatrix;
	parms.ProjectionMatrix = ProjectionMatrix;
	parms.ViewProjectionMatrix = ViewProjectionMatrix;

	ProcessEvent(fn, &parms);
}

uint8_t UGameplayStatics::GetViewportMouseCaptureMode(struct UObject* WorldContextObject){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetViewportMouseCaptureMode");

	FGetViewportMouseCaptureMode parms{};	
	parms.WorldContextObject = WorldContextObject;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UGameplayStatics::GetUnpausedTimeSeconds(struct UObject* WorldContextObject){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetUnpausedTimeSeconds");

	FGetUnpausedTimeSeconds parms{};	
	parms.WorldContextObject = WorldContextObject;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UGameplayStatics::GetTimeSeconds(struct UObject* WorldContextObject){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetTimeSeconds");

	FGetTimeSeconds parms{};	
	parms.WorldContextObject = WorldContextObject;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

enum class EPhysicalSurface UGameplayStatics::GetSurfaceType(struct FHitResult& Hit){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetSurfaceType");

	FGetSurfaceType parms{};	
	parms.Hit = Hit;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct ULevelStreaming* UGameplayStatics::GetStreamingLevel(struct UObject* WorldContextObject, struct FName PackageName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetStreamingLevel");

	FGetStreamingLevel parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.PackageName = PackageName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UGameplayStatics::GetRealTimeSeconds(struct UObject* WorldContextObject){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetRealTimeSeconds");

	FGetRealTimeSeconds parms{};	
	parms.WorldContextObject = WorldContextObject;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct APlayerState* UGameplayStatics::GetPlayerStateFromUniqueNetId(struct UObject* WorldContextObject, struct FUniqueNetIdRepl& UniqueId){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetPlayerStateFromUniqueNetId");

	FGetPlayerStateFromUniqueNetId parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.UniqueId = UniqueId;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct APlayerState* UGameplayStatics::GetPlayerState(struct UObject* WorldContextObject, int32_t PlayerStateIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetPlayerState");

	FGetPlayerState parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.PlayerStateIndex = PlayerStateIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct APawn* UGameplayStatics::GetPlayerPawn(struct UObject* WorldContextObject, int32_t PlayerIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetPlayerPawn");

	FGetPlayerPawn parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.PlayerIndex = PlayerIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UGameplayStatics::GetPlayerControllerID(struct APlayerController* Player){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetPlayerControllerID");

	FGetPlayerControllerID parms{};	
	parms.Player = Player;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct APlayerController* UGameplayStatics::GetPlayerControllerFromPlatformUser(struct UObject* WorldContextObject, struct FPlatformUserId userID){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetPlayerControllerFromPlatformUser");

	FGetPlayerControllerFromPlatformUser parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.userID = userID;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct APlayerController* UGameplayStatics::GetPlayerControllerFromID(struct UObject* WorldContextObject, int32_t ControllerId){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetPlayerControllerFromID");

	FGetPlayerControllerFromID parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.ControllerId = ControllerId;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct APlayerController* UGameplayStatics::GetPlayerController(struct UObject* WorldContextObject, int32_t PlayerIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetPlayerController");

	FGetPlayerController parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.PlayerIndex = PlayerIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct ACharacter* UGameplayStatics::GetPlayerCharacter(struct UObject* WorldContextObject, int32_t PlayerIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetPlayerCharacter");

	FGetPlayerCharacter parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.PlayerIndex = PlayerIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct APlayerCameraManager* UGameplayStatics::GetPlayerCameraManager(struct UObject* WorldContextObject, int32_t PlayerIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetPlayerCameraManager");

	FGetPlayerCameraManager parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.PlayerIndex = PlayerIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UGameplayStatics::GetPlatformName(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetPlatformName");

	FGetPlatformName parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

UObject* UGameplayStatics::GetObjectClass(struct UObject* Object){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetObjectClass");

	FGetObjectClass parms{};	
	parms.Object = Object;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UGameplayStatics::GetNumPlayerStates(struct UObject* WorldContextObject){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetNumPlayerStates");

	FGetNumPlayerStates parms{};	
	parms.WorldContextObject = WorldContextObject;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UGameplayStatics::GetNumPlayerControllers(struct UObject* WorldContextObject){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetNumPlayerControllers");

	FGetNumPlayerControllers parms{};	
	parms.WorldContextObject = WorldContextObject;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UGameplayStatics::GetNumLocalPlayerControllers(struct UObject* WorldContextObject){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetNumLocalPlayerControllers");

	FGetNumLocalPlayerControllers parms{};	
	parms.WorldContextObject = WorldContextObject;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UGameplayStatics::GetMaxAudioChannelCount(struct UObject* WorldContextObject){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetMaxAudioChannelCount");

	FGetMaxAudioChannelCount parms{};	
	parms.WorldContextObject = WorldContextObject;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UGameplayStatics::GetKeyValue(struct FString Pair, struct FString& Key, struct FString& Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetKeyValue");

	FGetKeyValue parms{};	
	parms.Pair = Pair;
	parms.Key = Key;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

int32_t UGameplayStatics::GetIntOption(struct FString Options, struct FString Key, int32_t DefaultValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetIntOption");

	FGetIntOption parms{};	
	parms.Options = Options;
	parms.Key = Key;
	parms.DefaultValue = DefaultValue;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UGameplayStatics::GetGlobalTimeDilation(struct UObject* WorldContextObject){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetGlobalTimeDilation");

	FGetGlobalTimeDilation parms{};	
	parms.WorldContextObject = WorldContextObject;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct AGameStateBase* UGameplayStatics::GetGameState(struct UObject* WorldContextObject){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetGameState");

	FGetGameState parms{};	
	parms.WorldContextObject = WorldContextObject;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct AGameModeBase* UGameplayStatics::GetGameMode(struct UObject* WorldContextObject){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetGameMode");

	FGetGameMode parms{};	
	parms.WorldContextObject = WorldContextObject;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UGameInstance* UGameplayStatics::GetGameInstance(struct UObject* WorldContextObject){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetGameInstance");

	FGetGameInstance parms{};	
	parms.WorldContextObject = WorldContextObject;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UGameplayStatics::GetEnableWorldRendering(struct UObject* WorldContextObject){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetEnableWorldRendering");

	FGetEnableWorldRendering parms{};	
	parms.WorldContextObject = WorldContextObject;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UReverbEffect* UGameplayStatics::GetCurrentReverbEffect(struct UObject* WorldContextObject){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetCurrentReverbEffect");

	FGetCurrentReverbEffect parms{};	
	parms.WorldContextObject = WorldContextObject;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UGameplayStatics::GetCurrentLevelName(struct UObject* WorldContextObject, bool bRemovePrefixString){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetCurrentLevelName");

	FGetCurrentLevelName parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.bRemovePrefixString = bRemovePrefixString;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UGameplayStatics::GetClosestListenerLocation(struct UObject* WorldContextObject, struct FVector& Location, float MaximumRange, bool bAllowAttenuationOverride, struct FVector& ListenerPosition){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetClosestListenerLocation");

	FGetClosestListenerLocation parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Location = Location;
	parms.MaximumRange = MaximumRange;
	parms.bAllowAttenuationOverride = bAllowAttenuationOverride;
	parms.ListenerPosition = ListenerPosition;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<struct FName> UGameplayStatics::GetAvailableSpatialPluginNames(struct UObject* WorldContextObject){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetAvailableSpatialPluginNames");

	FGetAvailableSpatialPluginNames parms{};	
	parms.WorldContextObject = WorldContextObject;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UGameplayStatics::GetAudioTimeSeconds(struct UObject* WorldContextObject){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetAudioTimeSeconds");

	FGetAudioTimeSeconds parms{};	
	parms.WorldContextObject = WorldContextObject;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UGameplayStatics::GetAllActorsWithTag(struct UObject* WorldContextObject, struct FName Tag, struct TArray<struct AActor*>& OutActors){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetAllActorsWithTag");

	FGetAllActorsWithTag parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Tag = Tag;
	parms.OutActors = OutActors;

	ProcessEvent(fn, &parms);
}

void UGameplayStatics::GetAllActorsWithInterface(struct UObject* WorldContextObject, UInterface* Interface, struct TArray<struct AActor*>& OutActors){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetAllActorsWithInterface");

	FGetAllActorsWithInterface parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Interface = Interface;
	parms.OutActors = OutActors;

	ProcessEvent(fn, &parms);
}

void UGameplayStatics::GetAllActorsOfClassWithTag(struct UObject* WorldContextObject, AActor* ActorClass, struct FName Tag, struct TArray<struct AActor*>& OutActors){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetAllActorsOfClassWithTag");

	FGetAllActorsOfClassWithTag parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.ActorClass = ActorClass;
	parms.Tag = Tag;
	parms.OutActors = OutActors;

	ProcessEvent(fn, &parms);
}

void UGameplayStatics::GetAllActorsOfClass(struct UObject* WorldContextObject, AActor* ActorClass, struct TArray<struct AActor*>& OutActors){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetAllActorsOfClass");

	FGetAllActorsOfClass parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.ActorClass = ActorClass;
	parms.OutActors = OutActors;

	ProcessEvent(fn, &parms);
}

struct AActor* UGameplayStatics::GetActorOfClass(struct UObject* WorldContextObject, AActor* ActorClass){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetActorOfClass");

	FGetActorOfClass parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.ActorClass = ActorClass;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UGameplayStatics::GetActorArrayBounds(struct TArray<struct AActor*>& Actors, bool bOnlyCollidingComponents, struct FVector& Center, struct FVector& BoxExtent){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetActorArrayBounds");

	FGetActorArrayBounds parms{};	
	parms.Actors = Actors;
	parms.bOnlyCollidingComponents = bOnlyCollidingComponents;
	parms.Center = Center;
	parms.BoxExtent = BoxExtent;

	ProcessEvent(fn, &parms);
}

struct FVector UGameplayStatics::GetActorArrayAverageLocation(struct TArray<struct AActor*>& Actors){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetActorArrayAverageLocation");

	FGetActorArrayAverageLocation parms{};	
	parms.Actors = Actors;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FName UGameplayStatics::GetActiveSpatialPluginName(struct UObject* WorldContextObject){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetActiveSpatialPluginName");

	FGetActiveSpatialPluginName parms{};	
	parms.WorldContextObject = WorldContextObject;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UGameplayStatics::GetAccurateRealTime(int32_t& Seconds, double& PartialSeconds){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetAccurateRealTime");

	FGetAccurateRealTime parms{};	
	parms.Seconds = Seconds;
	parms.PartialSeconds = PartialSeconds;

	ProcessEvent(fn, &parms);
}

void UGameplayStatics::FlushLevelStreaming(struct UObject* WorldContextObject){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.FlushLevelStreaming");

	FFlushLevelStreaming parms{};	
	parms.WorldContextObject = WorldContextObject;

	ProcessEvent(fn, &parms);
}

struct AActor* UGameplayStatics::FinishSpawningActor(struct AActor* Actor, struct FTransform& SpawnTransform){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.FinishSpawningActor");

	FFinishSpawningActor parms{};	
	parms.Actor = Actor;
	parms.SpawnTransform = SpawnTransform;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct AActor* UGameplayStatics::FindNearestActor(struct FVector Origin, struct TArray<struct AActor*>& ActorsToCheck, float& Distance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.FindNearestActor");

	FFindNearestActor parms{};	
	parms.Origin = Origin;
	parms.ActorsToCheck = ActorsToCheck;
	parms.Distance = Distance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UGameplayStatics::FindCollisionUV(struct FHitResult& Hit, int32_t UVChannel, struct FVector2D& UV){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.FindCollisionUV");

	FFindCollisionUV parms{};	
	parms.Hit = Hit;
	parms.UVChannel = UVChannel;
	parms.UV = UV;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UGameplayStatics::EnableLiveStreaming(bool Enable){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.EnableLiveStreaming");

	FEnableLiveStreaming parms{};	
	parms.Enable = Enable;

	ProcessEvent(fn, &parms);
}

bool UGameplayStatics::DoesSaveGameExist(struct FString SlotName, int32_t UserIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.DoesSaveGameExist");

	FDoesSaveGameExist parms{};	
	parms.SlotName = SlotName;
	parms.UserIndex = UserIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UGameplayStatics::DeprojectScreenToWorld(struct APlayerController* Player, struct FVector2D& ScreenPosition, struct FVector& WorldPosition, struct FVector& WorldDirection){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.DeprojectScreenToWorld");

	FDeprojectScreenToWorld parms{};	
	parms.Player = Player;
	parms.ScreenPosition = ScreenPosition;
	parms.WorldPosition = WorldPosition;
	parms.WorldDirection = WorldDirection;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UGameplayStatics::DeprojectSceneCaptureToWorld(struct ASceneCapture2D* SceneCapture2D, struct FVector2D& TargetUV, struct FVector& WorldPosition, struct FVector& WorldDirection){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.DeprojectSceneCaptureToWorld");

	FDeprojectSceneCaptureToWorld parms{};	
	parms.SceneCapture2D = SceneCapture2D;
	parms.TargetUV = TargetUV;
	parms.WorldPosition = WorldPosition;
	parms.WorldDirection = WorldDirection;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UGameplayStatics::DeleteGameInSlot(struct FString SlotName, int32_t UserIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.DeleteGameInSlot");

	FDeleteGameInSlot parms{};	
	parms.SlotName = SlotName;
	parms.UserIndex = UserIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UGameplayStatics::DeactivateReverbEffect(struct UObject* WorldContextObject, struct FName TagName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.DeactivateReverbEffect");

	FDeactivateReverbEffect parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.TagName = TagName;

	ProcessEvent(fn, &parms);
}

struct UAudioComponent* UGameplayStatics::CreateSound2D(struct UObject* WorldContextObject, struct USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier, float StartTime, struct USoundConcurrency* ConcurrencySettings, bool bPersistAcrossLevelTransition, bool bAutoDestroy){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.CreateSound2D");

	FCreateSound2D parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Sound = Sound;
	parms.VolumeMultiplier = VolumeMultiplier;
	parms.PitchMultiplier = PitchMultiplier;
	parms.StartTime = StartTime;
	parms.ConcurrencySettings = ConcurrencySettings;
	parms.bPersistAcrossLevelTransition = bPersistAcrossLevelTransition;
	parms.bAutoDestroy = bAutoDestroy;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct USaveGame* UGameplayStatics::CreateSaveGameObject(USaveGame* SaveGameClass){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.CreateSaveGameObject");

	FCreateSaveGameObject parms{};	
	parms.SaveGameClass = SaveGameClass;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct APlayerController* UGameplayStatics::CreatePlayerFromPlatformUser(struct UObject* WorldContextObject, struct FPlatformUserId userID, bool bSpawnPlayerController){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.CreatePlayerFromPlatformUser");

	FCreatePlayerFromPlatformUser parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.userID = userID;
	parms.bSpawnPlayerController = bSpawnPlayerController;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct APlayerController* UGameplayStatics::CreatePlayer(struct UObject* WorldContextObject, int32_t ControllerId, bool bSpawnPlayerController){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.CreatePlayer");

	FCreatePlayer parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.ControllerId = ControllerId;
	parms.bSpawnPlayerController = bSpawnPlayerController;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UGameplayStatics::ClearSoundMixModifiers(struct UObject* WorldContextObject){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ClearSoundMixModifiers");

	FClearSoundMixModifiers parms{};	
	parms.WorldContextObject = WorldContextObject;

	ProcessEvent(fn, &parms);
}

void UGameplayStatics::ClearSoundMixClassOverride(struct UObject* WorldContextObject, struct USoundMix* InSoundMixModifier, struct USoundClass* InSoundClass, float FadeOutTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ClearSoundMixClassOverride");

	FClearSoundMixClassOverride parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.InSoundMixModifier = InSoundMixModifier;
	parms.InSoundClass = InSoundClass;
	parms.FadeOutTime = FadeOutTime;

	ProcessEvent(fn, &parms);
}

void UGameplayStatics::CancelAsyncLoading(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.CancelAsyncLoading");

	FCancelAsyncLoading parms{};	

	ProcessEvent(fn, &parms);
}

void UGameplayStatics::BreakHitResult(struct FHitResult& Hit, bool& bBlockingHit, bool& bInitialOverlap, float& Time, float& Distance, struct FVector& Location, struct FVector& ImpactPoint, struct FVector& Normal, struct FVector& ImpactNormal, struct UPhysicalMaterial*& PhysMat, struct AActor*& HitActor, struct UPrimitiveComponent*& HitComponent, struct FName& HitBoneName, struct FName& BoneName, int32_t& HitItem, int32_t& ElementIndex, int32_t& FaceIndex, struct FVector& TraceStart, struct FVector& TraceEnd){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.BreakHitResult");

	FBreakHitResult parms{};	
	parms.Hit = Hit;
	parms.bBlockingHit = bBlockingHit;
	parms.bInitialOverlap = bInitialOverlap;
	parms.Time = Time;
	parms.Distance = Distance;
	parms.Location = Location;
	parms.ImpactPoint = ImpactPoint;
	parms.Normal = Normal;
	parms.ImpactNormal = ImpactNormal;
	parms.PhysMat = PhysMat;
	parms.HitActor = HitActor;
	parms.HitComponent = HitComponent;
	parms.HitBoneName = HitBoneName;
	parms.BoneName = BoneName;
	parms.HitItem = HitItem;
	parms.ElementIndex = ElementIndex;
	parms.FaceIndex = FaceIndex;
	parms.TraceStart = TraceStart;
	parms.TraceEnd = TraceEnd;

	ProcessEvent(fn, &parms);
}

bool UGameplayStatics::BlueprintSuggestProjectileVelocity(struct UObject* WorldContextObject, struct FVector& TossVelocity, struct FVector StartLocation, struct FVector EndLocation, float LaunchSpeed, float OverrideGravityZ, enum class ESuggestProjVelocityTraceOption TraceOption, float CollisionRadius, bool bFavorHighArc, bool bDrawDebug){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.BlueprintSuggestProjectileVelocity");

	FBlueprintSuggestProjectileVelocity parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.TossVelocity = TossVelocity;
	parms.StartLocation = StartLocation;
	parms.EndLocation = EndLocation;
	parms.LaunchSpeed = LaunchSpeed;
	parms.OverrideGravityZ = OverrideGravityZ;
	parms.TraceOption = TraceOption;
	parms.CollisionRadius = CollisionRadius;
	parms.bFavorHighArc = bFavorHighArc;
	parms.bDrawDebug = bDrawDebug;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UGameplayStatics::Blueprint_PredictProjectilePath_ByTraceChannel(struct UObject* WorldContextObject, struct FHitResult& OutHit, struct TArray<struct FVector>& OutPathPositions, struct FVector& OutLastTraceDestination, struct FVector StartPos, struct FVector LaunchVelocity, bool bTracePath, float ProjectileRadius, enum class ECollisionChannel TraceChannel, bool bTraceComplex, struct TArray<struct AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, float DrawDebugTime, float SimFrequency, float MaxSimTime, float OverrideGravityZ){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.Blueprint_PredictProjectilePath_ByTraceChannel");

	FBlueprint_PredictProjectilePath_ByTraceChannel parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.OutHit = OutHit;
	parms.OutPathPositions = OutPathPositions;
	parms.OutLastTraceDestination = OutLastTraceDestination;
	parms.StartPos = StartPos;
	parms.LaunchVelocity = LaunchVelocity;
	parms.bTracePath = bTracePath;
	parms.ProjectileRadius = ProjectileRadius;
	parms.TraceChannel = TraceChannel;
	parms.bTraceComplex = bTraceComplex;
	parms.ActorsToIgnore = ActorsToIgnore;
	parms.DrawDebugType = DrawDebugType;
	parms.DrawDebugTime = DrawDebugTime;
	parms.SimFrequency = SimFrequency;
	parms.MaxSimTime = MaxSimTime;
	parms.OverrideGravityZ = OverrideGravityZ;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UGameplayStatics::Blueprint_PredictProjectilePath_ByObjectType(struct UObject* WorldContextObject, struct FHitResult& OutHit, struct TArray<struct FVector>& OutPathPositions, struct FVector& OutLastTraceDestination, struct FVector StartPos, struct FVector LaunchVelocity, bool bTracePath, float ProjectileRadius, struct TArray<enum class EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, struct TArray<struct AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, float DrawDebugTime, float SimFrequency, float MaxSimTime, float OverrideGravityZ){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.Blueprint_PredictProjectilePath_ByObjectType");

	FBlueprint_PredictProjectilePath_ByObjectType parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.OutHit = OutHit;
	parms.OutPathPositions = OutPathPositions;
	parms.OutLastTraceDestination = OutLastTraceDestination;
	parms.StartPos = StartPos;
	parms.LaunchVelocity = LaunchVelocity;
	parms.bTracePath = bTracePath;
	parms.ProjectileRadius = ProjectileRadius;
	parms.ObjectTypes = ObjectTypes;
	parms.bTraceComplex = bTraceComplex;
	parms.ActorsToIgnore = ActorsToIgnore;
	parms.DrawDebugType = DrawDebugType;
	parms.DrawDebugTime = DrawDebugTime;
	parms.SimFrequency = SimFrequency;
	parms.MaxSimTime = MaxSimTime;
	parms.OverrideGravityZ = OverrideGravityZ;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UGameplayStatics::Blueprint_PredictProjectilePath_Advanced(struct UObject* WorldContextObject, struct FPredictProjectilePathParams& PredictParams, struct FPredictProjectilePathResult& PredictResult){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.Blueprint_PredictProjectilePath_Advanced");

	FBlueprint_PredictProjectilePath_Advanced parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.PredictParams = PredictParams;
	parms.PredictResult = PredictResult;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct AActor* UGameplayStatics::BeginSpawningActorFromBlueprint(struct UObject* WorldContextObject, struct UBlueprint* Blueprint, struct FTransform& SpawnTransform, bool bNoCollisionFail){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.BeginSpawningActorFromBlueprint");

	FBeginSpawningActorFromBlueprint parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Blueprint = Blueprint;
	parms.SpawnTransform = SpawnTransform;
	parms.bNoCollisionFail = bNoCollisionFail;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct AActor* UGameplayStatics::BeginDeferredActorSpawnFromClass(struct UObject* WorldContextObject, AActor* ActorClass, struct FTransform& SpawnTransform, uint8_t CollisionHandlingOverride, struct AActor* Owner){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.BeginDeferredActorSpawnFromClass");

	FBeginDeferredActorSpawnFromClass parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.ActorClass = ActorClass;
	parms.SpawnTransform = SpawnTransform;
	parms.CollisionHandlingOverride = CollisionHandlingOverride;
	parms.Owner = Owner;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UGameplayStatics::AreSubtitlesEnabled(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.AreSubtitlesEnabled");

	FAreSubtitlesEnabled parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UGameplayStatics::AreAnyListenersWithinRange(struct UObject* WorldContextObject, struct FVector& Location, float MaximumRange){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.AreAnyListenersWithinRange");

	FAreAnyListenersWithinRange parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Location = Location;
	parms.MaximumRange = MaximumRange;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UGameplayStatics::ApplyRadialDamageWithFalloff(struct UObject* WorldContextObject, float BaseDamage, float MinimumDamage, struct FVector& Origin, float DamageInnerRadius, float DamageOuterRadius, float DamageFalloff, UDamageType* DamageTypeClass, struct TArray<struct AActor*>& IgnoreActors, struct AActor* DamageCauser, struct AController* InstigatedByController, enum class ECollisionChannel DamagePreventionChannel){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ApplyRadialDamageWithFalloff");

	FApplyRadialDamageWithFalloff parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.BaseDamage = BaseDamage;
	parms.MinimumDamage = MinimumDamage;
	parms.Origin = Origin;
	parms.DamageInnerRadius = DamageInnerRadius;
	parms.DamageOuterRadius = DamageOuterRadius;
	parms.DamageFalloff = DamageFalloff;
	parms.DamageTypeClass = DamageTypeClass;
	parms.IgnoreActors = IgnoreActors;
	parms.DamageCauser = DamageCauser;
	parms.InstigatedByController = InstigatedByController;
	parms.DamagePreventionChannel = DamagePreventionChannel;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UGameplayStatics::ApplyRadialDamage(struct UObject* WorldContextObject, float BaseDamage, struct FVector& Origin, float DamageRadius, UDamageType* DamageTypeClass, struct TArray<struct AActor*>& IgnoreActors, struct AActor* DamageCauser, struct AController* InstigatedByController, bool bDoFullDamage, enum class ECollisionChannel DamagePreventionChannel){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ApplyRadialDamage");

	FApplyRadialDamage parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.BaseDamage = BaseDamage;
	parms.Origin = Origin;
	parms.DamageRadius = DamageRadius;
	parms.DamageTypeClass = DamageTypeClass;
	parms.IgnoreActors = IgnoreActors;
	parms.DamageCauser = DamageCauser;
	parms.InstigatedByController = InstigatedByController;
	parms.bDoFullDamage = bDoFullDamage;
	parms.DamagePreventionChannel = DamagePreventionChannel;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UGameplayStatics::ApplyPointDamage(struct AActor* DamagedActor, float BaseDamage, struct FVector& HitFromDirection, struct FHitResult& HitInfo, struct AController* EventInstigator, struct AActor* DamageCauser, UDamageType* DamageTypeClass){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ApplyPointDamage");

	FApplyPointDamage parms{};	
	parms.DamagedActor = DamagedActor;
	parms.BaseDamage = BaseDamage;
	parms.HitFromDirection = HitFromDirection;
	parms.HitInfo = HitInfo;
	parms.EventInstigator = EventInstigator;
	parms.DamageCauser = DamageCauser;
	parms.DamageTypeClass = DamageTypeClass;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UGameplayStatics::ApplyDamage(struct AActor* DamagedActor, float BaseDamage, struct AController* EventInstigator, struct AActor* DamageCauser, UDamageType* DamageTypeClass){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ApplyDamage");

	FApplyDamage parms{};	
	parms.DamagedActor = DamagedActor;
	parms.BaseDamage = BaseDamage;
	parms.EventInstigator = EventInstigator;
	parms.DamageCauser = DamageCauser;
	parms.DamageTypeClass = DamageTypeClass;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UGameplayStatics::AnnounceAccessibleString(struct FString AnnouncementString){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.AnnounceAccessibleString");

	FAnnounceAccessibleString parms{};	
	parms.AnnouncementString = AnnouncementString;

	ProcessEvent(fn, &parms);
}

void UGameplayStatics::ActivateReverbEffect(struct UObject* WorldContextObject, struct UReverbEffect* ReverbEffect, struct FName TagName, float Priority, float Volume, float FadeTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ActivateReverbEffect");

	FActivateReverbEffect parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.ReverbEffect = ReverbEffect;
	parms.TagName = TagName;
	parms.Priority = Priority;
	parms.Volume = Volume;
	parms.FadeTime = FadeTime;

	ProcessEvent(fn, &parms);
}

void UVisualLoggerKismetLibrary::RedirectVislog(struct UObject* SourceOwner, struct UObject* DestinationOwner){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.VisualLoggerKismetLibrary.RedirectVislog");

	FRedirectVislog parms{};	
	parms.SourceOwner = SourceOwner;
	parms.DestinationOwner = DestinationOwner;

	ProcessEvent(fn, &parms);
}

void UVisualLoggerKismetLibrary::LogText(struct UObject* WorldContextObject, struct FString Text, struct FName LogCategory, bool bAddToMessageLog){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.VisualLoggerKismetLibrary.LogText");

	FLogText parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Text = Text;
	parms.LogCategory = LogCategory;
	parms.bAddToMessageLog = bAddToMessageLog;

	ProcessEvent(fn, &parms);
}

void UVisualLoggerKismetLibrary::LogSegment(struct UObject* WorldContextObject, struct FVector SegmentStart, struct FVector SegmentEnd, struct FString Text, struct FLinearColor ObjectColor, float Thickness, struct FName CategoryName, bool bAddToMessageLog){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.VisualLoggerKismetLibrary.LogSegment");

	FLogSegment parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.SegmentStart = SegmentStart;
	parms.SegmentEnd = SegmentEnd;
	parms.Text = Text;
	parms.ObjectColor = ObjectColor;
	parms.Thickness = Thickness;
	parms.CategoryName = CategoryName;
	parms.bAddToMessageLog = bAddToMessageLog;

	ProcessEvent(fn, &parms);
}

void UVisualLoggerKismetLibrary::LogLocation(struct UObject* WorldContextObject, struct FVector Location, struct FString Text, struct FLinearColor ObjectColor, float Radius, struct FName LogCategory, bool bAddToMessageLog){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.VisualLoggerKismetLibrary.LogLocation");

	FLogLocation parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Location = Location;
	parms.Text = Text;
	parms.ObjectColor = ObjectColor;
	parms.Radius = Radius;
	parms.LogCategory = LogCategory;
	parms.bAddToMessageLog = bAddToMessageLog;

	ProcessEvent(fn, &parms);
}

void UVisualLoggerKismetLibrary::LogBox(struct UObject* WorldContextObject, struct FBox BoxShape, struct FString Text, struct FLinearColor ObjectColor, struct FName LogCategory, bool bAddToMessageLog){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.VisualLoggerKismetLibrary.LogBox");

	FLogBox parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.BoxShape = BoxShape;
	parms.Text = Text;
	parms.ObjectColor = ObjectColor;
	parms.LogCategory = LogCategory;
	parms.bAddToMessageLog = bAddToMessageLog;

	ProcessEvent(fn, &parms);
}

void UVisualLoggerKismetLibrary::EnableRecording(bool bEnabled){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.VisualLoggerKismetLibrary.EnableRecording");

	FEnableRecording parms{};	
	parms.bEnabled = bEnabled;

	ProcessEvent(fn, &parms);
}

bool UAnimationCurveIdentifierExtensions::IsValid(struct FAnimationCurveIdentifier& Identifier){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationCurveIdentifierExtensions.IsValid");

	FIsValid parms{};	
	parms.Identifier = Identifier;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

uint8_t UAnimationCurveIdentifierExtensions::GetType(struct FAnimationCurveIdentifier& Identifier){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationCurveIdentifierExtensions.GetType");

	FGetType parms{};	
	parms.Identifier = Identifier;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FName UAnimationCurveIdentifierExtensions::GetName(struct FAnimationCurveIdentifier& Identifier){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationCurveIdentifierExtensions.GetName");

	FGetName parms{};	
	parms.Identifier = Identifier;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void ADecalActor::SetDecalMaterial(struct UMaterialInterface* NewDecalMaterial){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DecalActor.SetDecalMaterial");

	FSetDecalMaterial parms{};	
	parms.NewDecalMaterial = NewDecalMaterial;

	ProcessEvent(fn, &parms);
}

struct UMaterialInterface* ADecalActor::GetDecalMaterial(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DecalActor.GetDecalMaterial");

	FGetDecalMaterial parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UMaterialInstanceDynamic* ADecalActor::CreateDynamicMaterialInstance(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DecalActor.CreateDynamicMaterialInstance");

	FCreateDynamicMaterialInstance parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void USkyLightComponent::SetVolumetricScatteringIntensity(float NewIntensity){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetVolumetricScatteringIntensity");

	FSetVolumetricScatteringIntensity parms{};	
	parms.NewIntensity = NewIntensity;

	ProcessEvent(fn, &parms);
}

void USkyLightComponent::SetSourceCubemapAngle(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetSourceCubemapAngle");

	FSetSourceCubemapAngle parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void USkyLightComponent::SetOcclusionTint(struct FColor& InTint){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetOcclusionTint");

	FSetOcclusionTint parms{};	
	parms.InTint = InTint;

	ProcessEvent(fn, &parms);
}

void USkyLightComponent::SetOcclusionExponent(float InOcclusionExponent){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetOcclusionExponent");

	FSetOcclusionExponent parms{};	
	parms.InOcclusionExponent = InOcclusionExponent;

	ProcessEvent(fn, &parms);
}

void USkyLightComponent::SetOcclusionContrast(float InOcclusionContrast){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetOcclusionContrast");

	FSetOcclusionContrast parms{};	
	parms.InOcclusionContrast = InOcclusionContrast;

	ProcessEvent(fn, &parms);
}

void USkyLightComponent::SetMinOcclusion(float InMinOcclusion){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetMinOcclusion");

	FSetMinOcclusion parms{};	
	parms.InMinOcclusion = InMinOcclusion;

	ProcessEvent(fn, &parms);
}

void USkyLightComponent::SetLowerHemisphereColor(struct FLinearColor& InLowerHemisphereColor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetLowerHemisphereColor");

	FSetLowerHemisphereColor parms{};	
	parms.InLowerHemisphereColor = InLowerHemisphereColor;

	ProcessEvent(fn, &parms);
}

void USkyLightComponent::SetLightColor(struct FLinearColor NewLightColor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetLightColor");

	FSetLightColor parms{};	
	parms.NewLightColor = NewLightColor;

	ProcessEvent(fn, &parms);
}

void USkyLightComponent::SetIntensity(float NewIntensity){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetIntensity");

	FSetIntensity parms{};	
	parms.NewIntensity = NewIntensity;

	ProcessEvent(fn, &parms);
}

void USkyLightComponent::SetIndirectLightingIntensity(float NewIntensity){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetIndirectLightingIntensity");

	FSetIndirectLightingIntensity parms{};	
	parms.NewIntensity = NewIntensity;

	ProcessEvent(fn, &parms);
}

void USkyLightComponent::SetCubemapBlend(struct UTextureCube* SourceCubemap, struct UTextureCube* DestinationCubemap, float InBlendFraction){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetCubemapBlend");

	FSetCubemapBlend parms{};	
	parms.SourceCubemap = SourceCubemap;
	parms.DestinationCubemap = DestinationCubemap;
	parms.InBlendFraction = InBlendFraction;

	ProcessEvent(fn, &parms);
}

void USkyLightComponent::SetCubemap(struct UTextureCube* NewCubemap){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetCubemap");

	FSetCubemap parms{};	
	parms.NewCubemap = NewCubemap;

	ProcessEvent(fn, &parms);
}

void USkyLightComponent::RecaptureSky(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.RecaptureSky");

	FRecaptureSky parms{};	

	ProcessEvent(fn, &parms);
}

void UDataTableFunctionLibrary::GetDataTableRowNames(struct UDataTable* Table, struct TArray<struct FName>& OutRowNames){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataTableFunctionLibrary.GetDataTableRowNames");

	FGetDataTableRowNames parms{};	
	parms.Table = Table;
	parms.OutRowNames = OutRowNames;

	ProcessEvent(fn, &parms);
}

bool UDataTableFunctionLibrary::GetDataTableRowFromName(struct UDataTable* Table, struct FName RowName, struct FTableRowBase& OutRow){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataTableFunctionLibrary.GetDataTableRowFromName");

	FGetDataTableRowFromName parms{};	
	parms.Table = Table;
	parms.RowName = RowName;
	parms.OutRow = OutRow;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<struct FString> UDataTableFunctionLibrary::GetDataTableColumnAsString(struct UDataTable* DataTable, struct FName PropertyName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataTableFunctionLibrary.GetDataTableColumnAsString");

	FGetDataTableColumnAsString parms{};	
	parms.DataTable = DataTable;
	parms.PropertyName = PropertyName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UDataTableFunctionLibrary::EvaluateCurveTableRow(struct UCurveTable* CurveTable, struct FName RowName, float InXY, enum class EEvaluateCurveTableResult& OutResult, float& OutXY, struct FString ContextString){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataTableFunctionLibrary.EvaluateCurveTableRow");

	FEvaluateCurveTableRow parms{};	
	parms.CurveTable = CurveTable;
	parms.RowName = RowName;
	parms.InXY = InXY;
	parms.OutResult = OutResult;
	parms.OutXY = OutXY;
	parms.ContextString = ContextString;

	ProcessEvent(fn, &parms);
}

bool UDataTableFunctionLibrary::DoesDataTableRowExist(struct UDataTable* Table, struct FName RowName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataTableFunctionLibrary.DoesDataTableRowExist");

	FDoesDataTableRowExist parms{};	
	parms.Table = Table;
	parms.RowName = RowName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UWindDirectionalSourceComponent::SetWindType(uint8_t InNewType){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.WindDirectionalSourceComponent.SetWindType");

	FSetWindType parms{};	
	parms.InNewType = InNewType;

	ProcessEvent(fn, &parms);
}

void UWindDirectionalSourceComponent::SetStrength(float InNewStrength){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.WindDirectionalSourceComponent.SetStrength");

	FSetStrength parms{};	
	parms.InNewStrength = InNewStrength;

	ProcessEvent(fn, &parms);
}

void UWindDirectionalSourceComponent::SetSpeed(float InNewSpeed){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.WindDirectionalSourceComponent.SetSpeed");

	FSetSpeed parms{};	
	parms.InNewSpeed = InNewSpeed;

	ProcessEvent(fn, &parms);
}

void UWindDirectionalSourceComponent::SetRadius(float InNewRadius){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.WindDirectionalSourceComponent.SetRadius");

	FSetRadius parms{};	
	parms.InNewRadius = InNewRadius;

	ProcessEvent(fn, &parms);
}

void UWindDirectionalSourceComponent::SetMinimumGustAmount(float InNewMinGust){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.WindDirectionalSourceComponent.SetMinimumGustAmount");

	FSetMinimumGustAmount parms{};	
	parms.InNewMinGust = InNewMinGust;

	ProcessEvent(fn, &parms);
}

void UWindDirectionalSourceComponent::SetMaximumGustAmount(float InNewMaxGust){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.WindDirectionalSourceComponent.SetMaximumGustAmount");

	FSetMaximumGustAmount parms{};	
	parms.InNewMaxGust = InNewMaxGust;

	ProcessEvent(fn, &parms);
}

void APointLight::SetRadius(float NewRadius){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PointLight.SetRadius");

	FSetRadius parms{};	
	parms.NewRadius = NewRadius;

	ProcessEvent(fn, &parms);
}

void APointLight::SetLightFalloffExponent(float NewLightFalloffExponent){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PointLight.SetLightFalloffExponent");

	FSetLightFalloffExponent parms{};	
	parms.NewLightFalloffExponent = NewLightFalloffExponent;

	ProcessEvent(fn, &parms);
}

bool UPlatformEventsComponent::SupportsConvertibleLaptops(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlatformEventsComponent.SupportsConvertibleLaptops");

	FSupportsConvertibleLaptops parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UPlatformEventsComponent::PlatformEventDelegate__DelegateSignature(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("DelegateFunction Engine.PlatformEventsComponent.PlatformEventDelegate__DelegateSignature");

	FPlatformEventDelegate__DelegateSignature parms{};	

	ProcessEvent(fn, &parms);
}

bool UPlatformEventsComponent::IsInTabletMode(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlatformEventsComponent.IsInTabletMode");

	FIsInTabletMode parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UPlatformEventsComponent::IsInLaptopMode(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlatformEventsComponent.IsInLaptopMode");

	FIsInLaptopMode parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UWorldSubsystem* USubsystemBlueprintLibrary::GetWorldSubsystem(struct UObject* ContextObject, UWorldSubsystem* Class){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SubsystemBlueprintLibrary.GetWorldSubsystem");

	FGetWorldSubsystem parms{};	
	parms.ContextObject = ContextObject;
	parms.Class = Class;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct ULocalPlayerSubsystem* USubsystemBlueprintLibrary::GetLocalPlayerSubSystemFromPlayerController(struct APlayerController* PlayerController, ULocalPlayerSubsystem* Class){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SubsystemBlueprintLibrary.GetLocalPlayerSubSystemFromPlayerController");

	FGetLocalPlayerSubSystemFromPlayerController parms{};	
	parms.PlayerController = PlayerController;
	parms.Class = Class;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct ULocalPlayerSubsystem* USubsystemBlueprintLibrary::GetLocalPlayerSubsystem(struct UObject* ContextObject, ULocalPlayerSubsystem* Class){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SubsystemBlueprintLibrary.GetLocalPlayerSubsystem");

	FGetLocalPlayerSubsystem parms{};	
	parms.ContextObject = ContextObject;
	parms.Class = Class;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UGameInstanceSubsystem* USubsystemBlueprintLibrary::GetGameInstanceSubsystem(struct UObject* ContextObject, UGameInstanceSubsystem* Class){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SubsystemBlueprintLibrary.GetGameInstanceSubsystem");

	FGetGameInstanceSubsystem parms{};	
	parms.ContextObject = ContextObject;
	parms.Class = Class;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UEngineSubsystem* USubsystemBlueprintLibrary::GetEngineSubsystem(UEngineSubsystem* Class){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SubsystemBlueprintLibrary.GetEngineSubsystem");

	FGetEngineSubsystem parms{};	
	parms.Class = Class;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UAudioEngineSubsystem* USubsystemBlueprintLibrary::GetAudioEngineSubsystem(struct UObject* ContextObject, UAudioEngineSubsystem* Class){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SubsystemBlueprintLibrary.GetAudioEngineSubsystem");

	FGetAudioEngineSubsystem parms{};	
	parms.ContextObject = ContextObject;
	parms.Class = Class;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UVolumetricCloudComponent::SetViewSampleCountScale(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.VolumetricCloudComponent.SetViewSampleCountScale");

	FSetViewSampleCountScale parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UVolumetricCloudComponent::SetTracingStartMaxDistance(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.VolumetricCloudComponent.SetTracingStartMaxDistance");

	FSetTracingStartMaxDistance parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UVolumetricCloudComponent::SetTracingMaxDistance(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.VolumetricCloudComponent.SetTracingMaxDistance");

	FSetTracingMaxDistance parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UVolumetricCloudComponent::SetStopTracingTransmittanceThreshold(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.VolumetricCloudComponent.SetStopTracingTransmittanceThreshold");

	FSetStopTracingTransmittanceThreshold parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UVolumetricCloudComponent::SetSkyLightCloudBottomOcclusion(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.VolumetricCloudComponent.SetSkyLightCloudBottomOcclusion");

	FSetSkyLightCloudBottomOcclusion parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UVolumetricCloudComponent::SetShadowViewSampleCountScale(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.VolumetricCloudComponent.SetShadowViewSampleCountScale");

	FSetShadowViewSampleCountScale parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UVolumetricCloudComponent::SetShadowTracingDistance(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.VolumetricCloudComponent.SetShadowTracingDistance");

	FSetShadowTracingDistance parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UVolumetricCloudComponent::SetShadowReflectionViewSampleCountScale(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.VolumetricCloudComponent.SetShadowReflectionViewSampleCountScale");

	FSetShadowReflectionViewSampleCountScale parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UVolumetricCloudComponent::SetShadowReflectionSampleCountScale(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.VolumetricCloudComponent.SetShadowReflectionSampleCountScale");

	FSetShadowReflectionSampleCountScale parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UVolumetricCloudComponent::SetReflectionViewSampleCountScale(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.VolumetricCloudComponent.SetReflectionViewSampleCountScale");

	FSetReflectionViewSampleCountScale parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UVolumetricCloudComponent::SetReflectionSampleCountScale(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.VolumetricCloudComponent.SetReflectionSampleCountScale");

	FSetReflectionSampleCountScale parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UVolumetricCloudComponent::SetPlanetRadius(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.VolumetricCloudComponent.SetPlanetRadius");

	FSetPlanetRadius parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UVolumetricCloudComponent::SetMaterial(struct UMaterialInterface* NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.VolumetricCloudComponent.SetMaterial");

	FSetMaterial parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UVolumetricCloudComponent::SetLayerHeight(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.VolumetricCloudComponent.SetLayerHeight");

	FSetLayerHeight parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UVolumetricCloudComponent::SetLayerBottomAltitude(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.VolumetricCloudComponent.SetLayerBottomAltitude");

	FSetLayerBottomAltitude parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UVolumetricCloudComponent::SetGroundAlbedo(struct FColor NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.VolumetricCloudComponent.SetGroundAlbedo");

	FSetGroundAlbedo parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UVolumetricCloudComponent::SetbUsePerSampleAtmosphericLightTransmittance(bool NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.VolumetricCloudComponent.SetbUsePerSampleAtmosphericLightTransmittance");

	FSetbUsePerSampleAtmosphericLightTransmittance parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

struct TSet<int32_t> UBlueprintTypeConversions::ConvertSetType(struct TSet<int32_t>& InSet){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintTypeConversions.ConvertSetType");

	FConvertSetType parms{};	
	parms.InSet = InSet;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TMap<int32_t, int32_t> UBlueprintTypeConversions::ConvertMapType(struct TMap<int32_t, int32_t>& InMap){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintTypeConversions.ConvertMapType");

	FConvertMapType parms{};	
	parms.InMap = InMap;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UBlueprintTypeConversions::ConvertFVector4fToFVector4d(int32_t InFromData){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintTypeConversions.ConvertFVector4fToFVector4d");

	FConvertFVector4fToFVector4d parms{};	
	parms.InFromData = InFromData;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UBlueprintTypeConversions::ConvertFVector4dToFVector4f(int32_t InFromData){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintTypeConversions.ConvertFVector4dToFVector4f");

	FConvertFVector4dToFVector4f parms{};	
	parms.InFromData = InFromData;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UBlueprintTypeConversions::ConvertFVector3fToFVector3d(int32_t InFromData){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintTypeConversions.ConvertFVector3fToFVector3d");

	FConvertFVector3fToFVector3d parms{};	
	parms.InFromData = InFromData;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UBlueprintTypeConversions::ConvertFVector3dToFVector3f(int32_t InFromData){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintTypeConversions.ConvertFVector3dToFVector3f");

	FConvertFVector3dToFVector3f parms{};	
	parms.InFromData = InFromData;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UBlueprintTypeConversions::ConvertFVector2fToFVector2d(int32_t InFromData){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintTypeConversions.ConvertFVector2fToFVector2d");

	FConvertFVector2fToFVector2d parms{};	
	parms.InFromData = InFromData;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UBlueprintTypeConversions::ConvertFVector2dToFVector2f(int32_t InFromData){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintTypeConversions.ConvertFVector2dToFVector2f");

	FConvertFVector2dToFVector2f parms{};	
	parms.InFromData = InFromData;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UBlueprintTypeConversions::ConvertFTransform3fToFTransform3d(int32_t InFromData){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintTypeConversions.ConvertFTransform3fToFTransform3d");

	FConvertFTransform3fToFTransform3d parms{};	
	parms.InFromData = InFromData;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UBlueprintTypeConversions::ConvertFTransform3dToFTransform3f(int32_t InFromData){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintTypeConversions.ConvertFTransform3dToFTransform3f");

	FConvertFTransform3dToFTransform3f parms{};	
	parms.InFromData = InFromData;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UBlueprintTypeConversions::ConvertFRotator3fToFRotator3d(int32_t InFromData){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintTypeConversions.ConvertFRotator3fToFRotator3d");

	FConvertFRotator3fToFRotator3d parms{};	
	parms.InFromData = InFromData;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UBlueprintTypeConversions::ConvertFRotator3dToFRotator3f(int32_t InFromData){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintTypeConversions.ConvertFRotator3dToFRotator3f");

	FConvertFRotator3dToFRotator3f parms{};	
	parms.InFromData = InFromData;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UBlueprintTypeConversions::ConvertFQuat4fToFQuat4d(int32_t InFromData){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintTypeConversions.ConvertFQuat4fToFQuat4d");

	FConvertFQuat4fToFQuat4d parms{};	
	parms.InFromData = InFromData;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UBlueprintTypeConversions::ConvertFQuat4dToFQuat4f(int32_t InFromData){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintTypeConversions.ConvertFQuat4dToFQuat4f");

	FConvertFQuat4dToFQuat4f parms{};	
	parms.InFromData = InFromData;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UBlueprintTypeConversions::ConvertFPlane4fToFPlane4d(int32_t InFromData){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintTypeConversions.ConvertFPlane4fToFPlane4d");

	FConvertFPlane4fToFPlane4d parms{};	
	parms.InFromData = InFromData;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UBlueprintTypeConversions::ConvertFPlane4dToFPlane4f(int32_t InFromData){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintTypeConversions.ConvertFPlane4dToFPlane4f");

	FConvertFPlane4dToFPlane4f parms{};	
	parms.InFromData = InFromData;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UBlueprintTypeConversions::ConvertFMatrix44fToFMatrix44d(int32_t InFromData){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintTypeConversions.ConvertFMatrix44fToFMatrix44d");

	FConvertFMatrix44fToFMatrix44d parms{};	
	parms.InFromData = InFromData;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UBlueprintTypeConversions::ConvertFMatrix44dToFMatrix44f(int32_t InFromData){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintTypeConversions.ConvertFMatrix44dToFMatrix44f");

	FConvertFMatrix44dToFMatrix44f parms{};	
	parms.InFromData = InFromData;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UBlueprintTypeConversions::ConvertFBox2fToFBox2d(int32_t InFromData){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintTypeConversions.ConvertFBox2fToFBox2d");

	FConvertFBox2fToFBox2d parms{};	
	parms.InFromData = InFromData;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UBlueprintTypeConversions::ConvertFBox2dToFBox2f(int32_t InFromData){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintTypeConversions.ConvertFBox2dToFBox2f");

	FConvertFBox2dToFBox2f parms{};	
	parms.InFromData = InFromData;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<int32_t> UBlueprintTypeConversions::ConvertArrayType(struct TArray<int32_t>& inArray){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintTypeConversions.ConvertArrayType");

	FConvertArrayType parms{};	
	parms.inArray = inArray;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FActorInstanceHandle ULightWeightInstanceBlueprintFunctionLibrary::CreateNewLightWeightInstance(UObject* ActorClass, struct FTransform Transform, struct UDataLayerInstance* Layer, struct UWorld* World){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LightWeightInstanceBlueprintFunctionLibrary.CreateNewLightWeightInstance");

	FCreateNewLightWeightInstance parms{};	
	parms.ActorClass = ActorClass;
	parms.Transform = Transform;
	parms.Layer = Layer;
	parms.World = World;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FActorInstanceHandle ULightWeightInstanceBlueprintFunctionLibrary::ConvertActorToLightWeightInstance(struct AActor* Actor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LightWeightInstanceBlueprintFunctionLibrary.ConvertActorToLightWeightInstance");

	FConvertActorToLightWeightInstance parms{};	
	parms.Actor = Actor;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UAsyncActionChangePrimaryAssetBundles* UAsyncActionChangePrimaryAssetBundles::AsyncChangeBundleStateForPrimaryAssetList(struct UObject* WorldContextObject, struct TArray<struct FPrimaryAssetId>& PrimaryAssetList, struct TArray<struct FName>& AddBundles, struct TArray<struct FName>& RemoveBundles){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AsyncActionChangePrimaryAssetBundles.AsyncChangeBundleStateForPrimaryAssetList");

	FAsyncChangeBundleStateForPrimaryAssetList parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.PrimaryAssetList = PrimaryAssetList;
	parms.AddBundles = AddBundles;
	parms.RemoveBundles = RemoveBundles;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UAsyncActionChangePrimaryAssetBundles* UAsyncActionChangePrimaryAssetBundles::AsyncChangeBundleStateForMatchingPrimaryAssets(struct UObject* WorldContextObject, struct TArray<struct FName>& NewBundles, struct TArray<struct FName>& OldBundles){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AsyncActionChangePrimaryAssetBundles.AsyncChangeBundleStateForMatchingPrimaryAssets");

	FAsyncChangeBundleStateForMatchingPrimaryAssets parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.NewBundles = NewBundles;
	parms.OldBundles = OldBundles;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetNodeHelperLibrary::MarkBit(int32_t& Data, int32_t Index){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.MarkBit");

	FMarkBit parms{};	
	parms.Data = Data;
	parms.Index = Index;

	ProcessEvent(fn, &parms);
}

bool UKismetNodeHelperLibrary::HasUnmarkedBit(int32_t Data, int32_t NumBits){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.HasUnmarkedBit");

	FHasUnmarkedBit parms{};	
	parms.Data = Data;
	parms.NumBits = NumBits;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetNodeHelperLibrary::HasMarkedBit(int32_t Data, int32_t NumBits){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.HasMarkedBit");

	FHasMarkedBit parms{};	
	parms.Data = Data;
	parms.NumBits = NumBits;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

char UKismetNodeHelperLibrary::GetValidValue(struct UEnum* Enum, char EnumeratorValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.GetValidValue");

	FGetValidValue parms{};	
	parms.Enum = Enum;
	parms.EnumeratorValue = EnumeratorValue;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetNodeHelperLibrary::GetUnmarkedBit(int32_t Data, int32_t StartIdx, int32_t NumBits, bool bRandom){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.GetUnmarkedBit");

	FGetUnmarkedBit parms{};	
	parms.Data = Data;
	parms.StartIdx = StartIdx;
	parms.NumBits = NumBits;
	parms.bRandom = bRandom;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetNodeHelperLibrary::GetRandomUnmarkedBit(int32_t Data, int32_t StartIdx, int32_t NumBits){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.GetRandomUnmarkedBit");

	FGetRandomUnmarkedBit parms{};	
	parms.Data = Data;
	parms.StartIdx = StartIdx;
	parms.NumBits = NumBits;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetNodeHelperLibrary::GetFirstUnmarkedBit(int32_t Data, int32_t StartIdx, int32_t NumBits){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.GetFirstUnmarkedBit");

	FGetFirstUnmarkedBit parms{};	
	parms.Data = Data;
	parms.StartIdx = StartIdx;
	parms.NumBits = NumBits;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

char UKismetNodeHelperLibrary::GetEnumeratorValueFromIndex(struct UEnum* Enum, char EnumeratorIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.GetEnumeratorValueFromIndex");

	FGetEnumeratorValueFromIndex parms{};	
	parms.Enum = Enum;
	parms.EnumeratorIndex = EnumeratorIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetNodeHelperLibrary::GetEnumeratorUserFriendlyName(struct UEnum* Enum, char EnumeratorValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.GetEnumeratorUserFriendlyName");

	FGetEnumeratorUserFriendlyName parms{};	
	parms.Enum = Enum;
	parms.EnumeratorValue = EnumeratorValue;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FName UKismetNodeHelperLibrary::GetEnumeratorName(struct UEnum* Enum, char EnumeratorValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.GetEnumeratorName");

	FGetEnumeratorName parms{};	
	parms.Enum = Enum;
	parms.EnumeratorValue = EnumeratorValue;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetNodeHelperLibrary::ClearBit(int32_t& Data, int32_t Index){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.ClearBit");

	FClearBit parms{};	
	parms.Data = Data;
	parms.Index = Index;

	ProcessEvent(fn, &parms);
}

void UKismetNodeHelperLibrary::ClearAllBits(int32_t& Data){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.ClearAllBits");

	FClearAllBits parms{};	
	parms.Data = Data;

	ProcessEvent(fn, &parms);
}

bool UKismetNodeHelperLibrary::BitIsMarked(int32_t Data, int32_t Index){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.BitIsMarked");

	FBitIsMarked parms{};	
	parms.Data = Data;
	parms.Index = Index;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimationAttributeIdentifierExtensions::IsValid(struct FAnimationAttributeIdentifier& Identifier){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimationAttributeIdentifierExtensions.IsValid");

	FIsValid parms{};	
	parms.Identifier = Identifier;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UParticleSystemComponent::SetTrailSourceData(struct FName InFirstSocketName, struct FName InSecondSocketName, enum class ETrailWidthMode InWidthMode, float InWidth){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetTrailSourceData");

	FSetTrailSourceData parms{};	
	parms.InFirstSocketName = InFirstSocketName;
	parms.InSecondSocketName = InSecondSocketName;
	parms.InWidthMode = InWidthMode;
	parms.InWidth = InWidth;

	ProcessEvent(fn, &parms);
}

void UParticleSystemComponent::SetTemplate(struct UParticleSystem* NewTemplate){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetTemplate");

	FSetTemplate parms{};	
	parms.NewTemplate = NewTemplate;

	ProcessEvent(fn, &parms);
}

void UParticleSystemComponent::SetMaterialParameter(struct FName ParameterName, struct UMaterialInterface* Param){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetMaterialParameter");

	FSetMaterialParameter parms{};	
	parms.ParameterName = ParameterName;
	parms.Param = Param;

	ProcessEvent(fn, &parms);
}

void UParticleSystemComponent::SetBeamTargetTangent(int32_t EmitterIndex, struct FVector NewTangentPoint, int32_t TargetIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetBeamTargetTangent");

	FSetBeamTargetTangent parms{};	
	parms.EmitterIndex = EmitterIndex;
	parms.NewTangentPoint = NewTangentPoint;
	parms.TargetIndex = TargetIndex;

	ProcessEvent(fn, &parms);
}

void UParticleSystemComponent::SetBeamTargetStrength(int32_t EmitterIndex, float NewTargetStrength, int32_t TargetIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetBeamTargetStrength");

	FSetBeamTargetStrength parms{};	
	parms.EmitterIndex = EmitterIndex;
	parms.NewTargetStrength = NewTargetStrength;
	parms.TargetIndex = TargetIndex;

	ProcessEvent(fn, &parms);
}

void UParticleSystemComponent::SetBeamTargetPoint(int32_t EmitterIndex, struct FVector NewTargetPoint, int32_t TargetIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetBeamTargetPoint");

	FSetBeamTargetPoint parms{};	
	parms.EmitterIndex = EmitterIndex;
	parms.NewTargetPoint = NewTargetPoint;
	parms.TargetIndex = TargetIndex;

	ProcessEvent(fn, &parms);
}

void UParticleSystemComponent::SetBeamSourceTangent(int32_t EmitterIndex, struct FVector NewTangentPoint, int32_t SourceIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetBeamSourceTangent");

	FSetBeamSourceTangent parms{};	
	parms.EmitterIndex = EmitterIndex;
	parms.NewTangentPoint = NewTangentPoint;
	parms.SourceIndex = SourceIndex;

	ProcessEvent(fn, &parms);
}

void UParticleSystemComponent::SetBeamSourceStrength(int32_t EmitterIndex, float NewSourceStrength, int32_t SourceIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetBeamSourceStrength");

	FSetBeamSourceStrength parms{};	
	parms.EmitterIndex = EmitterIndex;
	parms.NewSourceStrength = NewSourceStrength;
	parms.SourceIndex = SourceIndex;

	ProcessEvent(fn, &parms);
}

void UParticleSystemComponent::SetBeamSourcePoint(int32_t EmitterIndex, struct FVector NewSourcePoint, int32_t SourceIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetBeamSourcePoint");

	FSetBeamSourcePoint parms{};	
	parms.EmitterIndex = EmitterIndex;
	parms.NewSourcePoint = NewSourcePoint;
	parms.SourceIndex = SourceIndex;

	ProcessEvent(fn, &parms);
}

void UParticleSystemComponent::SetBeamEndPoint(int32_t EmitterIndex, struct FVector NewEndPoint){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetBeamEndPoint");

	FSetBeamEndPoint parms{};	
	parms.EmitterIndex = EmitterIndex;
	parms.NewEndPoint = NewEndPoint;

	ProcessEvent(fn, &parms);
}

void UParticleSystemComponent::SetAutoAttachParams(struct USceneComponent* Parent, struct FName SocketName, enum class EAttachLocation LocationType){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetAutoAttachParams");

	FSetAutoAttachParams parms{};	
	parms.Parent = Parent;
	parms.SocketName = SocketName;
	parms.LocationType = LocationType;

	ProcessEvent(fn, &parms);
}

int32_t UParticleSystemComponent::GetNumActiveParticles(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GetNumActiveParticles");

	FGetNumActiveParticles parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UMaterialInterface* UParticleSystemComponent::GetNamedMaterial(struct FName InName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GetNamedMaterial");

	FGetNamedMaterial parms{};	
	parms.InName = InName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UParticleSystemComponent::GetBeamTargetTangent(int32_t EmitterIndex, int32_t TargetIndex, struct FVector& OutTangentPoint){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GetBeamTargetTangent");

	FGetBeamTargetTangent parms{};	
	parms.EmitterIndex = EmitterIndex;
	parms.TargetIndex = TargetIndex;
	parms.OutTangentPoint = OutTangentPoint;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UParticleSystemComponent::GetBeamTargetStrength(int32_t EmitterIndex, int32_t TargetIndex, float& OutTargetStrength){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GetBeamTargetStrength");

	FGetBeamTargetStrength parms{};	
	parms.EmitterIndex = EmitterIndex;
	parms.TargetIndex = TargetIndex;
	parms.OutTargetStrength = OutTargetStrength;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UParticleSystemComponent::GetBeamTargetPoint(int32_t EmitterIndex, int32_t TargetIndex, struct FVector& OutTargetPoint){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GetBeamTargetPoint");

	FGetBeamTargetPoint parms{};	
	parms.EmitterIndex = EmitterIndex;
	parms.TargetIndex = TargetIndex;
	parms.OutTargetPoint = OutTargetPoint;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UParticleSystemComponent::GetBeamSourceTangent(int32_t EmitterIndex, int32_t SourceIndex, struct FVector& OutTangentPoint){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GetBeamSourceTangent");

	FGetBeamSourceTangent parms{};	
	parms.EmitterIndex = EmitterIndex;
	parms.SourceIndex = SourceIndex;
	parms.OutTangentPoint = OutTangentPoint;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UParticleSystemComponent::GetBeamSourceStrength(int32_t EmitterIndex, int32_t SourceIndex, float& OutSourceStrength){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GetBeamSourceStrength");

	FGetBeamSourceStrength parms{};	
	parms.EmitterIndex = EmitterIndex;
	parms.SourceIndex = SourceIndex;
	parms.OutSourceStrength = OutSourceStrength;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UParticleSystemComponent::GetBeamSourcePoint(int32_t EmitterIndex, int32_t SourceIndex, struct FVector& OutSourcePoint){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GetBeamSourcePoint");

	FGetBeamSourcePoint parms{};	
	parms.EmitterIndex = EmitterIndex;
	parms.SourceIndex = SourceIndex;
	parms.OutSourcePoint = OutSourcePoint;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UParticleSystemComponent::GetBeamEndPoint(int32_t EmitterIndex, struct FVector& OutEndPoint){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GetBeamEndPoint");

	FGetBeamEndPoint parms{};	
	parms.EmitterIndex = EmitterIndex;
	parms.OutEndPoint = OutEndPoint;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UParticleSystemComponent::GenerateParticleEvent(struct FName InEventName, float InEmitterTime, struct FVector InLocation, struct FVector InDirection, struct FVector InVelocity){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GenerateParticleEvent");

	FGenerateParticleEvent parms{};	
	parms.InEventName = InEventName;
	parms.InEmitterTime = InEmitterTime;
	parms.InLocation = InLocation;
	parms.InDirection = InDirection;
	parms.InVelocity = InVelocity;

	ProcessEvent(fn, &parms);
}

void UParticleSystemComponent::EndTrails(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.EndTrails");

	FEndTrails parms{};	

	ProcessEvent(fn, &parms);
}

struct UMaterialInstanceDynamic* UParticleSystemComponent::CreateNamedDynamicMaterialInstance(struct FName InName, struct UMaterialInterface* SourceMaterial){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.CreateNamedDynamicMaterialInstance");

	FCreateNamedDynamicMaterialInstance parms{};	
	parms.InName = InName;
	parms.SourceMaterial = SourceMaterial;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UParticleSystemComponent::BeginTrails(struct FName InFirstSocketName, struct FName InSecondSocketName, enum class ETrailWidthMode InWidthMode, float InWidth){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.BeginTrails");

	FBeginTrails parms{};	
	parms.InFirstSocketName = InFirstSocketName;
	parms.InSecondSocketName = InSecondSocketName;
	parms.InWidthMode = InWidthMode;
	parms.InWidth = InWidth;

	ProcessEvent(fn, &parms);
}

struct FVector UPhysicsSpringComponent::GetSpringRestingPoint(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsSpringComponent.GetSpringRestingPoint");

	FGetSpringRestingPoint parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UPhysicsSpringComponent::GetSpringDirection(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsSpringComponent.GetSpringDirection");

	FGetSpringDirection parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UPhysicsSpringComponent::GetSpringCurrentEndPoint(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsSpringComponent.GetSpringCurrentEndPoint");

	FGetSpringCurrentEndPoint parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UPhysicsSpringComponent::GetNormalizedCompressionScalar(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsSpringComponent.GetNormalizedCompressionScalar");

	FGetNormalizedCompressionScalar parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UPhysicsThreadLibrary::AddForce(struct FBodyInstanceAsyncPhysicsTickHandle Handle, struct FVector Force, bool bAccelChange){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsThreadLibrary.AddForce");

	FAddForce parms{};	
	parms.Handle = Handle;
	parms.Force = Force;
	parms.bAccelChange = bAccelChange;

	ProcessEvent(fn, &parms);
}

void ARadialForceActor::ToggleForce(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.RadialForceActor.ToggleForce");

	FToggleForce parms{};	

	ProcessEvent(fn, &parms);
}

void ARadialForceActor::FireImpulse(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.RadialForceActor.FireImpulse");

	FFireImpulse parms{};	

	ProcessEvent(fn, &parms);
}

void ARadialForceActor::EnableForce(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.RadialForceActor.EnableForce");

	FEnableForce parms{};	

	ProcessEvent(fn, &parms);
}

void ARadialForceActor::DisableForce(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.RadialForceActor.DisableForce");

	FDisableForce parms{};	

	ProcessEvent(fn, &parms);
}

void ASceneCapture2D::OnInterpToggle(bool bEnable){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneCapture2D.OnInterpToggle");

	FOnInterpToggle parms{};	
	parms.bEnable = bEnable;

	ProcessEvent(fn, &parms);
}

void ASceneCaptureCube::OnInterpToggle(bool bEnable){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SceneCaptureCube.OnInterpToggle");

	FOnInterpToggle parms{};	
	parms.bEnable = bEnable;

	ProcessEvent(fn, &parms);
}

void USkeletalMeshSocket::InitializeSocketFromLocation(struct USkeletalMeshComponent* SkelComp, struct FVector WorldLocation, struct FVector WorldNormal){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshSocket.InitializeSocketFromLocation");

	FInitializeSocketFromLocation parms{};	
	parms.SkelComp = SkelComp;
	parms.WorldLocation = WorldLocation;
	parms.WorldNormal = WorldNormal;

	ProcessEvent(fn, &parms);
}

struct FVector USkeletalMeshSocket::GetSocketLocation(struct USkeletalMeshComponent* SkelComp){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshSocket.GetSocketLocation");

	FGetSocketLocation parms{};	
	parms.SkelComp = SkelComp;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct USkeletalMeshSocket* USkinnedAsset::FindSocketInfo(struct FName InSocketName, struct FTransform& OutTransform, int32_t& OutBoneIndex, int32_t& OutIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedAsset.FindSocketInfo");

	FFindSocketInfo parms{};	
	parms.InSocketName = InSocketName;
	parms.OutTransform = OutTransform;
	parms.OutBoneIndex = OutBoneIndex;
	parms.OutIndex = OutIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct USkeletalMeshSocket* USkinnedAsset::FindSocket(struct FName InSocketName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkinnedAsset.FindSocket");

	FFindSocket parms{};	
	parms.InSocketName = InSocketName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UPhysicsConstraintComponent::SetOrientationDriveTwistAndSwing(bool bEnableTwistDrive, bool bEnableSwingDrive){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetOrientationDriveTwistAndSwing");

	FSetOrientationDriveTwistAndSwing parms{};	
	parms.bEnableTwistDrive = bEnableTwistDrive;
	parms.bEnableSwingDrive = bEnableSwingDrive;

	ProcessEvent(fn, &parms);
}

void UPhysicsConstraintComponent::SetOrientationDriveSLERP(bool bEnableSLERP){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetOrientationDriveSLERP");

	FSetOrientationDriveSLERP parms{};	
	parms.bEnableSLERP = bEnableSLERP;

	ProcessEvent(fn, &parms);
}

void UPhysicsConstraintComponent::SetLinearZLimit(enum class ELinearConstraintMotion ConstraintType, float LimitSize){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearZLimit");

	FSetLinearZLimit parms{};	
	parms.ConstraintType = ConstraintType;
	parms.LimitSize = LimitSize;

	ProcessEvent(fn, &parms);
}

void UPhysicsConstraintComponent::SetLinearYLimit(enum class ELinearConstraintMotion ConstraintType, float LimitSize){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearYLimit");

	FSetLinearYLimit parms{};	
	parms.ConstraintType = ConstraintType;
	parms.LimitSize = LimitSize;

	ProcessEvent(fn, &parms);
}

void UPhysicsConstraintComponent::SetLinearXLimit(enum class ELinearConstraintMotion ConstraintType, float LimitSize){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearXLimit");

	FSetLinearXLimit parms{};	
	parms.ConstraintType = ConstraintType;
	parms.LimitSize = LimitSize;

	ProcessEvent(fn, &parms);
}

void UPhysicsConstraintComponent::SetLinearVelocityTarget(struct FVector& InVelTarget){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearVelocityTarget");

	FSetLinearVelocityTarget parms{};	
	parms.InVelTarget = InVelTarget;

	ProcessEvent(fn, &parms);
}

void UPhysicsConstraintComponent::SetLinearVelocityDrive(bool bEnableDriveX, bool bEnableDriveY, bool bEnableDriveZ){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearVelocityDrive");

	FSetLinearVelocityDrive parms{};	
	parms.bEnableDriveX = bEnableDriveX;
	parms.bEnableDriveY = bEnableDriveY;
	parms.bEnableDriveZ = bEnableDriveZ;

	ProcessEvent(fn, &parms);
}

void UPhysicsConstraintComponent::SetLinearPositionTarget(struct FVector& InPosTarget){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearPositionTarget");

	FSetLinearPositionTarget parms{};	
	parms.InPosTarget = InPosTarget;

	ProcessEvent(fn, &parms);
}

void UPhysicsConstraintComponent::SetLinearPositionDrive(bool bEnableDriveX, bool bEnableDriveY, bool bEnableDriveZ){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearPositionDrive");

	FSetLinearPositionDrive parms{};	
	parms.bEnableDriveX = bEnableDriveX;
	parms.bEnableDriveY = bEnableDriveY;
	parms.bEnableDriveZ = bEnableDriveZ;

	ProcessEvent(fn, &parms);
}

void UPhysicsConstraintComponent::SetLinearPlasticity(bool bLinearPlasticity, float LinearPlasticityThreshold, enum class EConstraintPlasticityType PlasticityType){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearPlasticity");

	FSetLinearPlasticity parms{};	
	parms.bLinearPlasticity = bLinearPlasticity;
	parms.LinearPlasticityThreshold = LinearPlasticityThreshold;
	parms.PlasticityType = PlasticityType;

	ProcessEvent(fn, &parms);
}

void UPhysicsConstraintComponent::SetLinearDriveParams(float PositionStrength, float VelocityStrength, float InForceLimit){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearDriveParams");

	FSetLinearDriveParams parms{};	
	parms.PositionStrength = PositionStrength;
	parms.VelocityStrength = VelocityStrength;
	parms.InForceLimit = InForceLimit;

	ProcessEvent(fn, &parms);
}

void UPhysicsConstraintComponent::SetLinearBreakable(bool bLinearBreakable, float LinearBreakThreshold){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearBreakable");

	FSetLinearBreakable parms{};	
	parms.bLinearBreakable = bLinearBreakable;
	parms.LinearBreakThreshold = LinearBreakThreshold;

	ProcessEvent(fn, &parms);
}

void UPhysicsConstraintComponent::SetDisableCollision(bool bDisableCollision){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetDisableCollision");

	FSetDisableCollision parms{};	
	parms.bDisableCollision = bDisableCollision;

	ProcessEvent(fn, &parms);
}

void UPhysicsConstraintComponent::SetContactTransferScale(float ContactTransferScale){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetContactTransferScale");

	FSetContactTransferScale parms{};	
	parms.ContactTransferScale = ContactTransferScale;

	ProcessEvent(fn, &parms);
}

void UPhysicsConstraintComponent::SetConstraintReferencePosition(enum class EConstraintFrame Frame, struct FVector& RefPosition){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetConstraintReferencePosition");

	FSetConstraintReferencePosition parms{};	
	parms.Frame = Frame;
	parms.RefPosition = RefPosition;

	ProcessEvent(fn, &parms);
}

void UPhysicsConstraintComponent::SetConstraintReferenceOrientation(enum class EConstraintFrame Frame, struct FVector& PriAxis, struct FVector& SecAxis){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetConstraintReferenceOrientation");

	FSetConstraintReferenceOrientation parms{};	
	parms.Frame = Frame;
	parms.PriAxis = PriAxis;
	parms.SecAxis = SecAxis;

	ProcessEvent(fn, &parms);
}

void UPhysicsConstraintComponent::SetConstraintReferenceFrame(enum class EConstraintFrame Frame, struct FTransform& RefFrame){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetConstraintReferenceFrame");

	FSetConstraintReferenceFrame parms{};	
	parms.Frame = Frame;
	parms.RefFrame = RefFrame;

	ProcessEvent(fn, &parms);
}

void UPhysicsConstraintComponent::SetConstrainedComponents(struct UPrimitiveComponent* Component1, struct FName BoneName1, struct UPrimitiveComponent* Component2, struct FName BoneName2){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetConstrainedComponents");

	FSetConstrainedComponents parms{};	
	parms.Component1 = Component1;
	parms.BoneName1 = BoneName1;
	parms.Component2 = Component2;
	parms.BoneName2 = BoneName2;

	ProcessEvent(fn, &parms);
}

void UPhysicsConstraintComponent::SetAngularVelocityTarget(struct FVector& InVelTarget){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularVelocityTarget");

	FSetAngularVelocityTarget parms{};	
	parms.InVelTarget = InVelTarget;

	ProcessEvent(fn, &parms);
}

void UPhysicsConstraintComponent::SetAngularVelocityDriveTwistAndSwing(bool bEnableTwistDrive, bool bEnableSwingDrive){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularVelocityDriveTwistAndSwing");

	FSetAngularVelocityDriveTwistAndSwing parms{};	
	parms.bEnableTwistDrive = bEnableTwistDrive;
	parms.bEnableSwingDrive = bEnableSwingDrive;

	ProcessEvent(fn, &parms);
}

void UPhysicsConstraintComponent::SetAngularVelocityDriveSLERP(bool bEnableSLERP){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularVelocityDriveSLERP");

	FSetAngularVelocityDriveSLERP parms{};	
	parms.bEnableSLERP = bEnableSLERP;

	ProcessEvent(fn, &parms);
}

void UPhysicsConstraintComponent::SetAngularVelocityDrive(bool bEnableSwingDrive, bool bEnableTwistDrive){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularVelocityDrive");

	FSetAngularVelocityDrive parms{};	
	parms.bEnableSwingDrive = bEnableSwingDrive;
	parms.bEnableTwistDrive = bEnableTwistDrive;

	ProcessEvent(fn, &parms);
}

void UPhysicsConstraintComponent::SetAngularTwistLimit(enum class EAngularConstraintMotion ConstraintType, float TwistLimitAngle){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularTwistLimit");

	FSetAngularTwistLimit parms{};	
	parms.ConstraintType = ConstraintType;
	parms.TwistLimitAngle = TwistLimitAngle;

	ProcessEvent(fn, &parms);
}

void UPhysicsConstraintComponent::SetAngularSwing2Limit(enum class EAngularConstraintMotion MotionType, float Swing2LimitAngle){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularSwing2Limit");

	FSetAngularSwing2Limit parms{};	
	parms.MotionType = MotionType;
	parms.Swing2LimitAngle = Swing2LimitAngle;

	ProcessEvent(fn, &parms);
}

void UPhysicsConstraintComponent::SetAngularSwing1Limit(enum class EAngularConstraintMotion MotionType, float Swing1LimitAngle){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularSwing1Limit");

	FSetAngularSwing1Limit parms{};	
	parms.MotionType = MotionType;
	parms.Swing1LimitAngle = Swing1LimitAngle;

	ProcessEvent(fn, &parms);
}

void UPhysicsConstraintComponent::SetAngularPlasticity(bool bAngularPlasticity, float AngularPlasticityThreshold){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularPlasticity");

	FSetAngularPlasticity parms{};	
	parms.bAngularPlasticity = bAngularPlasticity;
	parms.AngularPlasticityThreshold = AngularPlasticityThreshold;

	ProcessEvent(fn, &parms);
}

void UPhysicsConstraintComponent::SetAngularOrientationTarget(struct FRotator& InPosTarget){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularOrientationTarget");

	FSetAngularOrientationTarget parms{};	
	parms.InPosTarget = InPosTarget;

	ProcessEvent(fn, &parms);
}

void UPhysicsConstraintComponent::SetAngularOrientationDrive(bool bEnableSwingDrive, bool bEnableTwistDrive){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularOrientationDrive");

	FSetAngularOrientationDrive parms{};	
	parms.bEnableSwingDrive = bEnableSwingDrive;
	parms.bEnableTwistDrive = bEnableTwistDrive;

	ProcessEvent(fn, &parms);
}

void UPhysicsConstraintComponent::SetAngularDriveParams(float PositionStrength, float VelocityStrength, float InForceLimit){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularDriveParams");

	FSetAngularDriveParams parms{};	
	parms.PositionStrength = PositionStrength;
	parms.VelocityStrength = VelocityStrength;
	parms.InForceLimit = InForceLimit;

	ProcessEvent(fn, &parms);
}

void UPhysicsConstraintComponent::SetAngularDriveMode(enum class EAngularDriveMode DriveMode){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularDriveMode");

	FSetAngularDriveMode parms{};	
	parms.DriveMode = DriveMode;

	ProcessEvent(fn, &parms);
}

void UPhysicsConstraintComponent::SetAngularBreakable(bool bAngularBreakable, float AngularBreakThreshold){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularBreakable");

	FSetAngularBreakable parms{};	
	parms.bAngularBreakable = bAngularBreakable;
	parms.AngularBreakThreshold = AngularBreakThreshold;

	ProcessEvent(fn, &parms);
}

bool UPhysicsConstraintComponent::IsBroken(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.IsBroken");

	FIsBroken parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UPhysicsConstraintComponent::GetCurrentTwist(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.GetCurrentTwist");

	FGetCurrentTwist parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UPhysicsConstraintComponent::GetCurrentSwing2(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.GetCurrentSwing2");

	FGetCurrentSwing2 parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UPhysicsConstraintComponent::GetCurrentSwing1(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.GetCurrentSwing1");

	FGetCurrentSwing1 parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UPhysicsConstraintComponent::GetConstraintForce(struct FVector& OutLinearForce, struct FVector& OutAngularForce){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.GetConstraintForce");

	FGetConstraintForce parms{};	
	parms.OutLinearForce = OutLinearForce;
	parms.OutAngularForce = OutAngularForce;

	ProcessEvent(fn, &parms);
}

struct FConstraintInstanceAccessor UPhysicsConstraintComponent::GetConstraint(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.GetConstraint");

	FGetConstraint parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UPhysicsConstraintComponent::GetConstrainedComponents(struct UPrimitiveComponent*& OutComponent1, struct FName& OutBoneName1, struct UPrimitiveComponent*& OutComponent2, struct FName& OutBoneName2){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.GetConstrainedComponents");

	FGetConstrainedComponents parms{};	
	parms.OutComponent1 = OutComponent1;
	parms.OutBoneName1 = OutBoneName1;
	parms.OutComponent2 = OutComponent2;
	parms.OutBoneName2 = OutBoneName2;

	ProcessEvent(fn, &parms);
}

void UPhysicsConstraintComponent::BreakConstraint(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.BreakConstraint");

	FBreakConstraint parms{};	

	ProcessEvent(fn, &parms);
}

void USoundSubmixWidgetInterface::OnConstructed(struct USoundSubmixBase* SoundSubmix){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SoundSubmixWidgetInterface.OnConstructed");

	FOnConstructed parms{};	
	parms.SoundSubmix = SoundSubmix;

	ProcessEvent(fn, &parms);
}

void UStaticMesh::SetStaticMaterials(struct TArray<struct FStaticMaterial>& InStaticMaterials){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StaticMesh.SetStaticMaterials");

	FSetStaticMaterials parms{};	
	parms.InStaticMaterials = InStaticMaterials;

	ProcessEvent(fn, &parms);
}

void UStaticMesh::SetMinLODForQualityLevels(struct TMap<uint8_t, int32_t>& QualityLevelMinimumLODs, int32_t Default){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StaticMesh.SetMinLODForQualityLevels");

	FSetMinLODForQualityLevels parms{};	
	parms.QualityLevelMinimumLODs = QualityLevelMinimumLODs;
	parms.Default = Default;

	ProcessEvent(fn, &parms);
}

void UStaticMesh::SetMinimumLODForPlatforms(struct TMap<struct FName, int32_t>& PlatformMinimumLODs){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StaticMesh.SetMinimumLODForPlatforms");

	FSetMinimumLODForPlatforms parms{};	
	parms.PlatformMinimumLODs = PlatformMinimumLODs;

	ProcessEvent(fn, &parms);
}

void UStaticMesh::SetMinimumLODForPlatform(struct FName& PlatformName, int32_t InMinLOD){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StaticMesh.SetMinimumLODForPlatform");

	FSetMinimumLODForPlatform parms{};	
	parms.PlatformName = PlatformName;
	parms.InMinLOD = InMinLOD;

	ProcessEvent(fn, &parms);
}

void UStaticMesh::RemoveSocket(struct UStaticMeshSocket* Socket){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StaticMesh.RemoveSocket");

	FRemoveSocket parms{};	
	parms.Socket = Socket;

	ProcessEvent(fn, &parms);
}

struct UStaticMeshDescription* UStaticMesh::GetStaticMeshDescription(int32_t LODIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StaticMesh.GetStaticMeshDescription");

	FGetStaticMeshDescription parms{};	
	parms.LODIndex = LODIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<struct FStaticMaterial> UStaticMesh::GetStaticMaterials(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StaticMesh.GetStaticMaterials");

	FGetStaticMaterials parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<struct UStaticMeshSocket*> UStaticMesh::GetSocketsByTag(struct FString InSocketTag){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StaticMesh.GetSocketsByTag");

	FGetSocketsByTag parms{};	
	parms.InSocketTag = InSocketTag;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UStaticMesh::GetNumTriangles(int32_t LODIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StaticMesh.GetNumTriangles");

	FGetNumTriangles parms{};	
	parms.LODIndex = LODIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UStaticMesh::GetNumSections(int32_t InLOD){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StaticMesh.GetNumSections");

	FGetNumSections parms{};	
	parms.InLOD = InLOD;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UStaticMesh::GetNumLODs(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StaticMesh.GetNumLODs");

	FGetNumLODs parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UStaticMesh::GetMinLODForQualityLevels(struct TMap<uint8_t, int32_t>& QualityLevelMinimumLODs, int32_t& Default){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StaticMesh.GetMinLODForQualityLevels");

	FGetMinLODForQualityLevels parms{};	
	parms.QualityLevelMinimumLODs = QualityLevelMinimumLODs;
	parms.Default = Default;

	ProcessEvent(fn, &parms);
}

void UStaticMesh::GetMinimumLODForQualityLevels(struct TMap<struct FName, int32_t>& QualityLevelMinimumLODs){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StaticMesh.GetMinimumLODForQualityLevels");

	FGetMinimumLODForQualityLevels parms{};	
	parms.QualityLevelMinimumLODs = QualityLevelMinimumLODs;

	ProcessEvent(fn, &parms);
}

int32_t UStaticMesh::GetMinimumLODForQualityLevel(struct FName& QualityLevel){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StaticMesh.GetMinimumLODForQualityLevel");

	FGetMinimumLODForQualityLevel parms{};	
	parms.QualityLevel = QualityLevel;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UStaticMesh::GetMinimumLODForPlatforms(struct TMap<struct FName, int32_t>& PlatformMinimumLODs){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StaticMesh.GetMinimumLODForPlatforms");

	FGetMinimumLODForPlatforms parms{};	
	parms.PlatformMinimumLODs = PlatformMinimumLODs;

	ProcessEvent(fn, &parms);
}

int32_t UStaticMesh::GetMinimumLODForPlatform(struct FName& PlatformName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StaticMesh.GetMinimumLODForPlatform");

	FGetMinimumLODForPlatform parms{};	
	parms.PlatformName = PlatformName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UStaticMesh::GetMaterialIndex(struct FName MaterialSlotName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StaticMesh.GetMaterialIndex");

	FGetMaterialIndex parms{};	
	parms.MaterialSlotName = MaterialSlotName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UMaterialInterface* UStaticMesh::GetMaterial(int32_t MaterialIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StaticMesh.GetMaterial");

	FGetMaterial parms{};	
	parms.MaterialIndex = MaterialIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FBoxSphereBounds UStaticMesh::GetBounds(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StaticMesh.GetBounds");

	FGetBounds parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FBox UStaticMesh::GetBoundingBox(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StaticMesh.GetBoundingBox");

	FGetBoundingBox parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UStaticMeshSocket* UStaticMesh::FindSocket(struct FName InSocketName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StaticMesh.FindSocket");

	FFindSocket parms{};	
	parms.InSocketName = InSocketName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UStaticMeshDescription* UStaticMesh::CreateStaticMeshDescription(struct UObject* Outer){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StaticMesh.CreateStaticMeshDescription");

	FCreateStaticMeshDescription parms{};	
	parms.Outer = Outer;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UStaticMesh::BuildFromStaticMeshDescriptions(struct TArray<struct UStaticMeshDescription*>& StaticMeshDescriptions, bool bBuildSimpleCollision, bool bFastBuild){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StaticMesh.BuildFromStaticMeshDescriptions");

	FBuildFromStaticMeshDescriptions parms{};	
	parms.StaticMeshDescriptions = StaticMeshDescriptions;
	parms.bBuildSimpleCollision = bBuildSimpleCollision;
	parms.bFastBuild = bFastBuild;

	ProcessEvent(fn, &parms);
}

void UStaticMesh::AddSocket(struct UStaticMeshSocket* Socket){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StaticMesh.AddSocket");

	FAddSocket parms{};	
	parms.Socket = Socket;

	ProcessEvent(fn, &parms);
}

struct FName UStaticMesh::AddMaterial(struct UMaterialInterface* Material){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StaticMesh.AddMaterial");

	FAddMaterial parms{};	
	parms.Material = Material;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UStereoLayerShapeCylinder::SetRadius(float InRadius){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StereoLayerShapeCylinder.SetRadius");

	FSetRadius parms{};	
	parms.InRadius = InRadius;

	ProcessEvent(fn, &parms);
}

void UStereoLayerShapeCylinder::SetOverlayArc(float InOverlayArc){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StereoLayerShapeCylinder.SetOverlayArc");

	FSetOverlayArc parms{};	
	parms.InOverlayArc = InOverlayArc;

	ProcessEvent(fn, &parms);
}

void UStereoLayerShapeCylinder::SetHeight(int32_t InHeight){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StereoLayerShapeCylinder.SetHeight");

	FSetHeight parms{};	
	parms.InHeight = InHeight;

	ProcessEvent(fn, &parms);
}

void UStereoLayerShapeEquirect::SetEquirectProps(struct FEquirectProps InScaleBiases){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StereoLayerShapeEquirect.SetEquirectProps");

	FSetEquirectProps parms{};	
	parms.InScaleBiases = InScaleBiases;

	ProcessEvent(fn, &parms);
}

void UStereoLayerComponent::SetUVRect(struct FBox2D InUVRect){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StereoLayerComponent.SetUVRect");

	FSetUVRect parms{};	
	parms.InUVRect = InUVRect;

	ProcessEvent(fn, &parms);
}

void UStereoLayerComponent::SetTexture(struct UTexture* InTexture){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StereoLayerComponent.SetTexture");

	FSetTexture parms{};	
	parms.InTexture = InTexture;

	ProcessEvent(fn, &parms);
}

void UStereoLayerComponent::SetQuadSize(struct FVector2D InQuadSize){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StereoLayerComponent.SetQuadSize");

	FSetQuadSize parms{};	
	parms.InQuadSize = InQuadSize;

	ProcessEvent(fn, &parms);
}

void UStereoLayerComponent::SetPriority(int32_t InPriority){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StereoLayerComponent.SetPriority");

	FSetPriority parms{};	
	parms.InPriority = InPriority;

	ProcessEvent(fn, &parms);
}

void UStereoLayerComponent::SetLeftTexture(struct UTexture* InTexture){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StereoLayerComponent.SetLeftTexture");

	FSetLeftTexture parms{};	
	parms.InTexture = InTexture;

	ProcessEvent(fn, &parms);
}

void UStereoLayerComponent::SetEquirectProps(struct FEquirectProps InScaleBiases){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StereoLayerComponent.SetEquirectProps");

	FSetEquirectProps parms{};	
	parms.InScaleBiases = InScaleBiases;

	ProcessEvent(fn, &parms);
}

void UStereoLayerComponent::MarkTextureForUpdate(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StereoLayerComponent.MarkTextureForUpdate");

	FMarkTextureForUpdate parms{};	

	ProcessEvent(fn, &parms);
}

struct FBox2D UStereoLayerComponent::GetUVRect(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StereoLayerComponent.GetUVRect");

	FGetUVRect parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UTexture* UStereoLayerComponent::GetTexture(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StereoLayerComponent.GetTexture");

	FGetTexture parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector2D UStereoLayerComponent::GetQuadSize(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StereoLayerComponent.GetQuadSize");

	FGetQuadSize parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UStereoLayerComponent::GetPriority(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StereoLayerComponent.GetPriority");

	FGetPriority parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UTexture* UStereoLayerComponent::GetLeftTexture(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StereoLayerComponent.GetLeftTexture");

	FGetLeftTexture parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UTextRenderComponent::SetYScale(float Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetYScale");

	FSetYScale parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UTextRenderComponent::SetXScale(float Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetXScale");

	FSetXScale parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UTextRenderComponent::SetWorldSize(float Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetWorldSize");

	FSetWorldSize parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UTextRenderComponent::SetVertSpacingAdjust(float Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetVertSpacingAdjust");

	FSetVertSpacingAdjust parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UTextRenderComponent::SetVerticalAlignment(enum class EVerticalTextAligment Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetVerticalAlignment");

	FSetVerticalAlignment parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UTextRenderComponent::SetTextRenderColor(struct FColor Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetTextRenderColor");

	FSetTextRenderColor parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UTextRenderComponent::SetTextMaterial(struct UMaterialInterface* Material){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetTextMaterial");

	FSetTextMaterial parms{};	
	parms.Material = Material;

	ProcessEvent(fn, &parms);
}

void UTextRenderComponent::SetHorizSpacingAdjust(float Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetHorizSpacingAdjust");

	FSetHorizSpacingAdjust parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UTextRenderComponent::SetHorizontalAlignment(enum class EHorizTextAligment Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetHorizontalAlignment");

	FSetHorizontalAlignment parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UTextRenderComponent::SetFont(struct UFont* Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetFont");

	FSetFont parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UTextRenderComponent::K2_SetText(struct FText& Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.K2_SetText");

	FK2_SetText parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

struct FVector UTextRenderComponent::GetTextWorldSize(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.GetTextWorldSize");

	FGetTextWorldSize parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UTextRenderComponent::GetTextLocalSize(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.GetTextLocalSize");

	FGetTextLocalSize parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UTwitterIntegrationBase::TwitterRequest(struct FString URL, struct TArray<struct FString>& ParamKeysAndValues, enum class ETwitterRequestMethod RequestMethod, int32_t AccountIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TwitterIntegrationBase.TwitterRequest");

	FTwitterRequest parms{};	
	parms.URL = URL;
	parms.ParamKeysAndValues = ParamKeysAndValues;
	parms.RequestMethod = RequestMethod;
	parms.AccountIndex = AccountIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UTwitterIntegrationBase::ShowTweetUI(struct FString InitialMessage, struct FString URL, struct FString Picture){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TwitterIntegrationBase.ShowTweetUI");

	FShowTweetUI parms{};	
	parms.InitialMessage = InitialMessage;
	parms.URL = URL;
	parms.Picture = Picture;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UTwitterIntegrationBase::Init(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TwitterIntegrationBase.Init");

	FInit parms{};	

	ProcessEvent(fn, &parms);
}

int32_t UTwitterIntegrationBase::GetNumAccounts(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TwitterIntegrationBase.GetNumAccounts");

	FGetNumAccounts parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UTwitterIntegrationBase::GetAccountName(int32_t AccountIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TwitterIntegrationBase.GetAccountName");

	FGetAccountName parms{};	
	parms.AccountIndex = AccountIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UTwitterIntegrationBase::CanShowTweetUI(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TwitterIntegrationBase.CanShowTweetUI");

	FCanShowTweetUI parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UTwitterIntegrationBase::AuthorizeAccounts(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TwitterIntegrationBase.AuthorizeAccounts");

	FAuthorizeAccounts parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UVectorFieldComponent::SetIntensity(float NewIntensity){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.VectorFieldComponent.SetIntensity");

	FSetIntensity parms{};	
	parms.NewIntensity = NewIntensity;

	ProcessEvent(fn, &parms);
}

void UAutoDestroySubsystem::OnActorEndPlay(struct AActor* Actor, enum class EEndPlayReason EndPlayReason){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AutoDestroySubsystem.OnActorEndPlay");

	FOnActorEndPlay parms{};	
	parms.Actor = Actor;
	parms.EndPlayReason = EndPlayReason;

	ProcessEvent(fn, &parms);
}

struct FVector UPhysicsFieldStatics::EvalPhysicsVectorField(struct UObject* WorldContextObject, struct FVector& WorldPosition, enum class EFieldVectorType VectorType){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsFieldStatics.EvalPhysicsVectorField");

	FEvalPhysicsVectorField parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.WorldPosition = WorldPosition;
	parms.VectorType = VectorType;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UPhysicsFieldStatics::EvalPhysicsScalarField(struct UObject* WorldContextObject, struct FVector& WorldPosition, enum class EFieldScalarType ScalarType){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsFieldStatics.EvalPhysicsScalarField");

	FEvalPhysicsScalarField parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.WorldPosition = WorldPosition;
	parms.ScalarType = ScalarType;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UPhysicsFieldStatics::EvalPhysicsIntegerField(struct UObject* WorldContextObject, struct FVector& WorldPosition, enum class EFieldIntegerType IntegerType){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsFieldStatics.EvalPhysicsIntegerField");

	FEvalPhysicsIntegerField parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.WorldPosition = WorldPosition;
	parms.IntegerType = IntegerType;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UParticleSystem* UAnimNotifyState_Trail::OverridePSTemplate(struct USkeletalMeshComponent* MeshComp, struct UAnimSequenceBase* Animation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimNotifyState_Trail.OverridePSTemplate");

	FOverridePSTemplate parms{};	
	parms.MeshComp = MeshComp;
	parms.Animation = Animation;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void AAmbientSound::Stop(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AmbientSound.Stop");

	FStop parms{};	

	ProcessEvent(fn, &parms);
}

void AAmbientSound::Play(float StartTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AmbientSound.Play");

	FPlay parms{};	
	parms.StartTime = StartTime;

	ProcessEvent(fn, &parms);
}

void AAmbientSound::FadeOut(float FadeOutDuration, float FadeVolumeLevel){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AmbientSound.FadeOut");

	FFadeOut parms{};	
	parms.FadeOutDuration = FadeOutDuration;
	parms.FadeVolumeLevel = FadeVolumeLevel;

	ProcessEvent(fn, &parms);
}

void AAmbientSound::FadeIn(float FadeInDuration, float FadeVolumeLevel){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AmbientSound.FadeIn");

	FFadeIn parms{};	
	parms.FadeInDuration = FadeInDuration;
	parms.FadeVolumeLevel = FadeVolumeLevel;

	ProcessEvent(fn, &parms);
}

void AAmbientSound::AdjustVolume(float AdjustVolumeDuration, float AdjustVolumeLevel){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AmbientSound.AdjustVolume");

	FAdjustVolume parms{};	
	parms.AdjustVolumeDuration = AdjustVolumeDuration;
	parms.AdjustVolumeLevel = AdjustVolumeLevel;

	ProcessEvent(fn, &parms);
}

bool UAnimMontage::IsValidSectionName(struct FName InSectionName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimMontage.IsValidSectionName");

	FIsValidSectionName parms{};	
	parms.InSectionName = InSectionName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FName UAnimMontage::GetSectionName(int32_t SectionIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimMontage.GetSectionName");

	FGetSectionName parms{};	
	parms.SectionIndex = SectionIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UAnimMontage::GetSectionIndex(struct FName InSectionName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimMontage.GetSectionIndex");

	FGetSectionIndex parms{};	
	parms.InSectionName = InSectionName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UAnimMontage::GetNumSections(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimMontage.GetNumSections");

	FGetNumSections parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UAnimMontage::GetDefaultBlendOutTime(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimMontage.GetDefaultBlendOutTime");

	FGetDefaultBlendOutTime parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UAnimMontage::GetDefaultBlendInTime(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimMontage.GetDefaultBlendInTime");

	FGetDefaultBlendInTime parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FAlphaBlendArgs UAnimMontage::GetBlendOutArgs(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimMontage.GetBlendOutArgs");

	FGetBlendOutArgs parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FAlphaBlendArgs UAnimMontage::GetBlendInArgs(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimMontage.GetBlendInArgs");

	FGetBlendInArgs parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UAnimMontage* UAnimMontage::CreateSlotAnimationAsDynamicMontage_WithBlendSettings(struct UAnimSequenceBase* Asset, struct FName SlotNodeName, struct FMontageBlendSettings& BlendInSettings, struct FMontageBlendSettings& BlendOutSettings, float InPlayRate, int32_t LoopCount, float InBlendOutTriggerTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimMontage.CreateSlotAnimationAsDynamicMontage_WithBlendSettings");

	FCreateSlotAnimationAsDynamicMontage_WithBlendSettings parms{};	
	parms.Asset = Asset;
	parms.SlotNodeName = SlotNodeName;
	parms.BlendInSettings = BlendInSettings;
	parms.BlendOutSettings = BlendOutSettings;
	parms.InPlayRate = InPlayRate;
	parms.LoopCount = LoopCount;
	parms.InBlendOutTriggerTime = InBlendOutTriggerTime;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimNotifyLibrary::NotifyStateReachedEnd(struct FAnimNotifyEventReference& EventReference){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimNotifyLibrary.NotifyStateReachedEnd");

	FNotifyStateReachedEnd parms{};	
	parms.EventReference = EventReference;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimNotifyMirrorInspectionLibrary::IsTriggeredByMirroredAnimation(struct FAnimNotifyEventReference& EventReference){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimNotifyMirrorInspectionLibrary.IsTriggeredByMirroredAnimation");

	FIsTriggeredByMirroredAnimation parms{};	
	parms.EventReference = EventReference;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UMirrorDataTable* UAnimNotifyMirrorInspectionLibrary::GetMirrorDataTable(struct FAnimNotifyEventReference& EventReference){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimNotifyMirrorInspectionLibrary.GetMirrorDataTable");

	FGetMirrorDataTable parms{};	
	parms.EventReference = EventReference;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimNotifyStateMachineInspectionLibrary::IsTriggeredByStateMachine(struct FAnimNotifyEventReference& EventReference, struct UAnimInstance* AnimInstance, struct FName StateMachineName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimNotifyStateMachineInspectionLibrary.IsTriggeredByStateMachine");

	FIsTriggeredByStateMachine parms{};	
	parms.EventReference = EventReference;
	parms.AnimInstance = AnimInstance;
	parms.StateMachineName = StateMachineName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimNotifyStateMachineInspectionLibrary::IsTriggeredByStateInStateMachine(struct FAnimNotifyEventReference& EventReference, struct UAnimInstance* AnimInstance, struct FName StateMachineName, struct FName StateName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimNotifyStateMachineInspectionLibrary.IsTriggeredByStateInStateMachine");

	FIsTriggeredByStateInStateMachine parms{};	
	parms.EventReference = EventReference;
	parms.AnimInstance = AnimInstance;
	parms.StateMachineName = StateMachineName;
	parms.StateName = StateName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UAnimNotifyStateMachineInspectionLibrary::IsTriggeredByState(struct FAnimNotifyEventReference& EventReference, struct UAnimInstance* AnimInstance, struct FName StateName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimNotifyStateMachineInspectionLibrary.IsTriggeredByState");

	FIsTriggeredByState parms{};	
	parms.EventReference = EventReference;
	parms.AnimInstance = AnimInstance;
	parms.StateName = StateName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UAnimSingleNodeInstance::StopAnim(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.StopAnim");

	FStopAnim parms{};	

	ProcessEvent(fn, &parms);
}

void UAnimSingleNodeInstance::SetReverse(bool bInReverse){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetReverse");

	FSetReverse parms{};	
	parms.bInReverse = bInReverse;

	ProcessEvent(fn, &parms);
}

void UAnimSingleNodeInstance::SetPreviewCurveOverride(struct FName& PoseName, float Value, bool bRemoveIfZero){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetPreviewCurveOverride");

	FSetPreviewCurveOverride parms{};	
	parms.PoseName = PoseName;
	parms.Value = Value;
	parms.bRemoveIfZero = bRemoveIfZero;

	ProcessEvent(fn, &parms);
}

void UAnimSingleNodeInstance::SetPositionWithPreviousTime(float InPosition, float InPreviousTime, bool bFireNotifies){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetPositionWithPreviousTime");

	FSetPositionWithPreviousTime parms{};	
	parms.InPosition = InPosition;
	parms.InPreviousTime = InPreviousTime;
	parms.bFireNotifies = bFireNotifies;

	ProcessEvent(fn, &parms);
}

void UAnimSingleNodeInstance::SetPosition(float InPosition, bool bFireNotifies){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetPosition");

	FSetPosition parms{};	
	parms.InPosition = InPosition;
	parms.bFireNotifies = bFireNotifies;

	ProcessEvent(fn, &parms);
}

void UAnimSingleNodeInstance::SetPlayRate(float InPlayRate){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetPlayRate");

	FSetPlayRate parms{};	
	parms.InPlayRate = InPlayRate;

	ProcessEvent(fn, &parms);
}

void UAnimSingleNodeInstance::SetPlaying(bool bIsPlaying){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetPlaying");

	FSetPlaying parms{};	
	parms.bIsPlaying = bIsPlaying;

	ProcessEvent(fn, &parms);
}

void UAnimSingleNodeInstance::SetMirrorDataTable(struct UMirrorDataTable* MirrorDataTable){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetMirrorDataTable");

	FSetMirrorDataTable parms{};	
	parms.MirrorDataTable = MirrorDataTable;

	ProcessEvent(fn, &parms);
}

void UAnimSingleNodeInstance::SetLooping(bool bIsLooping){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetLooping");

	FSetLooping parms{};	
	parms.bIsLooping = bIsLooping;

	ProcessEvent(fn, &parms);
}

void UAnimSingleNodeInstance::SetBlendSpacePosition(struct FVector& InPosition){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetBlendSpacePosition");

	FSetBlendSpacePosition parms{};	
	parms.InPosition = InPosition;

	ProcessEvent(fn, &parms);
}

void UAnimSingleNodeInstance::SetAnimationAsset(struct UAnimationAsset* NewAsset, bool bIsLooping, float InPlayRate){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetAnimationAsset");

	FSetAnimationAsset parms{};	
	parms.NewAsset = NewAsset;
	parms.bIsLooping = bIsLooping;
	parms.InPlayRate = InPlayRate;

	ProcessEvent(fn, &parms);
}

void UAnimSingleNodeInstance::PlayAnim(bool bIsLooping, float InPlayRate, float InStartPosition){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.PlayAnim");

	FPlayAnim parms{};	
	parms.bIsLooping = bIsLooping;
	parms.InPlayRate = InPlayRate;
	parms.InStartPosition = InStartPosition;

	ProcessEvent(fn, &parms);
}

struct UMirrorDataTable* UAnimSingleNodeInstance::GetMirrorDataTable(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.GetMirrorDataTable");

	FGetMirrorDataTable parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UAnimSingleNodeInstance::GetLength(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.GetLength");

	FGetLength parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UAnimationAsset* UAnimSingleNodeInstance::GetAnimationAsset(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.GetAnimationAsset");

	FGetAnimationAsset parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UCachedAnimDataLibrary::StateMachine_IsStateRelevant(struct UAnimInstance* InAnimInstance, struct FCachedAnimStateData& CachedAnimStateData){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CachedAnimDataLibrary.StateMachine_IsStateRelevant");

	FStateMachine_IsStateRelevant parms{};	
	parms.InAnimInstance = InAnimInstance;
	parms.CachedAnimStateData = CachedAnimStateData;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UCachedAnimDataLibrary::StateMachine_GetLocalWeight(struct UAnimInstance* InAnimInstance, struct FCachedAnimStateData& CachedAnimStateData){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CachedAnimDataLibrary.StateMachine_GetLocalWeight");

	FStateMachine_GetLocalWeight parms{};	
	parms.InAnimInstance = InAnimInstance;
	parms.CachedAnimStateData = CachedAnimStateData;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UCachedAnimDataLibrary::StateMachine_GetGlobalWeight(struct UAnimInstance* InAnimInstance, struct FCachedAnimStateData& CachedAnimStateData){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CachedAnimDataLibrary.StateMachine_GetGlobalWeight");

	FStateMachine_GetGlobalWeight parms{};	
	parms.InAnimInstance = InAnimInstance;
	parms.CachedAnimStateData = CachedAnimStateData;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UCapsuleComponent::SetCapsuleSize(float InRadius, float InHalfHeight, bool bUpdateOverlaps){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.SetCapsuleSize");

	FSetCapsuleSize parms{};	
	parms.InRadius = InRadius;
	parms.InHalfHeight = InHalfHeight;
	parms.bUpdateOverlaps = bUpdateOverlaps;

	ProcessEvent(fn, &parms);
}

void UCapsuleComponent::SetCapsuleRadius(float Radius, bool bUpdateOverlaps){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.SetCapsuleRadius");

	FSetCapsuleRadius parms{};	
	parms.Radius = Radius;
	parms.bUpdateOverlaps = bUpdateOverlaps;

	ProcessEvent(fn, &parms);
}

void UCapsuleComponent::SetCapsuleHalfHeight(float HalfHeight, bool bUpdateOverlaps){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.SetCapsuleHalfHeight");

	FSetCapsuleHalfHeight parms{};	
	parms.HalfHeight = HalfHeight;
	parms.bUpdateOverlaps = bUpdateOverlaps;

	ProcessEvent(fn, &parms);
}

void UCapsuleComponent::GetUnscaledCapsuleSize_WithoutHemisphere(float& OutRadius, float& OutHalfHeightWithoutHemisphere){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetUnscaledCapsuleSize_WithoutHemisphere");

	FGetUnscaledCapsuleSize_WithoutHemisphere parms{};	
	parms.OutRadius = OutRadius;
	parms.OutHalfHeightWithoutHemisphere = OutHalfHeightWithoutHemisphere;

	ProcessEvent(fn, &parms);
}

void UCapsuleComponent::GetUnscaledCapsuleSize(float& OutRadius, float& OutHalfHeight){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetUnscaledCapsuleSize");

	FGetUnscaledCapsuleSize parms{};	
	parms.OutRadius = OutRadius;
	parms.OutHalfHeight = OutHalfHeight;

	ProcessEvent(fn, &parms);
}

float UCapsuleComponent::GetUnscaledCapsuleRadius(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetUnscaledCapsuleRadius");

	FGetUnscaledCapsuleRadius parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UCapsuleComponent::GetUnscaledCapsuleHalfHeight_WithoutHemisphere(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetUnscaledCapsuleHalfHeight_WithoutHemisphere");

	FGetUnscaledCapsuleHalfHeight_WithoutHemisphere parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UCapsuleComponent::GetUnscaledCapsuleHalfHeight(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetUnscaledCapsuleHalfHeight");

	FGetUnscaledCapsuleHalfHeight parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UCapsuleComponent::GetShapeScale(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetShapeScale");

	FGetShapeScale parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UCapsuleComponent::GetScaledCapsuleSize_WithoutHemisphere(float& OutRadius, float& OutHalfHeightWithoutHemisphere){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetScaledCapsuleSize_WithoutHemisphere");

	FGetScaledCapsuleSize_WithoutHemisphere parms{};	
	parms.OutRadius = OutRadius;
	parms.OutHalfHeightWithoutHemisphere = OutHalfHeightWithoutHemisphere;

	ProcessEvent(fn, &parms);
}

void UCapsuleComponent::GetScaledCapsuleSize(float& OutRadius, float& OutHalfHeight){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetScaledCapsuleSize");

	FGetScaledCapsuleSize parms{};	
	parms.OutRadius = OutRadius;
	parms.OutHalfHeight = OutHalfHeight;

	ProcessEvent(fn, &parms);
}

float UCapsuleComponent::GetScaledCapsuleRadius(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetScaledCapsuleRadius");

	FGetScaledCapsuleRadius parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UCapsuleComponent::GetScaledCapsuleHalfHeight_WithoutHemisphere(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetScaledCapsuleHalfHeight_WithoutHemisphere");

	FGetScaledCapsuleHalfHeight_WithoutHemisphere parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UCapsuleComponent::GetScaledCapsuleHalfHeight(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetScaledCapsuleHalfHeight");

	FGetScaledCapsuleHalfHeight parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UCurveSourceInterface::GetCurveValue(struct FName CurveName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CurveSourceInterface.GetCurveValue");

	FGetCurveValue parms{};	
	parms.CurveName = CurveName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UCurveSourceInterface::GetCurves(struct TArray<struct FNamedCurveValue>& OutValues){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CurveSourceInterface.GetCurves");

	FGetCurves parms{};	
	parms.OutValues = OutValues;

	ProcessEvent(fn, &parms);
}

struct FName UCurveSourceInterface::GetBindingName(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CurveSourceInterface.GetBindingName");

	FGetBindingName parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void ASkeletalMeshActor::OnRep_ReplicatedPhysAsset(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshActor.OnRep_ReplicatedPhysAsset");

	FOnRep_ReplicatedPhysAsset parms{};	

	ProcessEvent(fn, &parms);
}

void ASkeletalMeshActor::OnRep_ReplicatedMesh(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshActor.OnRep_ReplicatedMesh");

	FOnRep_ReplicatedMesh parms{};	

	ProcessEvent(fn, &parms);
}

void ASkeletalMeshActor::OnRep_ReplicatedMaterial1(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshActor.OnRep_ReplicatedMaterial1");

	FOnRep_ReplicatedMaterial1 parms{};	

	ProcessEvent(fn, &parms);
}

void ASkeletalMeshActor::OnRep_ReplicatedMaterial0(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMeshActor.OnRep_ReplicatedMaterial0");

	FOnRep_ReplicatedMaterial0 parms{};	

	ProcessEvent(fn, &parms);
}

struct UAsyncActionLoadPrimaryAssetClass* UAsyncActionLoadPrimaryAssetClass::AsyncLoadPrimaryAssetClass(struct UObject* WorldContextObject, struct FPrimaryAssetId PrimaryAsset, struct TArray<struct FName>& LoadBundles){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AsyncActionLoadPrimaryAssetClass.AsyncLoadPrimaryAssetClass");

	FAsyncLoadPrimaryAssetClass parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.PrimaryAsset = PrimaryAsset;
	parms.LoadBundles = LoadBundles;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector2D UCanvas::K2_TextSize(struct UFont* RenderFont, struct FString RenderText, struct FVector2D Scale){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Canvas.K2_TextSize");

	FK2_TextSize parms{};	
	parms.RenderFont = RenderFont;
	parms.RenderText = RenderText;
	parms.Scale = Scale;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector2D UCanvas::K2_StrLen(struct UFont* RenderFont, struct FString RenderText){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Canvas.K2_StrLen");

	FK2_StrLen parms{};	
	parms.RenderFont = RenderFont;
	parms.RenderText = RenderText;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UCanvas::K2_Project(struct FVector WorldLocation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Canvas.K2_Project");

	FK2_Project parms{};	
	parms.WorldLocation = WorldLocation;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UCanvas::K2_DrawTriangle(struct UTexture* RenderTexture, struct TArray<struct FCanvasUVTri> Triangles){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawTriangle");

	FK2_DrawTriangle parms{};	
	parms.RenderTexture = RenderTexture;
	parms.Triangles = Triangles;

	ProcessEvent(fn, &parms);
}

void UCanvas::K2_DrawTexture(struct UTexture* RenderTexture, struct FVector2D ScreenPosition, struct FVector2D ScreenSize, struct FVector2D CoordinatePosition, struct FVector2D CoordinateSize, struct FLinearColor RenderColor, enum class EBlendMode BlendMode, float Rotation, struct FVector2D PivotPoint){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawTexture");

	FK2_DrawTexture parms{};	
	parms.RenderTexture = RenderTexture;
	parms.ScreenPosition = ScreenPosition;
	parms.ScreenSize = ScreenSize;
	parms.CoordinatePosition = CoordinatePosition;
	parms.CoordinateSize = CoordinateSize;
	parms.RenderColor = RenderColor;
	parms.BlendMode = BlendMode;
	parms.Rotation = Rotation;
	parms.PivotPoint = PivotPoint;

	ProcessEvent(fn, &parms);
}

void UCanvas::K2_DrawText(struct UFont* RenderFont, struct FString RenderText, struct FVector2D ScreenPosition, struct FVector2D Scale, struct FLinearColor RenderColor, float Kerning, struct FLinearColor ShadowColor, struct FVector2D ShadowOffset, bool bCentreX, bool bCentreY, bool bOutlined, struct FLinearColor OutlineColor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawText");

	FK2_DrawText parms{};	
	parms.RenderFont = RenderFont;
	parms.RenderText = RenderText;
	parms.ScreenPosition = ScreenPosition;
	parms.Scale = Scale;
	parms.RenderColor = RenderColor;
	parms.Kerning = Kerning;
	parms.ShadowColor = ShadowColor;
	parms.ShadowOffset = ShadowOffset;
	parms.bCentreX = bCentreX;
	parms.bCentreY = bCentreY;
	parms.bOutlined = bOutlined;
	parms.OutlineColor = OutlineColor;

	ProcessEvent(fn, &parms);
}

void UCanvas::K2_DrawPolygon(struct UTexture* RenderTexture, struct FVector2D ScreenPosition, struct FVector2D Radius, int32_t NumberOfSides, struct FLinearColor RenderColor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawPolygon");

	FK2_DrawPolygon parms{};	
	parms.RenderTexture = RenderTexture;
	parms.ScreenPosition = ScreenPosition;
	parms.Radius = Radius;
	parms.NumberOfSides = NumberOfSides;
	parms.RenderColor = RenderColor;

	ProcessEvent(fn, &parms);
}

void UCanvas::K2_DrawMaterialTriangle(struct UMaterialInterface* RenderMaterial, struct TArray<struct FCanvasUVTri> Triangles){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawMaterialTriangle");

	FK2_DrawMaterialTriangle parms{};	
	parms.RenderMaterial = RenderMaterial;
	parms.Triangles = Triangles;

	ProcessEvent(fn, &parms);
}

void UCanvas::K2_DrawMaterial(struct UMaterialInterface* RenderMaterial, struct FVector2D ScreenPosition, struct FVector2D ScreenSize, struct FVector2D CoordinatePosition, struct FVector2D CoordinateSize, float Rotation, struct FVector2D PivotPoint){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawMaterial");

	FK2_DrawMaterial parms{};	
	parms.RenderMaterial = RenderMaterial;
	parms.ScreenPosition = ScreenPosition;
	parms.ScreenSize = ScreenSize;
	parms.CoordinatePosition = CoordinatePosition;
	parms.CoordinateSize = CoordinateSize;
	parms.Rotation = Rotation;
	parms.PivotPoint = PivotPoint;

	ProcessEvent(fn, &parms);
}

void UCanvas::K2_DrawLine(struct FVector2D ScreenPositionA, struct FVector2D ScreenPositionB, float Thickness, struct FLinearColor RenderColor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawLine");

	FK2_DrawLine parms{};	
	parms.ScreenPositionA = ScreenPositionA;
	parms.ScreenPositionB = ScreenPositionB;
	parms.Thickness = Thickness;
	parms.RenderColor = RenderColor;

	ProcessEvent(fn, &parms);
}

void UCanvas::K2_DrawBox(struct FVector2D ScreenPosition, struct FVector2D ScreenSize, float Thickness, struct FLinearColor RenderColor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawBox");

	FK2_DrawBox parms{};	
	parms.ScreenPosition = ScreenPosition;
	parms.ScreenSize = ScreenSize;
	parms.Thickness = Thickness;
	parms.RenderColor = RenderColor;

	ProcessEvent(fn, &parms);
}

void UCanvas::K2_DrawBorder(struct UTexture* BorderTexture, struct UTexture* BackgroundTexture, struct UTexture* LeftBorderTexture, struct UTexture* RightBorderTexture, struct UTexture* TopBorderTexture, struct UTexture* BottomBorderTexture, struct FVector2D ScreenPosition, struct FVector2D ScreenSize, struct FVector2D CoordinatePosition, struct FVector2D CoordinateSize, struct FLinearColor RenderColor, struct FVector2D BorderScale, struct FVector2D BackgroundScale, float Rotation, struct FVector2D PivotPoint, struct FVector2D CornerSize){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawBorder");

	FK2_DrawBorder parms{};	
	parms.BorderTexture = BorderTexture;
	parms.BackgroundTexture = BackgroundTexture;
	parms.LeftBorderTexture = LeftBorderTexture;
	parms.RightBorderTexture = RightBorderTexture;
	parms.TopBorderTexture = TopBorderTexture;
	parms.BottomBorderTexture = BottomBorderTexture;
	parms.ScreenPosition = ScreenPosition;
	parms.ScreenSize = ScreenSize;
	parms.CoordinatePosition = CoordinatePosition;
	parms.CoordinateSize = CoordinateSize;
	parms.RenderColor = RenderColor;
	parms.BorderScale = BorderScale;
	parms.BackgroundScale = BackgroundScale;
	parms.Rotation = Rotation;
	parms.PivotPoint = PivotPoint;
	parms.CornerSize = CornerSize;

	ProcessEvent(fn, &parms);
}

void UCanvas::K2_Deproject(struct FVector2D ScreenPosition, struct FVector& WorldOrigin, struct FVector& WorldDirection){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.Canvas.K2_Deproject");

	FK2_Deproject parms{};	
	parms.ScreenPosition = ScreenPosition;
	parms.WorldOrigin = WorldOrigin;
	parms.WorldDirection = WorldDirection;

	ProcessEvent(fn, &parms);
}

struct UAsyncActionLoadPrimaryAssetClassList* UAsyncActionLoadPrimaryAssetClassList::AsyncLoadPrimaryAssetClassList(struct UObject* WorldContextObject, struct TArray<struct FPrimaryAssetId>& PrimaryAssetList, struct TArray<struct FName>& LoadBundles){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AsyncActionLoadPrimaryAssetClassList.AsyncLoadPrimaryAssetClassList");

	FAsyncLoadPrimaryAssetClassList parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.PrimaryAssetList = PrimaryAssetList;
	parms.LoadBundles = LoadBundles;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void USkyAtmosphereComponent::SetSkyLuminanceFactor(struct FLinearColor NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetSkyLuminanceFactor");

	FSetSkyLuminanceFactor parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void USkyAtmosphereComponent::SetRayleighScatteringScale(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetRayleighScatteringScale");

	FSetRayleighScatteringScale parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void USkyAtmosphereComponent::SetRayleighScattering(struct FLinearColor NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetRayleighScattering");

	FSetRayleighScattering parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void USkyAtmosphereComponent::SetRayleighExponentialDistribution(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetRayleighExponentialDistribution");

	FSetRayleighExponentialDistribution parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void USkyAtmosphereComponent::SetOtherAbsorptionScale(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetOtherAbsorptionScale");

	FSetOtherAbsorptionScale parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void USkyAtmosphereComponent::SetOtherAbsorption(struct FLinearColor NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetOtherAbsorption");

	FSetOtherAbsorption parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void USkyAtmosphereComponent::SetMultiScatteringFactor(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetMultiScatteringFactor");

	FSetMultiScatteringFactor parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void USkyAtmosphereComponent::SetMieScatteringScale(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetMieScatteringScale");

	FSetMieScatteringScale parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void USkyAtmosphereComponent::SetMieScattering(struct FLinearColor NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetMieScattering");

	FSetMieScattering parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void USkyAtmosphereComponent::SetMieExponentialDistribution(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetMieExponentialDistribution");

	FSetMieExponentialDistribution parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void USkyAtmosphereComponent::SetMieAnisotropy(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetMieAnisotropy");

	FSetMieAnisotropy parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void USkyAtmosphereComponent::SetMieAbsorptionScale(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetMieAbsorptionScale");

	FSetMieAbsorptionScale parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void USkyAtmosphereComponent::SetMieAbsorption(struct FLinearColor NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetMieAbsorption");

	FSetMieAbsorption parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void USkyAtmosphereComponent::SetHeightFogContribution(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetHeightFogContribution");

	FSetHeightFogContribution parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void USkyAtmosphereComponent::SetAtmosphereHeight(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetAtmosphereHeight");

	FSetAtmosphereHeight parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void USkyAtmosphereComponent::SetAerialPespectiveViewDistanceScale(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetAerialPespectiveViewDistanceScale");

	FSetAerialPespectiveViewDistanceScale parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void USkyAtmosphereComponent::OverrideAtmosphereLightDirection(int32_t AtmosphereLightIndex, struct FVector& LightDirection){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.OverrideAtmosphereLightDirection");

	FOverrideAtmosphereLightDirection parms{};	
	parms.AtmosphereLightIndex = AtmosphereLightIndex;
	parms.LightDirection = LightDirection;

	ProcessEvent(fn, &parms);
}

struct FLinearColor USkyAtmosphereComponent::GetAtmosphereTransmitanceOnGroundAtPlanetTop(struct UDirectionalLightComponent* DirectionalLight){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.GetAtmosphereTransmitanceOnGroundAtPlanetTop");

	FGetAtmosphereTransmitanceOnGroundAtPlanetTop parms{};	
	parms.DirectionalLight = DirectionalLight;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UAtmosphericFogComponent::SetSunMultiplier(float NewSunMultiplier){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetSunMultiplier");

	FSetSunMultiplier parms{};	
	parms.NewSunMultiplier = NewSunMultiplier;

	ProcessEvent(fn, &parms);
}

void UAtmosphericFogComponent::SetStartDistance(float NewStartDistance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetStartDistance");

	FSetStartDistance parms{};	
	parms.NewStartDistance = NewStartDistance;

	ProcessEvent(fn, &parms);
}

void UAtmosphericFogComponent::SetPrecomputeParams(float DensityHeight, int32_t MaxScatteringOrder, int32_t InscatterAltitudeSampleNum){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetPrecomputeParams");

	FSetPrecomputeParams parms{};	
	parms.DensityHeight = DensityHeight;
	parms.MaxScatteringOrder = MaxScatteringOrder;
	parms.InscatterAltitudeSampleNum = InscatterAltitudeSampleNum;

	ProcessEvent(fn, &parms);
}

void UAtmosphericFogComponent::SetFogMultiplier(float NewFogMultiplier){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetFogMultiplier");

	FSetFogMultiplier parms{};	
	parms.NewFogMultiplier = NewFogMultiplier;

	ProcessEvent(fn, &parms);
}

void UAtmosphericFogComponent::SetDistanceScale(float NewDistanceScale){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetDistanceScale");

	FSetDistanceScale parms{};	
	parms.NewDistanceScale = NewDistanceScale;

	ProcessEvent(fn, &parms);
}

void UAtmosphericFogComponent::SetDistanceOffset(float NewDistanceOffset){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetDistanceOffset");

	FSetDistanceOffset parms{};	
	parms.NewDistanceOffset = NewDistanceOffset;

	ProcessEvent(fn, &parms);
}

void UAtmosphericFogComponent::SetDensityOffset(float NewDensityOffset){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetDensityOffset");

	FSetDensityOffset parms{};	
	parms.NewDensityOffset = NewDensityOffset;

	ProcessEvent(fn, &parms);
}

void UAtmosphericFogComponent::SetDensityMultiplier(float NewDensityMultiplier){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetDensityMultiplier");

	FSetDensityMultiplier parms{};	
	parms.NewDensityMultiplier = NewDensityMultiplier;

	ProcessEvent(fn, &parms);
}

void UAtmosphericFogComponent::SetDefaultLightColor(struct FLinearColor NewLightColor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetDefaultLightColor");

	FSetDefaultLightColor parms{};	
	parms.NewLightColor = NewLightColor;

	ProcessEvent(fn, &parms);
}

void UAtmosphericFogComponent::SetDefaultBrightness(float NewBrightness){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetDefaultBrightness");

	FSetDefaultBrightness parms{};	
	parms.NewBrightness = NewBrightness;

	ProcessEvent(fn, &parms);
}

void UAtmosphericFogComponent::SetAltitudeScale(float NewAltitudeScale){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetAltitudeScale");

	FSetAltitudeScale parms{};	
	parms.NewAltitudeScale = NewAltitudeScale;

	ProcessEvent(fn, &parms);
}

void UAtmosphericFogComponent::DisableSunDisk(bool NewSunDisk){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.DisableSunDisk");

	FDisableSunDisk parms{};	
	parms.NewSunDisk = NewSunDisk;

	ProcessEvent(fn, &parms);
}

void UAtmosphericFogComponent::DisableGroundScattering(bool NewGroundScattering){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.DisableGroundScattering");

	FDisableGroundScattering parms{};	
	parms.NewGroundScattering = NewGroundScattering;

	ProcessEvent(fn, &parms);
}

void AAudioVolume::SetSubmixSendSettings(struct TArray<struct FAudioVolumeSubmixSendSettings>& NewSubmixSendSettings){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioVolume.SetSubmixSendSettings");

	FSetSubmixSendSettings parms{};	
	parms.NewSubmixSendSettings = NewSubmixSendSettings;

	ProcessEvent(fn, &parms);
}

void AAudioVolume::SetSubmixOverrideSettings(struct TArray<struct FAudioVolumeSubmixOverrideSettings>& NewSubmixOverrideSettings){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioVolume.SetSubmixOverrideSettings");

	FSetSubmixOverrideSettings parms{};	
	parms.NewSubmixOverrideSettings = NewSubmixOverrideSettings;

	ProcessEvent(fn, &parms);
}

void AAudioVolume::SetReverbSettings(struct FReverbSettings& NewReverbSettings){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioVolume.SetReverbSettings");

	FSetReverbSettings parms{};	
	parms.NewReverbSettings = NewReverbSettings;

	ProcessEvent(fn, &parms);
}

void AAudioVolume::SetPriority(float NewPriority){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioVolume.SetPriority");

	FSetPriority parms{};	
	parms.NewPriority = NewPriority;

	ProcessEvent(fn, &parms);
}

void AAudioVolume::SetInteriorSettings(struct FInteriorSettings& NewInteriorSettings){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioVolume.SetInteriorSettings");

	FSetInteriorSettings parms{};	
	parms.NewInteriorSettings = NewInteriorSettings;

	ProcessEvent(fn, &parms);
}

void AAudioVolume::SetEnabled(bool bNewEnabled){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioVolume.SetEnabled");

	FSetEnabled parms{};	
	parms.bNewEnabled = bNewEnabled;

	ProcessEvent(fn, &parms);
}

void AAudioVolume::OnRep_bEnabled(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioVolume.OnRep_bEnabled");

	FOnRep_bEnabled parms{};	

	ProcessEvent(fn, &parms);
}

void UActorSoundParameterInterface::GetActorSoundParams(struct TArray<struct FAudioParameter>& Params){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ActorSoundParameterInterface.GetActorSoundParams");

	FGetActorSoundParams parms{};	
	parms.Params = Params;

	ProcessEvent(fn, &parms);
}

struct FAudioParameter UAudioParameterConversionStatics::StringToAudioParameter(struct FName Name, struct FString String){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioParameterConversionStatics.StringToAudioParameter");

	FStringToAudioParameter parms{};	
	parms.Name = Name;
	parms.String = String;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FAudioParameter UAudioParameterConversionStatics::StringArrayToAudioParameter(struct FName Name, struct TArray<struct FString> Strings){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioParameterConversionStatics.StringArrayToAudioParameter");

	FStringArrayToAudioParameter parms{};	
	parms.Name = Name;
	parms.Strings = Strings;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FAudioParameter UAudioParameterConversionStatics::ObjectToAudioParameter(struct FName Name, struct UObject* Object){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioParameterConversionStatics.ObjectToAudioParameter");

	FObjectToAudioParameter parms{};	
	parms.Name = Name;
	parms.Object = Object;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FAudioParameter UAudioParameterConversionStatics::ObjectArrayToAudioParameter(struct FName Name, struct TArray<struct UObject*> Objects){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioParameterConversionStatics.ObjectArrayToAudioParameter");

	FObjectArrayToAudioParameter parms{};	
	parms.Name = Name;
	parms.Objects = Objects;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FAudioParameter UAudioParameterConversionStatics::IntegerToAudioParameter(struct FName Name, int32_t Integer){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioParameterConversionStatics.IntegerToAudioParameter");

	FIntegerToAudioParameter parms{};	
	parms.Name = Name;
	parms.Integer = Integer;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FAudioParameter UAudioParameterConversionStatics::IntegerArrayToAudioParameter(struct FName Name, struct TArray<int32_t> Integers){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioParameterConversionStatics.IntegerArrayToAudioParameter");

	FIntegerArrayToAudioParameter parms{};	
	parms.Name = Name;
	parms.Integers = Integers;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FAudioParameter UAudioParameterConversionStatics::FloatToAudioParameter(struct FName Name, float float){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioParameterConversionStatics.FloatToAudioParameter");

	FFloatToAudioParameter parms{};	
	parms.Name = Name;
	parms.float = float;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FAudioParameter UAudioParameterConversionStatics::FloatArrayToAudioParameter(struct FName Name, struct TArray<float> Floats){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioParameterConversionStatics.FloatArrayToAudioParameter");

	FFloatArrayToAudioParameter parms{};	
	parms.Name = Name;
	parms.Floats = Floats;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FAudioParameter UAudioParameterConversionStatics::BooleanToAudioParameter(struct FName Name, bool bool){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioParameterConversionStatics.BooleanToAudioParameter");

	FBooleanToAudioParameter parms{};	
	parms.Name = Name;
	parms.bool = bool;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FAudioParameter UAudioParameterConversionStatics::BooleanArrayToAudioParameter(struct FName Name, struct TArray<bool> Bools){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AudioParameterConversionStatics.BooleanArrayToAudioParameter");

	FBooleanArrayToAudioParameter parms{};	
	parms.Name = Name;
	parms.Bools = Bools;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UBlueprintMapLibrary::SetMapPropertyByName(struct UObject* Object, struct FName PropertyName, struct TMap<int32_t, int32_t>& Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintMapLibrary.SetMapPropertyByName");

	FSetMapPropertyByName parms{};	
	parms.Object = Object;
	parms.PropertyName = PropertyName;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UBlueprintMapLibrary::Map_Values(struct TMap<int32_t, int32_t>& TargetMap, struct TArray<int32_t>& Values){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintMapLibrary.Map_Values");

	FMap_Values parms{};	
	parms.TargetMap = TargetMap;
	parms.Values = Values;

	ProcessEvent(fn, &parms);
}

bool UBlueprintMapLibrary::Map_Remove(struct TMap<int32_t, int32_t>& TargetMap, int32_t& Key){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintMapLibrary.Map_Remove");

	FMap_Remove parms{};	
	parms.TargetMap = TargetMap;
	parms.Key = Key;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UBlueprintMapLibrary::Map_Length(struct TMap<int32_t, int32_t>& TargetMap){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintMapLibrary.Map_Length");

	FMap_Length parms{};	
	parms.TargetMap = TargetMap;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UBlueprintMapLibrary::Map_Keys(struct TMap<int32_t, int32_t>& TargetMap, struct TArray<int32_t>& Keys){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintMapLibrary.Map_Keys");

	FMap_Keys parms{};	
	parms.TargetMap = TargetMap;
	parms.Keys = Keys;

	ProcessEvent(fn, &parms);
}

bool UBlueprintMapLibrary::Map_IsNotEmpty(struct TMap<int32_t, int32_t>& TargetMap){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintMapLibrary.Map_IsNotEmpty");

	FMap_IsNotEmpty parms{};	
	parms.TargetMap = TargetMap;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UBlueprintMapLibrary::Map_IsEmpty(struct TMap<int32_t, int32_t>& TargetMap){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintMapLibrary.Map_IsEmpty");

	FMap_IsEmpty parms{};	
	parms.TargetMap = TargetMap;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UBlueprintMapLibrary::Map_Find(struct TMap<int32_t, int32_t>& TargetMap, int32_t& Key, int32_t& Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintMapLibrary.Map_Find");

	FMap_Find parms{};	
	parms.TargetMap = TargetMap;
	parms.Key = Key;
	parms.Value = Value;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UBlueprintMapLibrary::Map_Contains(struct TMap<int32_t, int32_t>& TargetMap, int32_t& Key){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintMapLibrary.Map_Contains");

	FMap_Contains parms{};	
	parms.TargetMap = TargetMap;
	parms.Key = Key;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UBlueprintMapLibrary::Map_Clear(struct TMap<int32_t, int32_t>& TargetMap){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintMapLibrary.Map_Clear");

	FMap_Clear parms{};	
	parms.TargetMap = TargetMap;

	ProcessEvent(fn, &parms);
}

void UBlueprintMapLibrary::Map_Add(struct TMap<int32_t, int32_t>& TargetMap, int32_t& Key, int32_t& Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BlueprintMapLibrary.Map_Add");

	FMap_Add parms{};	
	parms.TargetMap = TargetMap;
	parms.Key = Key;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

struct UFXSystemComponent* UCameraLensEffectInterface::GetPrimaryParticleComponent(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CameraLensEffectInterface.GetPrimaryParticleComponent");

	FGetPrimaryParticleComponent parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<struct UFXSystemComponent*> UCameraLensEffectInterface::GetParticleComponents(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CameraLensEffectInterface.GetParticleComponents");

	FGetParticleComponents parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UCameraLensEffectInterfaceClassSupportLibrary::SetInterfaceClass(AActor* Class, struct FCameraLensInterfaceClassSupport& Var, uint8_t& Result){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CameraLensEffectInterfaceClassSupportLibrary.SetInterfaceClass");

	FSetInterfaceClass parms{};	
	parms.Class = Class;
	parms.Var = Var;
	parms.Result = Result;

	ProcessEvent(fn, &parms);
}

void UCameraLensEffectInterfaceClassSupportLibrary::IsInterfaceValid(struct TScriptInterface<ICameraLensEffectInterface>& CameraLens, uint8_t& Result){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CameraLensEffectInterfaceClassSupportLibrary.IsInterfaceValid");

	FIsInterfaceValid parms{};	
	parms.CameraLens = CameraLens;
	parms.Result = Result;

	ProcessEvent(fn, &parms);
}

void UCameraLensEffectInterfaceClassSupportLibrary::IsInterfaceClassValid(struct FCameraLensInterfaceClassSupport& CameraLens, uint8_t& Result){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CameraLensEffectInterfaceClassSupportLibrary.IsInterfaceClassValid");

	FIsInterfaceClassValid parms{};	
	parms.CameraLens = CameraLens;
	parms.Result = Result;

	ProcessEvent(fn, &parms);
}

AActor* UCameraLensEffectInterfaceClassSupportLibrary::GetInterfaceClass(struct FCameraLensInterfaceClassSupport& CameraLens){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CameraLensEffectInterfaceClassSupportLibrary.GetInterfaceClass");

	FGetInterfaceClass parms{};	
	parms.CameraLens = CameraLens;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UCameraShakeSourceComponent::StopAllCameraShakesOfType(UCameraShakeBase* InCameraShake, bool bImmediately){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CameraShakeSourceComponent.StopAllCameraShakesOfType");

	FStopAllCameraShakesOfType parms{};	
	parms.InCameraShake = InCameraShake;
	parms.bImmediately = bImmediately;

	ProcessEvent(fn, &parms);
}

void UCameraShakeSourceComponent::StopAllCameraShakes(bool bImmediately){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CameraShakeSourceComponent.StopAllCameraShakes");

	FStopAllCameraShakes parms{};	
	parms.bImmediately = bImmediately;

	ProcessEvent(fn, &parms);
}

void UCameraShakeSourceComponent::StartCameraShake(UCameraShakeBase* InCameraShake, float Scale, uint8_t PlaySpace, struct FRotator UserPlaySpaceRot){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CameraShakeSourceComponent.StartCameraShake");

	FStartCameraShake parms{};	
	parms.InCameraShake = InCameraShake;
	parms.Scale = Scale;
	parms.PlaySpace = PlaySpace;
	parms.UserPlaySpaceRot = UserPlaySpaceRot;

	ProcessEvent(fn, &parms);
}

void UCameraShakeSourceComponent::Start(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CameraShakeSourceComponent.Start");

	FStart parms{};	

	ProcessEvent(fn, &parms);
}

float UCameraShakeSourceComponent::GetAttenuationFactor(struct FVector& Location){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CameraShakeSourceComponent.GetAttenuationFactor");

	FGetAttenuationFactor parms{};	
	parms.Location = Location;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UCheatManager::Walk(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.Walk");

	FWalk parms{};	

	ProcessEvent(fn, &parms);
}

void UCheatManager::ViewSelf(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.ViewSelf");

	FViewSelf parms{};	

	ProcessEvent(fn, &parms);
}

void UCheatManager::ViewPlayer(struct FString S){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.ViewPlayer");

	FViewPlayer parms{};	
	parms.S = S;

	ProcessEvent(fn, &parms);
}

void UCheatManager::ViewClass(AActor* DesiredClass){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.ViewClass");

	FViewClass parms{};	
	parms.DesiredClass = DesiredClass;

	ProcessEvent(fn, &parms);
}

void UCheatManager::ViewActor(struct FName ActorName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.ViewActor");

	FViewActor parms{};	
	parms.ActorName = ActorName;

	ProcessEvent(fn, &parms);
}

void UCheatManager::UpdateSafeArea(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.UpdateSafeArea");

	FUpdateSafeArea parms{};	

	ProcessEvent(fn, &parms);
}

void UCheatManager::ToggleServerStatReplicatorUpdateStatNet(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.ToggleServerStatReplicatorUpdateStatNet");

	FToggleServerStatReplicatorUpdateStatNet parms{};	

	ProcessEvent(fn, &parms);
}

void UCheatManager::ToggleServerStatReplicatorClientOverwrite(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.ToggleServerStatReplicatorClientOverwrite");

	FToggleServerStatReplicatorClientOverwrite parms{};	

	ProcessEvent(fn, &parms);
}

void UCheatManager::ToggleDebugCamera(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.ToggleDebugCamera");

	FToggleDebugCamera parms{};	

	ProcessEvent(fn, &parms);
}

void UCheatManager::ToggleAILogging(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.ToggleAILogging");

	FToggleAILogging parms{};	

	ProcessEvent(fn, &parms);
}

void UCheatManager::TestCollisionDistance(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.TestCollisionDistance");

	FTestCollisionDistance parms{};	

	ProcessEvent(fn, &parms);
}

void UCheatManager::Teleport(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.Teleport");

	FTeleport parms{};	

	ProcessEvent(fn, &parms);
}

void UCheatManager::Summon(struct FString ClassName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.Summon");

	FSummon parms{};	
	parms.ClassName = ClassName;

	ProcessEvent(fn, &parms);
}

void UCheatManager::StreamLevelOut(struct FName PackageName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.StreamLevelOut");

	FStreamLevelOut parms{};	
	parms.PackageName = PackageName;

	ProcessEvent(fn, &parms);
}

void UCheatManager::StreamLevelIn(struct FName PackageName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.StreamLevelIn");

	FStreamLevelIn parms{};	
	parms.PackageName = PackageName;

	ProcessEvent(fn, &parms);
}

void UCheatManager::SpawnServerStatReplicator(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.SpawnServerStatReplicator");

	FSpawnServerStatReplicator parms{};	

	ProcessEvent(fn, &parms);
}

void UCheatManager::Slomo(float NewTimeDilation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.Slomo");

	FSlomo parms{};	
	parms.NewTimeDilation = NewTimeDilation;

	ProcessEvent(fn, &parms);
}

void UCheatManager::SetWorldOrigin(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.SetWorldOrigin");

	FSetWorldOrigin parms{};	

	ProcessEvent(fn, &parms);
}

void UCheatManager::SetMouseSensitivityToDefault(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.SetMouseSensitivityToDefault");

	FSetMouseSensitivityToDefault parms{};	

	ProcessEvent(fn, &parms);
}

void UCheatManager::ServerToggleAILogging(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.ServerToggleAILogging");

	FServerToggleAILogging parms{};	

	ProcessEvent(fn, &parms);
}

void UCheatManager::ReceiveInitCheatManager(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.ReceiveInitCheatManager");

	FReceiveInitCheatManager parms{};	

	ProcessEvent(fn, &parms);
}

void UCheatManager::ReceiveEndPlay(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.ReceiveEndPlay");

	FReceiveEndPlay parms{};	

	ProcessEvent(fn, &parms);
}

void UCheatManager::PlayersOnly(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.PlayersOnly");

	FPlayersOnly parms{};	

	ProcessEvent(fn, &parms);
}

void UCheatManager::OnPlayerEndPlayed(struct AActor* Player, enum class EEndPlayReason EndPlayReason){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.OnPlayerEndPlayed");

	FOnPlayerEndPlayed parms{};	
	parms.Player = Player;
	parms.EndPlayReason = EndPlayReason;

	ProcessEvent(fn, &parms);
}

void UCheatManager::OnlyLoadLevel(struct FName PackageName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.OnlyLoadLevel");

	FOnlyLoadLevel parms{};	
	parms.PackageName = PackageName;

	ProcessEvent(fn, &parms);
}

void UCheatManager::LogLoc(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.LogLoc");

	FLogLoc parms{};	

	ProcessEvent(fn, &parms);
}

void UCheatManager::InvertMouse(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.InvertMouse");

	FInvertMouse parms{};	

	ProcessEvent(fn, &parms);
}

void UCheatManager::God(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.God");

	FGod parms{};	

	ProcessEvent(fn, &parms);
}

void UCheatManager::Ghost(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.Ghost");

	FGhost parms{};	

	ProcessEvent(fn, &parms);
}

struct APlayerController* UCheatManager::GetPlayerController(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.GetPlayerController");

	FGetPlayerController parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UCheatManager::FreezeFrame(float Delay){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.FreezeFrame");

	FFreezeFrame parms{};	
	parms.Delay = Delay;

	ProcessEvent(fn, &parms);
}

void UCheatManager::Fly(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.Fly");

	FFly parms{};	

	ProcessEvent(fn, &parms);
}

void UCheatManager::FlushLog(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.FlushLog");

	FFlushLog parms{};	

	ProcessEvent(fn, &parms);
}

void UCheatManager::EnableDebugCamera(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.EnableDebugCamera");

	FEnableDebugCamera parms{};	

	ProcessEvent(fn, &parms);
}

void UCheatManager::DumpVoiceMutingState(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.DumpVoiceMutingState");

	FDumpVoiceMutingState parms{};	

	ProcessEvent(fn, &parms);
}

void UCheatManager::DumpPartyState(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.DumpPartyState");

	FDumpPartyState parms{};	

	ProcessEvent(fn, &parms);
}

void UCheatManager::DumpOnlineSessionState(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.DumpOnlineSessionState");

	FDumpOnlineSessionState parms{};	

	ProcessEvent(fn, &parms);
}

void UCheatManager::DumpChatState(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.DumpChatState");

	FDumpChatState parms{};	

	ProcessEvent(fn, &parms);
}

void UCheatManager::DisableDebugCamera(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.DisableDebugCamera");

	FDisableDebugCamera parms{};	

	ProcessEvent(fn, &parms);
}

void UCheatManager::DestroyTarget(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.DestroyTarget");

	FDestroyTarget parms{};	

	ProcessEvent(fn, &parms);
}

void UCheatManager::DestroyServerStatReplicator(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.DestroyServerStatReplicator");

	FDestroyServerStatReplicator parms{};	

	ProcessEvent(fn, &parms);
}

void UCheatManager::DestroyPawns(APawn* aClass){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.DestroyPawns");

	FDestroyPawns parms{};	
	parms.aClass = aClass;

	ProcessEvent(fn, &parms);
}

void UCheatManager::DestroyAllPawnsExceptTarget(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.DestroyAllPawnsExceptTarget");

	FDestroyAllPawnsExceptTarget parms{};	

	ProcessEvent(fn, &parms);
}

void UCheatManager::DestroyAll(AActor* aClass){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.DestroyAll");

	FDestroyAll parms{};	
	parms.aClass = aClass;

	ProcessEvent(fn, &parms);
}

void UCheatManager::DebugCapsuleSweepSize(float HalfHeight, float Radius){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.DebugCapsuleSweepSize");

	FDebugCapsuleSweepSize parms{};	
	parms.HalfHeight = HalfHeight;
	parms.Radius = Radius;

	ProcessEvent(fn, &parms);
}

void UCheatManager::DebugCapsuleSweepPawn(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.DebugCapsuleSweepPawn");

	FDebugCapsuleSweepPawn parms{};	

	ProcessEvent(fn, &parms);
}

void UCheatManager::DebugCapsuleSweepComplex(bool bTraceComplex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.DebugCapsuleSweepComplex");

	FDebugCapsuleSweepComplex parms{};	
	parms.bTraceComplex = bTraceComplex;

	ProcessEvent(fn, &parms);
}

void UCheatManager::DebugCapsuleSweepClear(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.DebugCapsuleSweepClear");

	FDebugCapsuleSweepClear parms{};	

	ProcessEvent(fn, &parms);
}

void UCheatManager::DebugCapsuleSweepChannel(enum class ECollisionChannel Channel){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.DebugCapsuleSweepChannel");

	FDebugCapsuleSweepChannel parms{};	
	parms.Channel = Channel;

	ProcessEvent(fn, &parms);
}

void UCheatManager::DebugCapsuleSweepCapture(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.DebugCapsuleSweepCapture");

	FDebugCapsuleSweepCapture parms{};	

	ProcessEvent(fn, &parms);
}

void UCheatManager::DebugCapsuleSweep(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.DebugCapsuleSweep");

	FDebugCapsuleSweep parms{};	

	ProcessEvent(fn, &parms);
}

void UCheatManager::DamageTarget(float DamageAmount){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.DamageTarget");

	FDamageTarget parms{};	
	parms.DamageAmount = DamageAmount;

	ProcessEvent(fn, &parms);
}

void UCheatManager::CheatScript(struct FString ScriptName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.CheatScript");

	FCheatScript parms{};	
	parms.ScriptName = ScriptName;

	ProcessEvent(fn, &parms);
}

void UCheatManager::ChangeSize(float F){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.ChangeSize");

	FChangeSize parms{};	
	parms.F = F;

	ProcessEvent(fn, &parms);
}

void UCheatManager::BugItStringCreator(struct FVector ViewLocation, struct FRotator ViewRotation, struct FString& GoString, struct FString& LocString){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.BugItStringCreator");

	FBugItStringCreator parms{};	
	parms.ViewLocation = ViewLocation;
	parms.ViewRotation = ViewRotation;
	parms.GoString = GoString;
	parms.LocString = LocString;

	ProcessEvent(fn, &parms);
}

void UCheatManager::BugItGo(float X, float Y, float Z, float Pitch, float Yaw, float Roll){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.BugItGo");

	FBugItGo parms{};	
	parms.X = X;
	parms.Y = Y;
	parms.Z = Z;
	parms.Pitch = Pitch;
	parms.Yaw = Yaw;
	parms.Roll = Roll;

	ProcessEvent(fn, &parms);
}

void UCheatManager::BugIt(struct FString ScreenShotDescription){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CheatManager.BugIt");

	FBugIt parms{};	
	parms.ScreenShotDescription = ScreenShotDescription;

	ProcessEvent(fn, &parms);
}

void UBillboardComponent::SetUV(int32_t NewU, int32_t NewUL, int32_t NewV, int32_t NewVL){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BillboardComponent.SetUV");

	FSetUV parms{};	
	parms.NewU = NewU;
	parms.NewUL = NewUL;
	parms.NewV = NewV;
	parms.NewVL = NewVL;

	ProcessEvent(fn, &parms);
}

void UBillboardComponent::SetSpriteAndUV(struct UTexture2D* NewSprite, int32_t NewU, int32_t NewUL, int32_t NewV, int32_t NewVL){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BillboardComponent.SetSpriteAndUV");

	FSetSpriteAndUV parms{};	
	parms.NewSprite = NewSprite;
	parms.NewU = NewU;
	parms.NewUL = NewUL;
	parms.NewV = NewV;
	parms.NewVL = NewVL;

	ProcessEvent(fn, &parms);
}

void UBillboardComponent::SetSprite(struct UTexture2D* NewSprite){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BillboardComponent.SetSprite");

	FSetSprite parms{};	
	parms.NewSprite = NewSprite;

	ProcessEvent(fn, &parms);
}

void UBillboardComponent::SetOpacityMaskRefVal(float RefVal){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.BillboardComponent.SetOpacityMaskRefVal");

	FSetOpacityMaskRefVal parms{};	
	parms.RefVal = RefVal;

	ProcessEvent(fn, &parms);
}

void UDecalComponent::SetSortOrder(int32_t Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DecalComponent.SetSortOrder");

	FSetSortOrder parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UDecalComponent::SetFadeScreenSize(float NewFadeScreenSize){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DecalComponent.SetFadeScreenSize");

	FSetFadeScreenSize parms{};	
	parms.NewFadeScreenSize = NewFadeScreenSize;

	ProcessEvent(fn, &parms);
}

void UDecalComponent::SetFadeOut(float StartDelay, float Duration, bool DestroyOwnerAfterFade){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DecalComponent.SetFadeOut");

	FSetFadeOut parms{};	
	parms.StartDelay = StartDelay;
	parms.Duration = Duration;
	parms.DestroyOwnerAfterFade = DestroyOwnerAfterFade;

	ProcessEvent(fn, &parms);
}

void UDecalComponent::SetFadeIn(float StartDelay, float Duaration){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DecalComponent.SetFadeIn");

	FSetFadeIn parms{};	
	parms.StartDelay = StartDelay;
	parms.Duaration = Duaration;

	ProcessEvent(fn, &parms);
}

void UDecalComponent::SetDecalMaterial(struct UMaterialInterface* NewDecalMaterial){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DecalComponent.SetDecalMaterial");

	FSetDecalMaterial parms{};	
	parms.NewDecalMaterial = NewDecalMaterial;

	ProcessEvent(fn, &parms);
}

float UDecalComponent::GetFadeStartDelay(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DecalComponent.GetFadeStartDelay");

	FGetFadeStartDelay parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UDecalComponent::GetFadeInStartDelay(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DecalComponent.GetFadeInStartDelay");

	FGetFadeInStartDelay parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UDecalComponent::GetFadeInDuration(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DecalComponent.GetFadeInDuration");

	FGetFadeInDuration parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UDecalComponent::GetFadeDuration(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DecalComponent.GetFadeDuration");

	FGetFadeDuration parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UMaterialInterface* UDecalComponent::GetDecalMaterial(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DecalComponent.GetDecalMaterial");

	FGetDecalMaterial parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UMaterialInstanceDynamic* UDecalComponent::CreateDynamicMaterialInstance(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DecalComponent.CreateDynamicMaterialInstance");

	FCreateDynamicMaterialInstance parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UDirectionalLightComponent::SetShadowSourceAngleFactor(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetShadowSourceAngleFactor");

	FSetShadowSourceAngleFactor parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UDirectionalLightComponent::SetShadowDistanceFadeoutFraction(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetShadowDistanceFadeoutFraction");

	FSetShadowDistanceFadeoutFraction parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UDirectionalLightComponent::SetShadowCascadeBiasDistribution(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetShadowCascadeBiasDistribution");

	FSetShadowCascadeBiasDistribution parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UDirectionalLightComponent::SetShadowAmount(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetShadowAmount");

	FSetShadowAmount parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UDirectionalLightComponent::SetOcclusionMaskDarkness(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetOcclusionMaskDarkness");

	FSetOcclusionMaskDarkness parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UDirectionalLightComponent::SetOcclusionDepthRange(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetOcclusionDepthRange");

	FSetOcclusionDepthRange parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UDirectionalLightComponent::SetLightSourceSoftAngle(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetLightSourceSoftAngle");

	FSetLightSourceSoftAngle parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UDirectionalLightComponent::SetLightSourceAngle(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetLightSourceAngle");

	FSetLightSourceAngle parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UDirectionalLightComponent::SetLightShaftOverrideDirection(struct FVector NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetLightShaftOverrideDirection");

	FSetLightShaftOverrideDirection parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UDirectionalLightComponent::SetEnableLightShaftOcclusion(bool bNewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetEnableLightShaftOcclusion");

	FSetEnableLightShaftOcclusion parms{};	
	parms.bNewValue = bNewValue;

	ProcessEvent(fn, &parms);
}

void UDirectionalLightComponent::SetDynamicShadowDistanceStationaryLight(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetDynamicShadowDistanceStationaryLight");

	FSetDynamicShadowDistanceStationaryLight parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UDirectionalLightComponent::SetDynamicShadowDistanceMovableLight(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetDynamicShadowDistanceMovableLight");

	FSetDynamicShadowDistanceMovableLight parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UDirectionalLightComponent::SetDynamicShadowCascades(int32_t NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetDynamicShadowCascades");

	FSetDynamicShadowCascades parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UDirectionalLightComponent::SetCascadeTransitionFraction(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetCascadeTransitionFraction");

	FSetCascadeTransitionFraction parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UDirectionalLightComponent::SetCascadeDistributionExponent(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetCascadeDistributionExponent");

	FSetCascadeDistributionExponent parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UDirectionalLightComponent::SetAtmosphereSunLightIndex(int32_t NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetAtmosphereSunLightIndex");

	FSetAtmosphereSunLightIndex parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UDirectionalLightComponent::SetAtmosphereSunLight(bool bNewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetAtmosphereSunLight");

	FSetAtmosphereSunLight parms{};	
	parms.bNewValue = bNewValue;

	ProcessEvent(fn, &parms);
}

void USphereComponent::SetSphereRadius(float InSphereRadius, bool bUpdateOverlaps){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SphereComponent.SetSphereRadius");

	FSetSphereRadius parms{};	
	parms.InSphereRadius = InSphereRadius;
	parms.bUpdateOverlaps = bUpdateOverlaps;

	ProcessEvent(fn, &parms);
}

float USphereComponent::GetUnscaledSphereRadius(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SphereComponent.GetUnscaledSphereRadius");

	FGetUnscaledSphereRadius parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float USphereComponent::GetShapeScale(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SphereComponent.GetShapeScale");

	FGetShapeScale parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float USphereComponent::GetScaledSphereRadius(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SphereComponent.GetScaledSphereRadius");

	FGetScaledSphereRadius parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UForceFeedbackComponent::Stop(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ForceFeedbackComponent.Stop");

	FStop parms{};	

	ProcessEvent(fn, &parms);
}

void UForceFeedbackComponent::SetIntensityMultiplier(float NewIntensityMultiplier){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ForceFeedbackComponent.SetIntensityMultiplier");

	FSetIntensityMultiplier parms{};	
	parms.NewIntensityMultiplier = NewIntensityMultiplier;

	ProcessEvent(fn, &parms);
}

void UForceFeedbackComponent::SetForceFeedbackEffect(struct UForceFeedbackEffect* NewForceFeedbackEffect){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ForceFeedbackComponent.SetForceFeedbackEffect");

	FSetForceFeedbackEffect parms{};	
	parms.NewForceFeedbackEffect = NewForceFeedbackEffect;

	ProcessEvent(fn, &parms);
}

void UForceFeedbackComponent::Play(float StartTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ForceFeedbackComponent.Play");

	FPlay parms{};	
	parms.StartTime = StartTime;

	ProcessEvent(fn, &parms);
}

bool UForceFeedbackComponent::BP_GetAttenuationSettingsToApply(struct FForceFeedbackAttenuationSettings& OutAttenuationSettings){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ForceFeedbackComponent.BP_GetAttenuationSettingsToApply");

	FBP_GetAttenuationSettingsToApply parms{};	
	parms.OutAttenuationSettings = OutAttenuationSettings;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UForceFeedbackComponent::AdjustAttenuation(struct FForceFeedbackAttenuationSettings& InAttenuationSettings){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ForceFeedbackComponent.AdjustAttenuation");

	FAdjustAttenuation parms{};	
	parms.InAttenuationSettings = InAttenuationSettings;

	ProcessEvent(fn, &parms);
}

void UInterpToMovementComponent::StopSimulating(struct FHitResult& HitResult){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InterpToMovementComponent.StopSimulating");

	FStopSimulating parms{};	
	parms.HitResult = HitResult;

	ProcessEvent(fn, &parms);
}

void UInterpToMovementComponent::RestartMovement(float InitialDirection){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InterpToMovementComponent.RestartMovement");

	FRestartMovement parms{};	
	parms.InitialDirection = InitialDirection;

	ProcessEvent(fn, &parms);
}

void UInterpToMovementComponent::ResetControlPoints(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InterpToMovementComponent.ResetControlPoints");

	FResetControlPoints parms{};	

	ProcessEvent(fn, &parms);
}

void UInterpToMovementComponent::OnInterpToWaitEndDelegate__DelegateSignature(struct FHitResult& ImpactResult, float Time){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("DelegateFunction Engine.InterpToMovementComponent.OnInterpToWaitEndDelegate__DelegateSignature");

	FOnInterpToWaitEndDelegate__DelegateSignature parms{};	
	parms.ImpactResult = ImpactResult;
	parms.Time = Time;

	ProcessEvent(fn, &parms);
}

void UInterpToMovementComponent::OnInterpToWaitBeginDelegate__DelegateSignature(struct FHitResult& ImpactResult, float Time){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("DelegateFunction Engine.InterpToMovementComponent.OnInterpToWaitBeginDelegate__DelegateSignature");

	FOnInterpToWaitBeginDelegate__DelegateSignature parms{};	
	parms.ImpactResult = ImpactResult;
	parms.Time = Time;

	ProcessEvent(fn, &parms);
}

void UInterpToMovementComponent::OnInterpToStopDelegate__DelegateSignature(struct FHitResult& ImpactResult, float Time){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("DelegateFunction Engine.InterpToMovementComponent.OnInterpToStopDelegate__DelegateSignature");

	FOnInterpToStopDelegate__DelegateSignature parms{};	
	parms.ImpactResult = ImpactResult;
	parms.Time = Time;

	ProcessEvent(fn, &parms);
}

void UInterpToMovementComponent::OnInterpToReverseDelegate__DelegateSignature(struct FHitResult& ImpactResult, float Time){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("DelegateFunction Engine.InterpToMovementComponent.OnInterpToReverseDelegate__DelegateSignature");

	FOnInterpToReverseDelegate__DelegateSignature parms{};	
	parms.ImpactResult = ImpactResult;
	parms.Time = Time;

	ProcessEvent(fn, &parms);
}

void UInterpToMovementComponent::OnInterpToResetDelegate__DelegateSignature(struct FHitResult& ImpactResult, float Time){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("DelegateFunction Engine.InterpToMovementComponent.OnInterpToResetDelegate__DelegateSignature");

	FOnInterpToResetDelegate__DelegateSignature parms{};	
	parms.ImpactResult = ImpactResult;
	parms.Time = Time;

	ProcessEvent(fn, &parms);
}

void UInterpToMovementComponent::FinaliseControlPoints(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InterpToMovementComponent.FinaliseControlPoints");

	FFinaliseControlPoints parms{};	

	ProcessEvent(fn, &parms);
}

void UInterpToMovementComponent::AddControlPointPosition(struct FVector Pos, bool bPositionIsRelative){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.InterpToMovementComponent.AddControlPointPosition");

	FAddControlPointPosition parms{};	
	parms.Pos = Pos;
	parms.bPositionIsRelative = bPositionIsRelative;

	ProcessEvent(fn, &parms);
}

void UPostProcessComponent::AddOrUpdateBlendable(struct TScriptInterface<IBlendableInterface> InBlendableObject, float InWeight){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PostProcessComponent.AddOrUpdateBlendable");

	FAddOrUpdateBlendable parms{};	
	parms.InBlendableObject = InBlendableObject;
	parms.InWeight = InWeight;

	ProcessEvent(fn, &parms);
}

void ULocalLightComponent::SetIntensityUnits(uint8_t NewIntensityUnits){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LocalLightComponent.SetIntensityUnits");

	FSetIntensityUnits parms{};	
	parms.NewIntensityUnits = NewIntensityUnits;

	ProcessEvent(fn, &parms);
}

void ULocalLightComponent::SetAttenuationRadius(float NewRadius){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LocalLightComponent.SetAttenuationRadius");

	FSetAttenuationRadius parms{};	
	parms.NewRadius = NewRadius;

	ProcessEvent(fn, &parms);
}

float ULocalLightComponent::GetUnitsConversionFactor(uint8_t SrcUnits, uint8_t TargetUnits, float CosHalfConeAngle){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LocalLightComponent.GetUnitsConversionFactor");

	FGetUnitsConversionFactor parms{};	
	parms.SrcUnits = SrcUnits;
	parms.TargetUnits = TargetUnits;
	parms.CosHalfConeAngle = CosHalfConeAngle;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString ULODSyncComponent::GetLODSyncDebugText(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LODSyncComponent.GetLODSyncDebugText");

	FGetLODSyncDebugText parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UMaterialBillboardComponent::SetElements(struct TArray<struct FMaterialSpriteElement>& NewElements){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MaterialBillboardComponent.SetElements");

	FSetElements parms{};	
	parms.NewElements = NewElements;

	ProcessEvent(fn, &parms);
}

void UMaterialBillboardComponent::AddElement(struct UMaterialInterface* Material, struct UCurveFloat* DistanceToOpacityCurve, bool bSizeIsInScreenSpace, float BaseSizeX, float BaseSizeY, struct UCurveFloat* DistanceToSizeCurve){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MaterialBillboardComponent.AddElement");

	FAddElement parms{};	
	parms.Material = Material;
	parms.DistanceToOpacityCurve = DistanceToOpacityCurve;
	parms.bSizeIsInScreenSpace = bSizeIsInScreenSpace;
	parms.BaseSizeX = BaseSizeX;
	parms.BaseSizeY = BaseSizeY;
	parms.DistanceToSizeCurve = DistanceToSizeCurve;

	ProcessEvent(fn, &parms);
}

void UPawnNoiseEmitterComponent::MakeNoise(struct AActor* NoiseMaker, float Loudness, struct FVector& NoiseLocation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PawnNoiseEmitterComponent.MakeNoise");

	FMakeNoise parms{};	
	parms.NoiseMaker = NoiseMaker;
	parms.Loudness = Loudness;
	parms.NoiseLocation = NoiseLocation;

	ProcessEvent(fn, &parms);
}

void UPointLightComponent::SetUseInverseSquaredFalloff(bool bNewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PointLightComponent.SetUseInverseSquaredFalloff");

	FSetUseInverseSquaredFalloff parms{};	
	parms.bNewValue = bNewValue;

	ProcessEvent(fn, &parms);
}

void UPointLightComponent::SetSourceRadius(float bNewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PointLightComponent.SetSourceRadius");

	FSetSourceRadius parms{};	
	parms.bNewValue = bNewValue;

	ProcessEvent(fn, &parms);
}

void UPointLightComponent::SetSourceLength(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PointLightComponent.SetSourceLength");

	FSetSourceLength parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void UPointLightComponent::SetSoftSourceRadius(float bNewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PointLightComponent.SetSoftSourceRadius");

	FSetSoftSourceRadius parms{};	
	parms.bNewValue = bNewValue;

	ProcessEvent(fn, &parms);
}

void UPointLightComponent::SetLightFalloffExponent(float NewLightFalloffExponent){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PointLightComponent.SetLightFalloffExponent");

	FSetLightFalloffExponent parms{};	
	parms.NewLightFalloffExponent = NewLightFalloffExponent;

	ProcessEvent(fn, &parms);
}

void UPointLightComponent::SetInverseExposureBlend(float NewInverseExposureBlend){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PointLightComponent.SetInverseExposureBlend");

	FSetInverseExposureBlend parms{};	
	parms.NewInverseExposureBlend = NewInverseExposureBlend;

	ProcessEvent(fn, &parms);
}

void URectLightComponent::SetSourceWidth(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.RectLightComponent.SetSourceWidth");

	FSetSourceWidth parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void URectLightComponent::SetSourceTexture(struct UTexture* NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.RectLightComponent.SetSourceTexture");

	FSetSourceTexture parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void URectLightComponent::SetSourceHeight(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.RectLightComponent.SetSourceHeight");

	FSetSourceHeight parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void URectLightComponent::SetBarnDoorLength(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.RectLightComponent.SetBarnDoorLength");

	FSetBarnDoorLength parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void URectLightComponent::SetBarnDoorAngle(float NewValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.RectLightComponent.SetBarnDoorAngle");

	FSetBarnDoorAngle parms{};	
	parms.NewValue = NewValue;

	ProcessEvent(fn, &parms);
}

void USpotLightComponent::SetOuterConeAngle(float NewOuterConeAngle){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SpotLightComponent.SetOuterConeAngle");

	FSetOuterConeAngle parms{};	
	parms.NewOuterConeAngle = NewOuterConeAngle;

	ProcessEvent(fn, &parms);
}

void USpotLightComponent::SetInnerConeAngle(float NewInnerConeAngle){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SpotLightComponent.SetInnerConeAngle");

	FSetInnerConeAngle parms{};	
	parms.NewInnerConeAngle = NewInnerConeAngle;

	ProcessEvent(fn, &parms);
}

bool UWorldPartitionStreamingSourceComponent::IsStreamingSourceEnabled(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.WorldPartitionStreamingSourceComponent.IsStreamingSourceEnabled");

	FIsStreamingSourceEnabled parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UWorldPartitionStreamingSourceComponent::IsStreamingCompleted(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.WorldPartitionStreamingSourceComponent.IsStreamingCompleted");

	FIsStreamingCompleted parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UWorldPartitionStreamingSourceComponent::EnableStreamingSource(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.WorldPartitionStreamingSourceComponent.EnableStreamingSource");

	FEnableStreamingSource parms{};	

	ProcessEvent(fn, &parms);
}

void UWorldPartitionStreamingSourceComponent::DisableStreamingSource(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.WorldPartitionStreamingSourceComponent.DisableStreamingSource");

	FDisableStreamingSource parms{};	

	ProcessEvent(fn, &parms);
}

void UCurveBase::GetValueRange(float& MinValue, float& MaxValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CurveBase.GetValueRange");

	FGetValueRange parms{};	
	parms.MinValue = MinValue;
	parms.MaxValue = MaxValue;

	ProcessEvent(fn, &parms);
}

void UCurveBase::GetTimeRange(float& MinTime, float& MaxTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CurveBase.GetTimeRange");

	FGetTimeRange parms{};	
	parms.MinTime = MinTime;
	parms.MaxTime = MaxTime;

	ProcessEvent(fn, &parms);
}

void USoundSubmix::StopSpectralAnalysis(struct UObject* WorldContextObject){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SoundSubmix.StopSpectralAnalysis");

	FStopSpectralAnalysis parms{};	
	parms.WorldContextObject = WorldContextObject;

	ProcessEvent(fn, &parms);
}

void USoundSubmix::StopRecordingOutput(struct UObject* WorldContextObject, uint8_t ExportType, struct FString Name, struct FString Path, struct USoundWave* ExistingSoundWaveToOverwrite){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SoundSubmix.StopRecordingOutput");

	FStopRecordingOutput parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.ExportType = ExportType;
	parms.Name = Name;
	parms.Path = Path;
	parms.ExistingSoundWaveToOverwrite = ExistingSoundWaveToOverwrite;

	ProcessEvent(fn, &parms);
}

void USoundSubmix::StopEnvelopeFollowing(struct UObject* WorldContextObject){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SoundSubmix.StopEnvelopeFollowing");

	FStopEnvelopeFollowing parms{};	
	parms.WorldContextObject = WorldContextObject;

	ProcessEvent(fn, &parms);
}

void USoundSubmix::StartSpectralAnalysis(struct UObject* WorldContextObject, uint8_t FFTSize, uint8_t InterpolationMethod, uint8_t WindowType, float HopSize, uint8_t SpectrumType){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SoundSubmix.StartSpectralAnalysis");

	FStartSpectralAnalysis parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.FFTSize = FFTSize;
	parms.InterpolationMethod = InterpolationMethod;
	parms.WindowType = WindowType;
	parms.HopSize = HopSize;
	parms.SpectrumType = SpectrumType;

	ProcessEvent(fn, &parms);
}

void USoundSubmix::StartRecordingOutput(struct UObject* WorldContextObject, float ExpectedDuration){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SoundSubmix.StartRecordingOutput");

	FStartRecordingOutput parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.ExpectedDuration = ExpectedDuration;

	ProcessEvent(fn, &parms);
}

void USoundSubmix::StartEnvelopeFollowing(struct UObject* WorldContextObject){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SoundSubmix.StartEnvelopeFollowing");

	FStartEnvelopeFollowing parms{};	
	parms.WorldContextObject = WorldContextObject;

	ProcessEvent(fn, &parms);
}

void USoundSubmix::SetSubmixWetLevel(struct UObject* WorldContextObject, float InWetLevel){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SoundSubmix.SetSubmixWetLevel");

	FSetSubmixWetLevel parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.InWetLevel = InWetLevel;

	ProcessEvent(fn, &parms);
}

void USoundSubmix::SetSubmixOutputVolume(struct UObject* WorldContextObject, float InOutputVolume){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SoundSubmix.SetSubmixOutputVolume");

	FSetSubmixOutputVolume parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.InOutputVolume = InOutputVolume;

	ProcessEvent(fn, &parms);
}

void USoundSubmix::SetSubmixDryLevel(struct UObject* WorldContextObject, float InDryLevel){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SoundSubmix.SetSubmixDryLevel");

	FSetSubmixDryLevel parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.InDryLevel = InDryLevel;

	ProcessEvent(fn, &parms);
}

void USoundSubmix::RemoveSpectralAnalysisDelegate(struct UObject* WorldContextObject, struct FDelegate& OnSubmixSpectralAnalysisBP){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SoundSubmix.RemoveSpectralAnalysisDelegate");

	FRemoveSpectralAnalysisDelegate parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.OnSubmixSpectralAnalysisBP = OnSubmixSpectralAnalysisBP;

	ProcessEvent(fn, &parms);
}

void USoundSubmix::AddSpectralAnalysisDelegate(struct UObject* WorldContextObject, struct TArray<struct FSoundSubmixSpectralAnalysisBandSettings>& InBandSettings, struct FDelegate& OnSubmixSpectralAnalysisBP, float UpdateRate, float DecibelNoiseFloor, bool bDoNormalize, bool bDoAutoRange, float AutoRangeAttackTime, float AutoRangeReleaseTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SoundSubmix.AddSpectralAnalysisDelegate");

	FAddSpectralAnalysisDelegate parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.InBandSettings = InBandSettings;
	parms.OnSubmixSpectralAnalysisBP = OnSubmixSpectralAnalysisBP;
	parms.UpdateRate = UpdateRate;
	parms.DecibelNoiseFloor = DecibelNoiseFloor;
	parms.bDoNormalize = bDoNormalize;
	parms.bDoAutoRange = bDoAutoRange;
	parms.AutoRangeAttackTime = AutoRangeAttackTime;
	parms.AutoRangeReleaseTime = AutoRangeReleaseTime;

	ProcessEvent(fn, &parms);
}

void USoundSubmix::AddEnvelopeFollowerDelegate(struct UObject* WorldContextObject, struct FDelegate& OnSubmixEnvelopeBP){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SoundSubmix.AddEnvelopeFollowerDelegate");

	FAddEnvelopeFollowerDelegate parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.OnSubmixEnvelopeBP = OnSubmixEnvelopeBP;

	ProcessEvent(fn, &parms);
}

float UCurveFloat::GetFloatValue(float InTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.CurveFloat.GetFloatValue");

	FGetFloatValue parms{};	
	parms.InTime = InTime;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UTypedElementWorldInterface::SetWorldTransform(struct FScriptTypedElementHandle& InElementHandle, struct FTransform& InTransform){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TypedElementWorldInterface.SetWorldTransform");

	FSetWorldTransform parms{};	
	parms.InElementHandle = InElementHandle;
	parms.InTransform = InTransform;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UTypedElementWorldInterface::SetRelativeTransform(struct FScriptTypedElementHandle& InElementHandle, struct FTransform& InTransform){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TypedElementWorldInterface.SetRelativeTransform");

	FSetRelativeTransform parms{};	
	parms.InElementHandle = InElementHandle;
	parms.InTransform = InTransform;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UTypedElementWorldInterface::SetPivotOffset(struct FScriptTypedElementHandle& InElementHandle, struct FVector& InPivotOffset){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TypedElementWorldInterface.SetPivotOffset");

	FSetPivotOffset parms{};	
	parms.InElementHandle = InElementHandle;
	parms.InPivotOffset = InPivotOffset;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FScriptTypedElementHandle UTypedElementWorldInterface::PromoteElement(struct FScriptTypedElementHandle& InElementHandle, struct UWorld* OverrideWorld){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TypedElementWorldInterface.PromoteElement");

	FPromoteElement parms{};	
	parms.InElementHandle = InElementHandle;
	parms.OverrideWorld = OverrideWorld;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UTypedElementWorldInterface::NotifyMovementStarted(struct FScriptTypedElementHandle& InElementHandle){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TypedElementWorldInterface.NotifyMovementStarted");

	FNotifyMovementStarted parms{};	
	parms.InElementHandle = InElementHandle;

	ProcessEvent(fn, &parms);
}

void UTypedElementWorldInterface::NotifyMovementOngoing(struct FScriptTypedElementHandle& InElementHandle){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TypedElementWorldInterface.NotifyMovementOngoing");

	FNotifyMovementOngoing parms{};	
	parms.InElementHandle = InElementHandle;

	ProcessEvent(fn, &parms);
}

void UTypedElementWorldInterface::NotifyMovementEnded(struct FScriptTypedElementHandle& InElementHandle){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TypedElementWorldInterface.NotifyMovementEnded");

	FNotifyMovementEnded parms{};	
	parms.InElementHandle = InElementHandle;

	ProcessEvent(fn, &parms);
}

bool UTypedElementWorldInterface::IsTemplateElement(struct FScriptTypedElementHandle& InElementHandle){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TypedElementWorldInterface.IsTemplateElement");

	FIsTemplateElement parms{};	
	parms.InElementHandle = InElementHandle;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UTypedElementWorldInterface::GetWorldTransform(struct FScriptTypedElementHandle& InElementHandle, struct FTransform& OutTransform){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TypedElementWorldInterface.GetWorldTransform");

	FGetWorldTransform parms{};	
	parms.InElementHandle = InElementHandle;
	parms.OutTransform = OutTransform;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UTypedElementWorldInterface::GetRelativeTransform(struct FScriptTypedElementHandle& InElementHandle, struct FTransform& OutTransform){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TypedElementWorldInterface.GetRelativeTransform");

	FGetRelativeTransform parms{};	
	parms.InElementHandle = InElementHandle;
	parms.OutTransform = OutTransform;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UTypedElementWorldInterface::GetPivotOffset(struct FScriptTypedElementHandle& InElementHandle, struct FVector& OutPivotOffset){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TypedElementWorldInterface.GetPivotOffset");

	FGetPivotOffset parms{};	
	parms.InElementHandle = InElementHandle;
	parms.OutPivotOffset = OutPivotOffset;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UWorld* UTypedElementWorldInterface::GetOwnerWorld(struct FScriptTypedElementHandle& InElementHandle){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TypedElementWorldInterface.GetOwnerWorld");

	FGetOwnerWorld parms{};	
	parms.InElementHandle = InElementHandle;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct ULevel* UTypedElementWorldInterface::GetOwnerLevel(struct FScriptTypedElementHandle& InElementHandle){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TypedElementWorldInterface.GetOwnerLevel");

	FGetOwnerLevel parms{};	
	parms.InElementHandle = InElementHandle;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UTypedElementWorldInterface::GetBounds(struct FScriptTypedElementHandle& InElementHandle, struct FBoxSphereBounds& OutBounds){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TypedElementWorldInterface.GetBounds");

	FGetBounds parms{};	
	parms.InElementHandle = InElementHandle;
	parms.OutBounds = OutBounds;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FScriptTypedElementHandle UTypedElementWorldInterface::DuplicateElement(struct FScriptTypedElementHandle& InElementHandle, struct UWorld* InWorld, struct FVector& InLocationOffset){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TypedElementWorldInterface.DuplicateElement");

	FDuplicateElement parms{};	
	parms.InElementHandle = InElementHandle;
	parms.InWorld = InWorld;
	parms.InLocationOffset = InLocationOffset;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UTypedElementWorldInterface::DeleteElement(struct FScriptTypedElementHandle& InElementHandle, struct UWorld* InWorld, struct UTypedElementSelectionSet* InSelectionSet, struct FTypedElementDeletionOptions& InDeletionOptions){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TypedElementWorldInterface.DeleteElement");

	FDeleteElement parms{};	
	parms.InElementHandle = InElementHandle;
	parms.InWorld = InWorld;
	parms.InSelectionSet = InSelectionSet;
	parms.InDeletionOptions = InDeletionOptions;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UTypedElementWorldInterface::CanPromoteElement(struct FScriptTypedElementHandle& InElementHandle){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TypedElementWorldInterface.CanPromoteElement");

	FCanPromoteElement parms{};	
	parms.InElementHandle = InElementHandle;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UTypedElementWorldInterface::CanMoveElement(struct FScriptTypedElementHandle& InElementHandle, uint8_t InWorldType){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TypedElementWorldInterface.CanMoveElement");

	FCanMoveElement parms{};	
	parms.InElementHandle = InElementHandle;
	parms.InWorldType = InWorldType;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UTypedElementWorldInterface::CanEditElement(struct FScriptTypedElementHandle& InElementHandle){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TypedElementWorldInterface.CanEditElement");

	FCanEditElement parms{};	
	parms.InElementHandle = InElementHandle;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UTypedElementWorldInterface::CanDuplicateElement(struct FScriptTypedElementHandle& InElementHandle){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TypedElementWorldInterface.CanDuplicateElement");

	FCanDuplicateElement parms{};	
	parms.InElementHandle = InElementHandle;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UTypedElementWorldInterface::CanDeleteElement(struct FScriptTypedElementHandle& InElementHandle){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.TypedElementWorldInterface.CanDeleteElement");

	FCanDeleteElement parms{};	
	parms.InElementHandle = InElementHandle;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UAsyncActionHandleSaveGame* UAsyncActionHandleSaveGame::AsyncSaveGameToSlot(struct UObject* WorldContextObject, struct USaveGame* SaveGameObject, struct FString SlotName, int32_t UserIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AsyncActionHandleSaveGame.AsyncSaveGameToSlot");

	FAsyncSaveGameToSlot parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.SaveGameObject = SaveGameObject;
	parms.SlotName = SlotName;
	parms.UserIndex = UserIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UAsyncActionHandleSaveGame* UAsyncActionHandleSaveGame::AsyncLoadGameFromSlot(struct UObject* WorldContextObject, struct FString SlotName, int32_t UserIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AsyncActionHandleSaveGame.AsyncLoadGameFromSlot");

	FAsyncLoadGameFromSlot parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.SlotName = SlotName;
	parms.UserIndex = UserIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool USpringArmComponent::IsCollisionFixApplied(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SpringArmComponent.IsCollisionFixApplied");

	FIsCollisionFixApplied parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector USpringArmComponent::GetUnfixedCameraPosition(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SpringArmComponent.GetUnfixedCameraPosition");

	FGetUnfixedCameraPosition parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FRotator USpringArmComponent::GetTargetRotation(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SpringArmComponent.GetTargetRotation");

	FGetTargetRotation parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetInternationalizationLibrary::SetCurrentLocale(struct FString culture, bool SaveToConfig){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.SetCurrentLocale");

	FSetCurrentLocale parms{};	
	parms.culture = culture;
	parms.SaveToConfig = SaveToConfig;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetInternationalizationLibrary::SetCurrentLanguageAndLocale(struct FString culture, bool SaveToConfig){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.SetCurrentLanguageAndLocale");

	FSetCurrentLanguageAndLocale parms{};	
	parms.culture = culture;
	parms.SaveToConfig = SaveToConfig;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetInternationalizationLibrary::SetCurrentLanguage(struct FString culture, bool SaveToConfig){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.SetCurrentLanguage");

	FSetCurrentLanguage parms{};	
	parms.culture = culture;
	parms.SaveToConfig = SaveToConfig;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetInternationalizationLibrary::SetCurrentCulture(struct FString culture, bool SaveToConfig){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.SetCurrentCulture");

	FSetCurrentCulture parms{};	
	parms.culture = culture;
	parms.SaveToConfig = SaveToConfig;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetInternationalizationLibrary::SetCurrentAssetGroupCulture(struct FName AssetGroup, struct FString culture, bool SaveToConfig){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.SetCurrentAssetGroupCulture");

	FSetCurrentAssetGroupCulture parms{};	
	parms.AssetGroup = AssetGroup;
	parms.culture = culture;
	parms.SaveToConfig = SaveToConfig;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetInternationalizationLibrary::GetSuitableCulture(struct TArray<struct FString>& AvailableCultures, struct FString CultureToMatch, struct FString FallbackCulture){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.GetSuitableCulture");

	FGetSuitableCulture parms{};	
	parms.AvailableCultures = AvailableCultures;
	parms.CultureToMatch = CultureToMatch;
	parms.FallbackCulture = FallbackCulture;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetInternationalizationLibrary::GetNativeCulture(uint8_t TextCategory){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.GetNativeCulture");

	FGetNativeCulture parms{};	
	parms.TextCategory = TextCategory;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<struct FString> UKismetInternationalizationLibrary::GetLocalizedCultures(bool IncludeGame, bool IncludeEngine, bool IncludeEditor, bool IncludeAdditional){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.GetLocalizedCultures");

	FGetLocalizedCultures parms{};	
	parms.IncludeGame = IncludeGame;
	parms.IncludeEngine = IncludeEngine;
	parms.IncludeEditor = IncludeEditor;
	parms.IncludeAdditional = IncludeAdditional;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetInternationalizationLibrary::GetCurrentLocale(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.GetCurrentLocale");

	FGetCurrentLocale parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetInternationalizationLibrary::GetCurrentLanguage(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.GetCurrentLanguage");

	FGetCurrentLanguage parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetInternationalizationLibrary::GetCurrentCulture(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.GetCurrentCulture");

	FGetCurrentCulture parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetInternationalizationLibrary::GetCurrentAssetGroupCulture(struct FName AssetGroup){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.GetCurrentAssetGroupCulture");

	FGetCurrentAssetGroupCulture parms{};	
	parms.AssetGroup = AssetGroup;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetInternationalizationLibrary::GetCultureDisplayName(struct FString culture, bool Localized){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.GetCultureDisplayName");

	FGetCultureDisplayName parms{};	
	parms.culture = culture;
	parms.Localized = Localized;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetInternationalizationLibrary::ClearCurrentAssetGroupCulture(struct FName AssetGroup, bool SaveToConfig){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.ClearCurrentAssetGroupCulture");

	FClearCurrentAssetGroupCulture parms{};	
	parms.AssetGroup = AssetGroup;
	parms.SaveToConfig = SaveToConfig;

	ProcessEvent(fn, &parms);
}

void UKismetRenderingLibrary::SetCastInsetShadowForAllAttachments(struct UPrimitiveComponent* PrimitiveComponent, bool bCastInsetShadow, bool bLightAttachmentsAsGroup){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.SetCastInsetShadowForAllAttachments");

	FSetCastInsetShadowForAllAttachments parms{};	
	parms.PrimitiveComponent = PrimitiveComponent;
	parms.bCastInsetShadow = bCastInsetShadow;
	parms.bLightAttachmentsAsGroup = bLightAttachmentsAsGroup;

	ProcessEvent(fn, &parms);
}

void UKismetRenderingLibrary::ResizeRenderTarget2D(struct UTextureRenderTarget2D* TextureRenderTarget, int32_t Width, int32_t Height){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ResizeRenderTarget2D");

	FResizeRenderTarget2D parms{};	
	parms.TextureRenderTarget = TextureRenderTarget;
	parms.Width = Width;
	parms.Height = Height;

	ProcessEvent(fn, &parms);
}

struct UTexture2D* UKismetRenderingLibrary::RenderTargetCreateStaticTexture2DEditorOnly(struct UTextureRenderTarget2D* RenderTarget, struct FString Name, enum class TextureCompressionSettings CompressionSettings, enum class TextureMipGenSettings MipSettings){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.RenderTargetCreateStaticTexture2DEditorOnly");

	FRenderTargetCreateStaticTexture2DEditorOnly parms{};	
	parms.RenderTarget = RenderTarget;
	parms.Name = Name;
	parms.CompressionSettings = CompressionSettings;
	parms.MipSettings = MipSettings;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetRenderingLibrary::ReleaseRenderTarget2D(struct UTextureRenderTarget2D* TextureRenderTarget){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ReleaseRenderTarget2D");

	FReleaseRenderTarget2D parms{};	
	parms.TextureRenderTarget = TextureRenderTarget;

	ProcessEvent(fn, &parms);
}

struct FColor UKismetRenderingLibrary::ReadRenderTargetUV(struct UObject* WorldContextObject, struct UTextureRenderTarget2D* TextureRenderTarget, float U, float V){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ReadRenderTargetUV");

	FReadRenderTargetUV parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.TextureRenderTarget = TextureRenderTarget;
	parms.U = U;
	parms.V = V;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<struct FLinearColor> UKismetRenderingLibrary::ReadRenderTargetRawUVArea(struct UObject* WorldContextObject, struct UTextureRenderTarget2D* TextureRenderTarget, struct FBox2D Area, bool bNormalize){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ReadRenderTargetRawUVArea");

	FReadRenderTargetRawUVArea parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.TextureRenderTarget = TextureRenderTarget;
	parms.Area = Area;
	parms.bNormalize = bNormalize;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FLinearColor UKismetRenderingLibrary::ReadRenderTargetRawUV(struct UObject* WorldContextObject, struct UTextureRenderTarget2D* TextureRenderTarget, float U, float V, bool bNormalize){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ReadRenderTargetRawUV");

	FReadRenderTargetRawUV parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.TextureRenderTarget = TextureRenderTarget;
	parms.U = U;
	parms.V = V;
	parms.bNormalize = bNormalize;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<struct FLinearColor> UKismetRenderingLibrary::ReadRenderTargetRawPixelArea(struct UObject* WorldContextObject, struct UTextureRenderTarget2D* TextureRenderTarget, int32_t MinX, int32_t MinY, int32_t MaxX, int32_t MaxY, bool bNormalize){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ReadRenderTargetRawPixelArea");

	FReadRenderTargetRawPixelArea parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.TextureRenderTarget = TextureRenderTarget;
	parms.MinX = MinX;
	parms.MinY = MinY;
	parms.MaxX = MaxX;
	parms.MaxY = MaxY;
	parms.bNormalize = bNormalize;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FLinearColor UKismetRenderingLibrary::ReadRenderTargetRawPixel(struct UObject* WorldContextObject, struct UTextureRenderTarget2D* TextureRenderTarget, int32_t X, int32_t Y, bool bNormalize){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ReadRenderTargetRawPixel");

	FReadRenderTargetRawPixel parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.TextureRenderTarget = TextureRenderTarget;
	parms.X = X;
	parms.Y = Y;
	parms.bNormalize = bNormalize;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetRenderingLibrary::ReadRenderTargetRaw(struct UObject* WorldContextObject, struct UTextureRenderTarget2D* TextureRenderTarget, struct TArray<struct FLinearColor>& OutLinearSamples, bool bNormalize){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ReadRenderTargetRaw");

	FReadRenderTargetRaw parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.TextureRenderTarget = TextureRenderTarget;
	parms.OutLinearSamples = OutLinearSamples;
	parms.bNormalize = bNormalize;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FColor UKismetRenderingLibrary::ReadRenderTargetPixel(struct UObject* WorldContextObject, struct UTextureRenderTarget2D* TextureRenderTarget, int32_t X, int32_t Y){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ReadRenderTargetPixel");

	FReadRenderTargetPixel parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.TextureRenderTarget = TextureRenderTarget;
	parms.X = X;
	parms.Y = Y;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetRenderingLibrary::ReadRenderTarget(struct UObject* WorldContextObject, struct UTextureRenderTarget2D* TextureRenderTarget, struct TArray<struct FColor>& OutSamples, bool bNormalize){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ReadRenderTarget");

	FReadRenderTarget parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.TextureRenderTarget = TextureRenderTarget;
	parms.OutSamples = OutSamples;
	parms.bNormalize = bNormalize;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FSkelMeshSkinWeightInfo UKismetRenderingLibrary::MakeSkinWeightInfo(int32_t Bone0, char Weight0, int32_t Bone1, char Weight1, int32_t Bone2, char Weight2, int32_t Bone3, char Weight3){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.MakeSkinWeightInfo");

	FMakeSkinWeightInfo parms{};	
	parms.Bone0 = Bone0;
	parms.Weight0 = Weight0;
	parms.Bone1 = Bone1;
	parms.Weight1 = Weight1;
	parms.Bone2 = Bone2;
	parms.Weight2 = Weight2;
	parms.Bone3 = Bone3;
	parms.Weight3 = Weight3;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UTexture2D* UKismetRenderingLibrary::ImportFileAsTexture2D(struct UObject* WorldContextObject, struct FString Filename){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ImportFileAsTexture2D");

	FImportFileAsTexture2D parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Filename = Filename;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UTexture2D* UKismetRenderingLibrary::ImportBufferAsTexture2D(struct UObject* WorldContextObject, struct TArray<char>& Buffer){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ImportBufferAsTexture2D");

	FImportBufferAsTexture2D parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Buffer = Buffer;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetRenderingLibrary::ExportTexture2D(struct UObject* WorldContextObject, struct UTexture2D* Texture, struct FString FilePath, struct FString Filename){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ExportTexture2D");

	FExportTexture2D parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Texture = Texture;
	parms.FilePath = FilePath;
	parms.Filename = Filename;

	ProcessEvent(fn, &parms);
}

void UKismetRenderingLibrary::ExportRenderTarget(struct UObject* WorldContextObject, struct UTextureRenderTarget2D* TextureRenderTarget, struct FString FilePath, struct FString Filename){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ExportRenderTarget");

	FExportRenderTarget parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.TextureRenderTarget = TextureRenderTarget;
	parms.FilePath = FilePath;
	parms.Filename = Filename;

	ProcessEvent(fn, &parms);
}

void UKismetRenderingLibrary::EndDrawCanvasToRenderTarget(struct UObject* WorldContextObject, struct FDrawToRenderTargetContext& Context){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.EndDrawCanvasToRenderTarget");

	FEndDrawCanvasToRenderTarget parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Context = Context;

	ProcessEvent(fn, &parms);
}

void UKismetRenderingLibrary::DrawMaterialToRenderTarget(struct UObject* WorldContextObject, struct UTextureRenderTarget2D* TextureRenderTarget, struct UMaterialInterface* Material){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.DrawMaterialToRenderTarget");

	FDrawMaterialToRenderTarget parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.TextureRenderTarget = TextureRenderTarget;
	parms.Material = Material;

	ProcessEvent(fn, &parms);
}

struct UTextureRenderTargetVolume* UKismetRenderingLibrary::CreateRenderTargetVolume(struct UObject* WorldContextObject, int32_t Width, int32_t Height, int32_t Depth, enum class ETextureRenderTargetFormat Format, struct FLinearColor ClearColor, bool bAutoGenerateMipMaps){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.CreateRenderTargetVolume");

	FCreateRenderTargetVolume parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Width = Width;
	parms.Height = Height;
	parms.Depth = Depth;
	parms.Format = Format;
	parms.ClearColor = ClearColor;
	parms.bAutoGenerateMipMaps = bAutoGenerateMipMaps;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UTextureRenderTarget2DArray* UKismetRenderingLibrary::CreateRenderTarget2DArray(struct UObject* WorldContextObject, int32_t Width, int32_t Height, int32_t Slices, enum class ETextureRenderTargetFormat Format, struct FLinearColor ClearColor, bool bAutoGenerateMipMaps){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.CreateRenderTarget2DArray");

	FCreateRenderTarget2DArray parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Width = Width;
	parms.Height = Height;
	parms.Slices = Slices;
	parms.Format = Format;
	parms.ClearColor = ClearColor;
	parms.bAutoGenerateMipMaps = bAutoGenerateMipMaps;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UTextureRenderTarget2D* UKismetRenderingLibrary::CreateRenderTarget2D(struct UObject* WorldContextObject, int32_t Width, int32_t Height, enum class ETextureRenderTargetFormat Format, struct FLinearColor ClearColor, bool bAutoGenerateMipMaps){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.CreateRenderTarget2D");

	FCreateRenderTarget2D parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Width = Width;
	parms.Height = Height;
	parms.Format = Format;
	parms.ClearColor = ClearColor;
	parms.bAutoGenerateMipMaps = bAutoGenerateMipMaps;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetRenderingLibrary::ConvertRenderTargetToTexture2DEditorOnly(struct UObject* WorldContextObject, struct UTextureRenderTarget2D* RenderTarget, struct UTexture2D* Texture){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ConvertRenderTargetToTexture2DEditorOnly");

	FConvertRenderTargetToTexture2DEditorOnly parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.RenderTarget = RenderTarget;
	parms.Texture = Texture;

	ProcessEvent(fn, &parms);
}

void UKismetRenderingLibrary::ClearRenderTarget2D(struct UObject* WorldContextObject, struct UTextureRenderTarget2D* TextureRenderTarget, struct FLinearColor ClearColor){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ClearRenderTarget2D");

	FClearRenderTarget2D parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.TextureRenderTarget = TextureRenderTarget;
	parms.ClearColor = ClearColor;

	ProcessEvent(fn, &parms);
}

struct FMatrix UKismetRenderingLibrary::CalculateProjectionMatrix(struct FMinimalViewInfo& MinimalViewInfo){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.CalculateProjectionMatrix");

	FCalculateProjectionMatrix parms{};	
	parms.MinimalViewInfo = MinimalViewInfo;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetRenderingLibrary::BreakSkinWeightInfo(struct FSkelMeshSkinWeightInfo InWeight, int32_t& Bone0, char& Weight0, int32_t& Bone1, char& Weight1, int32_t& Bone2, char& Weight2, int32_t& Bone3, char& Weight3){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.BreakSkinWeightInfo");

	FBreakSkinWeightInfo parms{};	
	parms.InWeight = InWeight;
	parms.Bone0 = Bone0;
	parms.Weight0 = Weight0;
	parms.Bone1 = Bone1;
	parms.Weight1 = Weight1;
	parms.Bone2 = Bone2;
	parms.Weight2 = Weight2;
	parms.Bone3 = Bone3;
	parms.Weight3 = Weight3;

	ProcessEvent(fn, &parms);
}

void UKismetRenderingLibrary::BeginDrawCanvasToRenderTarget(struct UObject* WorldContextObject, struct UTextureRenderTarget2D* TextureRenderTarget, struct UCanvas*& Canvas, struct FVector2D& Size, struct FDrawToRenderTargetContext& Context){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.BeginDrawCanvasToRenderTarget");

	FBeginDrawCanvasToRenderTarget parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.TextureRenderTarget = TextureRenderTarget;
	parms.Canvas = Canvas;
	parms.Size = Size;
	parms.Context = Context;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::UnregisterForRemoteNotifications(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.UnregisterForRemoteNotifications");

	FUnregisterForRemoteNotifications parms{};	

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::UnloadPrimaryAssetList(struct TArray<struct FPrimaryAssetId>& PrimaryAssetIdList){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.UnloadPrimaryAssetList");

	FUnloadPrimaryAssetList parms{};	
	parms.PrimaryAssetIdList = PrimaryAssetIdList;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::UnloadPrimaryAsset(struct FPrimaryAssetId PrimaryAssetId){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.UnloadPrimaryAsset");

	FUnloadPrimaryAsset parms{};	
	parms.PrimaryAssetId = PrimaryAssetId;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::TransactObject(struct UObject* Object){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.TransactObject");

	FTransactObject parms{};	
	parms.Object = Object;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::StackTrace(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.StackTrace");

	FStackTrace parms{};	

	ProcessEvent(fn, &parms);
}

bool UKismetSystemLibrary::SphereTraceSingleForObjects(struct UObject* WorldContextObject, struct FVector Start, struct FVector End, float Radius, struct TArray<enum class EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, struct TArray<struct AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, struct FHitResult& OutHit, bool bIgnoreSelf, struct FLinearColor TraceColor, struct FLinearColor TraceHitColor, float DrawTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereTraceSingleForObjects");

	FSphereTraceSingleForObjects parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Start = Start;
	parms.End = End;
	parms.Radius = Radius;
	parms.ObjectTypes = ObjectTypes;
	parms.bTraceComplex = bTraceComplex;
	parms.ActorsToIgnore = ActorsToIgnore;
	parms.DrawDebugType = DrawDebugType;
	parms.OutHit = OutHit;
	parms.bIgnoreSelf = bIgnoreSelf;
	parms.TraceColor = TraceColor;
	parms.TraceHitColor = TraceHitColor;
	parms.DrawTime = DrawTime;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::SphereTraceSingleByProfile(struct UObject* WorldContextObject, struct FVector Start, struct FVector End, float Radius, struct FName ProfileName, bool bTraceComplex, struct TArray<struct AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, struct FHitResult& OutHit, bool bIgnoreSelf, struct FLinearColor TraceColor, struct FLinearColor TraceHitColor, float DrawTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereTraceSingleByProfile");

	FSphereTraceSingleByProfile parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Start = Start;
	parms.End = End;
	parms.Radius = Radius;
	parms.ProfileName = ProfileName;
	parms.bTraceComplex = bTraceComplex;
	parms.ActorsToIgnore = ActorsToIgnore;
	parms.DrawDebugType = DrawDebugType;
	parms.OutHit = OutHit;
	parms.bIgnoreSelf = bIgnoreSelf;
	parms.TraceColor = TraceColor;
	parms.TraceHitColor = TraceHitColor;
	parms.DrawTime = DrawTime;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::SphereTraceSingle(struct UObject* WorldContextObject, struct FVector Start, struct FVector End, float Radius, enum class ETraceTypeQuery TraceChannel, bool bTraceComplex, struct TArray<struct AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, struct FHitResult& OutHit, bool bIgnoreSelf, struct FLinearColor TraceColor, struct FLinearColor TraceHitColor, float DrawTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereTraceSingle");

	FSphereTraceSingle parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Start = Start;
	parms.End = End;
	parms.Radius = Radius;
	parms.TraceChannel = TraceChannel;
	parms.bTraceComplex = bTraceComplex;
	parms.ActorsToIgnore = ActorsToIgnore;
	parms.DrawDebugType = DrawDebugType;
	parms.OutHit = OutHit;
	parms.bIgnoreSelf = bIgnoreSelf;
	parms.TraceColor = TraceColor;
	parms.TraceHitColor = TraceHitColor;
	parms.DrawTime = DrawTime;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::SphereTraceMultiForObjects(struct UObject* WorldContextObject, struct FVector Start, struct FVector End, float Radius, struct TArray<enum class EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, struct TArray<struct AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, struct TArray<struct FHitResult>& OutHits, bool bIgnoreSelf, struct FLinearColor TraceColor, struct FLinearColor TraceHitColor, float DrawTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereTraceMultiForObjects");

	FSphereTraceMultiForObjects parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Start = Start;
	parms.End = End;
	parms.Radius = Radius;
	parms.ObjectTypes = ObjectTypes;
	parms.bTraceComplex = bTraceComplex;
	parms.ActorsToIgnore = ActorsToIgnore;
	parms.DrawDebugType = DrawDebugType;
	parms.OutHits = OutHits;
	parms.bIgnoreSelf = bIgnoreSelf;
	parms.TraceColor = TraceColor;
	parms.TraceHitColor = TraceHitColor;
	parms.DrawTime = DrawTime;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::SphereTraceMultiByProfile(struct UObject* WorldContextObject, struct FVector Start, struct FVector End, float Radius, struct FName ProfileName, bool bTraceComplex, struct TArray<struct AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, struct TArray<struct FHitResult>& OutHits, bool bIgnoreSelf, struct FLinearColor TraceColor, struct FLinearColor TraceHitColor, float DrawTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereTraceMultiByProfile");

	FSphereTraceMultiByProfile parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Start = Start;
	parms.End = End;
	parms.Radius = Radius;
	parms.ProfileName = ProfileName;
	parms.bTraceComplex = bTraceComplex;
	parms.ActorsToIgnore = ActorsToIgnore;
	parms.DrawDebugType = DrawDebugType;
	parms.OutHits = OutHits;
	parms.bIgnoreSelf = bIgnoreSelf;
	parms.TraceColor = TraceColor;
	parms.TraceHitColor = TraceHitColor;
	parms.DrawTime = DrawTime;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::SphereTraceMulti(struct UObject* WorldContextObject, struct FVector Start, struct FVector End, float Radius, enum class ETraceTypeQuery TraceChannel, bool bTraceComplex, struct TArray<struct AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, struct TArray<struct FHitResult>& OutHits, bool bIgnoreSelf, struct FLinearColor TraceColor, struct FLinearColor TraceHitColor, float DrawTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereTraceMulti");

	FSphereTraceMulti parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Start = Start;
	parms.End = End;
	parms.Radius = Radius;
	parms.TraceChannel = TraceChannel;
	parms.bTraceComplex = bTraceComplex;
	parms.ActorsToIgnore = ActorsToIgnore;
	parms.DrawDebugType = DrawDebugType;
	parms.OutHits = OutHits;
	parms.bIgnoreSelf = bIgnoreSelf;
	parms.TraceColor = TraceColor;
	parms.TraceHitColor = TraceHitColor;
	parms.DrawTime = DrawTime;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::SphereOverlapComponents(struct UObject* WorldContextObject, struct FVector SpherePos, float SphereRadius, struct TArray<enum class EObjectTypeQuery>& ObjectTypes, UObject* ComponentClassFilter, struct TArray<struct AActor*>& ActorsToIgnore, struct TArray<struct UPrimitiveComponent*>& OutComponents){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereOverlapComponents");

	FSphereOverlapComponents parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.SpherePos = SpherePos;
	parms.SphereRadius = SphereRadius;
	parms.ObjectTypes = ObjectTypes;
	parms.ComponentClassFilter = ComponentClassFilter;
	parms.ActorsToIgnore = ActorsToIgnore;
	parms.OutComponents = OutComponents;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::SphereOverlapActors(struct UObject* WorldContextObject, struct FVector SpherePos, float SphereRadius, struct TArray<enum class EObjectTypeQuery>& ObjectTypes, UObject* ActorClassFilter, struct TArray<struct AActor*>& ActorsToIgnore, struct TArray<struct AActor*>& OutActors){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereOverlapActors");

	FSphereOverlapActors parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.SpherePos = SpherePos;
	parms.SphereRadius = SphereRadius;
	parms.ObjectTypes = ObjectTypes;
	parms.ActorClassFilter = ActorClassFilter;
	parms.ActorsToIgnore = ActorsToIgnore;
	parms.OutActors = OutActors;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetSystemLibrary::SnapshotObject(struct UObject* Object){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SnapshotObject");

	FSnapshotObject parms{};	
	parms.Object = Object;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::ShowPlatformSpecificLeaderboardScreen(struct FString CategoryName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ShowPlatformSpecificLeaderboardScreen");

	FShowPlatformSpecificLeaderboardScreen parms{};	
	parms.CategoryName = CategoryName;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::ShowPlatformSpecificAchievementsScreen(struct APlayerController* SpecificPlayer){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ShowPlatformSpecificAchievementsScreen");

	FShowPlatformSpecificAchievementsScreen parms{};	
	parms.SpecificPlayer = SpecificPlayer;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::ShowInterstitialAd(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ShowInterstitialAd");

	FShowInterstitialAd parms{};	

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::ShowAdBanner(int32_t AdIdIndex, bool bShowOnBottomOfScreen){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ShowAdBanner");

	FShowAdBanner parms{};	
	parms.AdIdIndex = AdIdIndex;
	parms.bShowOnBottomOfScreen = bShowOnBottomOfScreen;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::SetWindowTitle(struct FText& Title){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetWindowTitle");

	FSetWindowTitle parms{};	
	parms.Title = Title;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::SetVolumeButtonsHandledBySystem(bool bEnabled){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetVolumeButtonsHandledBySystem");

	FSetVolumeButtonsHandledBySystem parms{};	
	parms.bEnabled = bEnabled;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::SetVectorPropertyByName(struct UObject* Object, struct FName PropertyName, struct FVector& Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetVectorPropertyByName");

	FSetVectorPropertyByName parms{};	
	parms.Object = Object;
	parms.PropertyName = PropertyName;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::SetVector3fPropertyByName(struct UObject* Object, struct FName PropertyName, struct FVector3f& Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetVector3fPropertyByName");

	FSetVector3fPropertyByName parms{};	
	parms.Object = Object;
	parms.PropertyName = PropertyName;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::SetUserActivity(struct FUserActivity& UserActivity){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetUserActivity");

	FSetUserActivity parms{};	
	parms.UserActivity = UserActivity;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::SetTransformPropertyByName(struct UObject* Object, struct FName PropertyName, struct FTransform& Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetTransformPropertyByName");

	FSetTransformPropertyByName parms{};	
	parms.Object = Object;
	parms.PropertyName = PropertyName;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::SetTextPropertyByName(struct UObject* Object, struct FName PropertyName, struct FText& Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetTextPropertyByName");

	FSetTextPropertyByName parms{};	
	parms.Object = Object;
	parms.PropertyName = PropertyName;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::SetSuppressViewportTransitionMessage(struct UObject* WorldContextObject, bool bState){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetSuppressViewportTransitionMessage");

	FSetSuppressViewportTransitionMessage parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.bState = bState;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::SetStructurePropertyByName(struct UObject* Object, struct FName PropertyName, struct FGenericStruct& Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetStructurePropertyByName");

	FSetStructurePropertyByName parms{};	
	parms.Object = Object;
	parms.PropertyName = PropertyName;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::SetStringPropertyByName(struct UObject* Object, struct FName PropertyName, struct FString Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetStringPropertyByName");

	FSetStringPropertyByName parms{};	
	parms.Object = Object;
	parms.PropertyName = PropertyName;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::SetSoftObjectPropertyByName(struct UObject* Object, struct FName PropertyName, struct TSoftObjectPtr<UObject>& Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetSoftObjectPropertyByName");

	FSetSoftObjectPropertyByName parms{};	
	parms.Object = Object;
	parms.PropertyName = PropertyName;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::SetSoftClassPropertyByName(struct UObject* Object, struct FName PropertyName, struct TSoftClassPtr<UObject>& Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetSoftClassPropertyByName");

	FSetSoftClassPropertyByName parms{};	
	parms.Object = Object;
	parms.PropertyName = PropertyName;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::SetRotatorPropertyByName(struct UObject* Object, struct FName PropertyName, struct FRotator& Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetRotatorPropertyByName");

	FSetRotatorPropertyByName parms{};	
	parms.Object = Object;
	parms.PropertyName = PropertyName;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::SetObjectPropertyByName(struct UObject* Object, struct FName PropertyName, struct UObject* Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetObjectPropertyByName");

	FSetObjectPropertyByName parms{};	
	parms.Object = Object;
	parms.PropertyName = PropertyName;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::SetNamePropertyByName(struct UObject* Object, struct FName PropertyName, struct FName& Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetNamePropertyByName");

	FSetNamePropertyByName parms{};	
	parms.Object = Object;
	parms.PropertyName = PropertyName;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::SetLinearColorPropertyByName(struct UObject* Object, struct FName PropertyName, struct FLinearColor& Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetLinearColorPropertyByName");

	FSetLinearColorPropertyByName parms{};	
	parms.Object = Object;
	parms.PropertyName = PropertyName;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::SetIntPropertyByName(struct UObject* Object, struct FName PropertyName, int32_t Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetIntPropertyByName");

	FSetIntPropertyByName parms{};	
	parms.Object = Object;
	parms.PropertyName = PropertyName;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::SetInterfacePropertyByName(struct UObject* Object, struct FName PropertyName, struct TScriptInterface<IInterface>& Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetInterfacePropertyByName");

	FSetInterfacePropertyByName parms{};	
	parms.Object = Object;
	parms.PropertyName = PropertyName;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::SetInt64PropertyByName(struct UObject* Object, struct FName PropertyName, int64_t Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetInt64PropertyByName");

	FSetInt64PropertyByName parms{};	
	parms.Object = Object;
	parms.PropertyName = PropertyName;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::SetGamepadsBlockDeviceFeedback(bool bBlock){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetGamepadsBlockDeviceFeedback");

	FSetGamepadsBlockDeviceFeedback parms{};	
	parms.bBlock = bBlock;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::SetFieldPathPropertyByName(struct UObject* Object, struct FName PropertyName, struct TFieldPath<FNone>& Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetFieldPathPropertyByName");

	FSetFieldPathPropertyByName parms{};	
	parms.Object = Object;
	parms.PropertyName = PropertyName;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::SetDoublePropertyByName(struct UObject* Object, struct FName PropertyName, double Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetDoublePropertyByName");

	FSetDoublePropertyByName parms{};	
	parms.Object = Object;
	parms.PropertyName = PropertyName;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::SetColorPropertyByName(struct UObject* Object, struct FName PropertyName, struct FColor& Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetColorPropertyByName");

	FSetColorPropertyByName parms{};	
	parms.Object = Object;
	parms.PropertyName = PropertyName;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::SetCollisionProfileNameProperty(struct UObject* Object, struct FName PropertyName, struct FCollisionProfileName& Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetCollisionProfileNameProperty");

	FSetCollisionProfileNameProperty parms{};	
	parms.Object = Object;
	parms.PropertyName = PropertyName;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::SetClassPropertyByName(struct UObject* Object, struct FName PropertyName, UObject* Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetClassPropertyByName");

	FSetClassPropertyByName parms{};	
	parms.Object = Object;
	parms.PropertyName = PropertyName;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::SetBytePropertyByName(struct UObject* Object, struct FName PropertyName, char Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetBytePropertyByName");

	FSetBytePropertyByName parms{};	
	parms.Object = Object;
	parms.PropertyName = PropertyName;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::SetBoolPropertyByName(struct UObject* Object, struct FName PropertyName, bool Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetBoolPropertyByName");

	FSetBoolPropertyByName parms{};	
	parms.Object = Object;
	parms.PropertyName = PropertyName;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::RetriggerableDelay(struct UObject* WorldContextObject, float Duration, struct FLatentActionInfo LatentInfo){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.RetriggerableDelay");

	FRetriggerableDelay parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Duration = Duration;
	parms.LatentInfo = LatentInfo;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::ResetGamepadAssignmentToController(int32_t ControllerId){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ResetGamepadAssignmentToController");

	FResetGamepadAssignmentToController parms{};	
	parms.ControllerId = ControllerId;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::ResetGamepadAssignments(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ResetGamepadAssignments");

	FResetGamepadAssignments parms{};	

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::RegisterForRemoteNotifications(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.RegisterForRemoteNotifications");

	FRegisterForRemoteNotifications parms{};	

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::QuitGame(struct UObject* WorldContextObject, struct APlayerController* SpecificPlayer, enum class EQuitPreference QuitPreference, bool bIgnorePlatformRestrictions){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.QuitGame");

	FQuitGame parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.SpecificPlayer = SpecificPlayer;
	parms.QuitPreference = QuitPreference;
	parms.bIgnorePlatformRestrictions = bIgnorePlatformRestrictions;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::PrintWarning(struct FString InString){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.PrintWarning");

	FPrintWarning parms{};	
	parms.InString = InString;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::PrintText(struct UObject* WorldContextObject, struct FText InText, bool bPrintToScreen, bool bPrintToLog, struct FLinearColor TextColor, float Duration, struct FName Key){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.PrintText");

	FPrintText parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.InText = InText;
	parms.bPrintToScreen = bPrintToScreen;
	parms.bPrintToLog = bPrintToLog;
	parms.TextColor = TextColor;
	parms.Duration = Duration;
	parms.Key = Key;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::PrintString(struct UObject* WorldContextObject, struct FString InString, bool bPrintToScreen, bool bPrintToLog, struct FLinearColor TextColor, float Duration, struct FName Key){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.PrintString");

	FPrintString parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.InString = InString;
	parms.bPrintToScreen = bPrintToScreen;
	parms.bPrintToLog = bPrintToLog;
	parms.TextColor = TextColor;
	parms.Duration = Duration;
	parms.Key = Key;

	ProcessEvent(fn, &parms);
}

bool UKismetSystemLibrary::ParseParamValue(struct FString InString, struct FString InParam, struct FString& OutValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ParseParamValue");

	FParseParamValue parms{};	
	parms.InString = InString;
	parms.InParam = InParam;
	parms.OutValue = OutValue;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::ParseParam(struct FString InString, struct FString InParam){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ParseParam");

	FParseParam parms{};	
	parms.InString = InString;
	parms.InParam = InParam;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetSystemLibrary::ParseCommandLine(struct FString InCmdLine, struct TArray<struct FString>& OutTokens, struct TArray<struct FString>& OutSwitches, struct TMap<struct FString, struct FString>& OutParams){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ParseCommandLine");

	FParseCommandLine parms{};	
	parms.InCmdLine = InCmdLine;
	parms.OutTokens = OutTokens;
	parms.OutSwitches = OutSwitches;
	parms.OutParams = OutParams;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::OnAssetLoaded__DelegateSignature(struct UObject* Loaded){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("DelegateFunction Engine.KismetSystemLibrary.OnAssetLoaded__DelegateSignature");

	FOnAssetLoaded__DelegateSignature parms{};	
	parms.Loaded = Loaded;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::OnAssetClassLoaded__DelegateSignature(UObject* Loaded){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("DelegateFunction Engine.KismetSystemLibrary.OnAssetClassLoaded__DelegateSignature");

	FOnAssetClassLoaded__DelegateSignature parms{};	
	parms.Loaded = Loaded;

	ProcessEvent(fn, &parms);
}

bool UKismetSystemLibrary::NotEqual_SoftObjectReference(struct TSoftObjectPtr<UObject>& A, struct TSoftObjectPtr<UObject>& B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.NotEqual_SoftObjectReference");

	FNotEqual_SoftObjectReference parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::NotEqual_SoftClassReference(struct TSoftClassPtr<UObject>& A, struct TSoftClassPtr<UObject>& B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.NotEqual_SoftClassReference");

	FNotEqual_SoftClassReference parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::NotEqual_PrimaryAssetType(struct FPrimaryAssetType A, struct FPrimaryAssetType B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.NotEqual_PrimaryAssetType");

	FNotEqual_PrimaryAssetType parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::NotEqual_PrimaryAssetId(struct FPrimaryAssetId A, struct FPrimaryAssetId B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.NotEqual_PrimaryAssetId");

	FNotEqual_PrimaryAssetId parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetSystemLibrary::NormalizeFilename(struct FString InFilename){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.NormalizeFilename");

	FNormalizeFilename parms{};	
	parms.InFilename = InFilename;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetSystemLibrary::MoveComponentTo(struct USceneComponent* Component, struct FVector TargetRelativeLocation, struct FRotator TargetRelativeRotation, bool bEaseOut, bool bEaseIn, float OverTime, bool bForceShortestRotationPath, enum class EMoveComponentAction MoveAction, struct FLatentActionInfo LatentInfo){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MoveComponentTo");

	FMoveComponentTo parms{};	
	parms.Component = Component;
	parms.TargetRelativeLocation = TargetRelativeLocation;
	parms.TargetRelativeRotation = TargetRelativeRotation;
	parms.bEaseOut = bEaseOut;
	parms.bEaseIn = bEaseIn;
	parms.OverTime = OverTime;
	parms.bForceShortestRotationPath = bForceShortestRotationPath;
	parms.MoveAction = MoveAction;
	parms.LatentInfo = LatentInfo;

	ProcessEvent(fn, &parms);
}

struct FSoftObjectPath UKismetSystemLibrary::MakeSoftObjectPath(struct FString PathString){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeSoftObjectPath");

	FMakeSoftObjectPath parms{};	
	parms.PathString = PathString;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FSoftClassPath UKismetSystemLibrary::MakeSoftClassPath(struct FString PathString){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeSoftClassPath");

	FMakeSoftClassPath parms{};	
	parms.PathString = PathString;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FText UKismetSystemLibrary::MakeLiteralText(struct FText Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeLiteralText");

	FMakeLiteralText parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetSystemLibrary::MakeLiteralString(struct FString Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeLiteralString");

	FMakeLiteralString parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FName UKismetSystemLibrary::MakeLiteralName(struct FName Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeLiteralName");

	FMakeLiteralName parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int64_t UKismetSystemLibrary::MakeLiteralInt64(int64_t Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeLiteralInt64");

	FMakeLiteralInt64 parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetSystemLibrary::MakeLiteralInt(int32_t Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeLiteralInt");

	FMakeLiteralInt parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetSystemLibrary::MakeLiteralDouble(double Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeLiteralDouble");

	FMakeLiteralDouble parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

char UKismetSystemLibrary::MakeLiteralByte(char Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeLiteralByte");

	FMakeLiteralByte parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::MakeLiteralBool(bool Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeLiteralBool");

	FMakeLiteralBool parms{};	
	parms.Value = Value;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FARFilter UKismetSystemLibrary::MakeARFilter(struct TArray<struct FName>& PackageNames, struct TArray<struct FName>& PackagePaths, struct TArray<struct FSoftObjectPath>& SoftObjectPaths, struct TArray<struct FTopLevelAssetPath>& ClassPaths, struct TSet<struct FTopLevelAssetPath>& RecursiveClassPathsExclusionSet, struct TArray<struct FName>& ClassNames, struct TSet<struct FName>& RecursiveClassesExclusionSet, bool bRecursivePaths, bool bRecursiveClasses, bool bIncludeOnlyOnDiskAssets){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeARFilter");

	FMakeARFilter parms{};	
	parms.PackageNames = PackageNames;
	parms.PackagePaths = PackagePaths;
	parms.SoftObjectPaths = SoftObjectPaths;
	parms.ClassPaths = ClassPaths;
	parms.RecursiveClassPathsExclusionSet = RecursiveClassPathsExclusionSet;
	parms.ClassNames = ClassNames;
	parms.RecursiveClassesExclusionSet = RecursiveClassesExclusionSet;
	parms.bRecursivePaths = bRecursivePaths;
	parms.bRecursiveClasses = bRecursiveClasses;
	parms.bIncludeOnlyOnDiskAssets = bIncludeOnlyOnDiskAssets;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetSystemLibrary::LogString(struct FString InString, bool bPrintToLog){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LogString");

	FLogString parms{};	
	parms.InString = InString;
	parms.bPrintToLog = bPrintToLog;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::LoadInterstitialAd(int32_t AdIdIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LoadInterstitialAd");

	FLoadInterstitialAd parms{};	
	parms.AdIdIndex = AdIdIndex;

	ProcessEvent(fn, &parms);
}

UObject* UKismetSystemLibrary::LoadClassAsset_Blocking(struct TSoftClassPtr<UObject> AssetClass){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LoadClassAsset_Blocking");

	FLoadClassAsset_Blocking parms{};	
	parms.AssetClass = AssetClass;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetSystemLibrary::LoadAssetClass(struct UObject* WorldContextObject, struct TSoftClassPtr<UObject> AssetClass, struct FDelegate OnLoaded, struct FLatentActionInfo LatentInfo){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LoadAssetClass");

	FLoadAssetClass parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.AssetClass = AssetClass;
	parms.OnLoaded = OnLoaded;
	parms.LatentInfo = LatentInfo;

	ProcessEvent(fn, &parms);
}

struct UObject* UKismetSystemLibrary::LoadAsset_Blocking(struct TSoftObjectPtr<UObject> Asset){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LoadAsset_Blocking");

	FLoadAsset_Blocking parms{};	
	parms.Asset = Asset;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetSystemLibrary::LoadAsset(struct UObject* WorldContextObject, struct TSoftObjectPtr<UObject> Asset, struct FDelegate OnLoaded, struct FLatentActionInfo LatentInfo){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LoadAsset");

	FLoadAsset parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Asset = Asset;
	parms.OnLoaded = OnLoaded;
	parms.LatentInfo = LatentInfo;

	ProcessEvent(fn, &parms);
}

bool UKismetSystemLibrary::LineTraceSingleForObjects(struct UObject* WorldContextObject, struct FVector Start, struct FVector End, struct TArray<enum class EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, struct TArray<struct AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, struct FHitResult& OutHit, bool bIgnoreSelf, struct FLinearColor TraceColor, struct FLinearColor TraceHitColor, float DrawTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LineTraceSingleForObjects");

	FLineTraceSingleForObjects parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Start = Start;
	parms.End = End;
	parms.ObjectTypes = ObjectTypes;
	parms.bTraceComplex = bTraceComplex;
	parms.ActorsToIgnore = ActorsToIgnore;
	parms.DrawDebugType = DrawDebugType;
	parms.OutHit = OutHit;
	parms.bIgnoreSelf = bIgnoreSelf;
	parms.TraceColor = TraceColor;
	parms.TraceHitColor = TraceHitColor;
	parms.DrawTime = DrawTime;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::LineTraceSingleByProfile(struct UObject* WorldContextObject, struct FVector Start, struct FVector End, struct FName ProfileName, bool bTraceComplex, struct TArray<struct AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, struct FHitResult& OutHit, bool bIgnoreSelf, struct FLinearColor TraceColor, struct FLinearColor TraceHitColor, float DrawTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LineTraceSingleByProfile");

	FLineTraceSingleByProfile parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Start = Start;
	parms.End = End;
	parms.ProfileName = ProfileName;
	parms.bTraceComplex = bTraceComplex;
	parms.ActorsToIgnore = ActorsToIgnore;
	parms.DrawDebugType = DrawDebugType;
	parms.OutHit = OutHit;
	parms.bIgnoreSelf = bIgnoreSelf;
	parms.TraceColor = TraceColor;
	parms.TraceHitColor = TraceHitColor;
	parms.DrawTime = DrawTime;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::LineTraceSingle(struct UObject* WorldContextObject, struct FVector Start, struct FVector End, enum class ETraceTypeQuery TraceChannel, bool bTraceComplex, struct TArray<struct AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, struct FHitResult& OutHit, bool bIgnoreSelf, struct FLinearColor TraceColor, struct FLinearColor TraceHitColor, float DrawTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LineTraceSingle");

	FLineTraceSingle parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Start = Start;
	parms.End = End;
	parms.TraceChannel = TraceChannel;
	parms.bTraceComplex = bTraceComplex;
	parms.ActorsToIgnore = ActorsToIgnore;
	parms.DrawDebugType = DrawDebugType;
	parms.OutHit = OutHit;
	parms.bIgnoreSelf = bIgnoreSelf;
	parms.TraceColor = TraceColor;
	parms.TraceHitColor = TraceHitColor;
	parms.DrawTime = DrawTime;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::LineTraceMultiForObjects(struct UObject* WorldContextObject, struct FVector Start, struct FVector End, struct TArray<enum class EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, struct TArray<struct AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, struct TArray<struct FHitResult>& OutHits, bool bIgnoreSelf, struct FLinearColor TraceColor, struct FLinearColor TraceHitColor, float DrawTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LineTraceMultiForObjects");

	FLineTraceMultiForObjects parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Start = Start;
	parms.End = End;
	parms.ObjectTypes = ObjectTypes;
	parms.bTraceComplex = bTraceComplex;
	parms.ActorsToIgnore = ActorsToIgnore;
	parms.DrawDebugType = DrawDebugType;
	parms.OutHits = OutHits;
	parms.bIgnoreSelf = bIgnoreSelf;
	parms.TraceColor = TraceColor;
	parms.TraceHitColor = TraceHitColor;
	parms.DrawTime = DrawTime;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::LineTraceMultiByProfile(struct UObject* WorldContextObject, struct FVector Start, struct FVector End, struct FName ProfileName, bool bTraceComplex, struct TArray<struct AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, struct TArray<struct FHitResult>& OutHits, bool bIgnoreSelf, struct FLinearColor TraceColor, struct FLinearColor TraceHitColor, float DrawTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LineTraceMultiByProfile");

	FLineTraceMultiByProfile parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Start = Start;
	parms.End = End;
	parms.ProfileName = ProfileName;
	parms.bTraceComplex = bTraceComplex;
	parms.ActorsToIgnore = ActorsToIgnore;
	parms.DrawDebugType = DrawDebugType;
	parms.OutHits = OutHits;
	parms.bIgnoreSelf = bIgnoreSelf;
	parms.TraceColor = TraceColor;
	parms.TraceHitColor = TraceHitColor;
	parms.DrawTime = DrawTime;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::LineTraceMulti(struct UObject* WorldContextObject, struct FVector Start, struct FVector End, enum class ETraceTypeQuery TraceChannel, bool bTraceComplex, struct TArray<struct AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, struct TArray<struct FHitResult>& OutHits, bool bIgnoreSelf, struct FLinearColor TraceColor, struct FLinearColor TraceHitColor, float DrawTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LineTraceMulti");

	FLineTraceMulti parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Start = Start;
	parms.End = End;
	parms.TraceChannel = TraceChannel;
	parms.bTraceComplex = bTraceComplex;
	parms.ActorsToIgnore = ActorsToIgnore;
	parms.DrawDebugType = DrawDebugType;
	parms.OutHits = OutHits;
	parms.bIgnoreSelf = bIgnoreSelf;
	parms.TraceColor = TraceColor;
	parms.TraceHitColor = TraceHitColor;
	parms.DrawTime = DrawTime;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetSystemLibrary::LaunchURL(struct FString URL){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LaunchURL");

	FLaunchURL parms{};	
	parms.URL = URL;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::K2_UnPauseTimerHandle(struct UObject* WorldContextObject, struct FTimerHandle Handle){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_UnPauseTimerHandle");

	FK2_UnPauseTimerHandle parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Handle = Handle;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::K2_UnPauseTimerDelegate(struct FDelegate Delegate){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_UnPauseTimerDelegate");

	FK2_UnPauseTimerDelegate parms{};	
	parms.Delegate = Delegate;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::K2_UnPauseTimer(struct UObject* Object, struct FString FunctionName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_UnPauseTimer");

	FK2_UnPauseTimer parms{};	
	parms.Object = Object;
	parms.FunctionName = FunctionName;

	ProcessEvent(fn, &parms);
}

bool UKismetSystemLibrary::K2_TimerExistsHandle(struct UObject* WorldContextObject, struct FTimerHandle Handle){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_TimerExistsHandle");

	FK2_TimerExistsHandle parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Handle = Handle;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::K2_TimerExistsDelegate(struct FDelegate Delegate){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_TimerExistsDelegate");

	FK2_TimerExistsDelegate parms{};	
	parms.Delegate = Delegate;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::K2_TimerExists(struct UObject* Object, struct FString FunctionName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_TimerExists");

	FK2_TimerExists parms{};	
	parms.Object = Object;
	parms.FunctionName = FunctionName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTimerHandle UKismetSystemLibrary::K2_SetTimerForNextTickDelegate(struct FDelegate Delegate){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_SetTimerForNextTickDelegate");

	FK2_SetTimerForNextTickDelegate parms{};	
	parms.Delegate = Delegate;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTimerHandle UKismetSystemLibrary::K2_SetTimerForNextTick(struct UObject* Object, struct FString FunctionName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_SetTimerForNextTick");

	FK2_SetTimerForNextTick parms{};	
	parms.Object = Object;
	parms.FunctionName = FunctionName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTimerHandle UKismetSystemLibrary::K2_SetTimerDelegate(struct FDelegate Delegate, float Time, bool bLooping, float InitialStartDelay, float InitialStartDelayVariance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_SetTimerDelegate");

	FK2_SetTimerDelegate parms{};	
	parms.Delegate = Delegate;
	parms.Time = Time;
	parms.bLooping = bLooping;
	parms.InitialStartDelay = InitialStartDelay;
	parms.InitialStartDelayVariance = InitialStartDelayVariance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTimerHandle UKismetSystemLibrary::K2_SetTimer(struct UObject* Object, struct FString FunctionName, float Time, bool bLooping, float InitialStartDelay, float InitialStartDelayVariance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_SetTimer");

	FK2_SetTimer parms{};	
	parms.Object = Object;
	parms.FunctionName = FunctionName;
	parms.Time = Time;
	parms.bLooping = bLooping;
	parms.InitialStartDelay = InitialStartDelay;
	parms.InitialStartDelayVariance = InitialStartDelayVariance;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetSystemLibrary::K2_PauseTimerHandle(struct UObject* WorldContextObject, struct FTimerHandle Handle){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_PauseTimerHandle");

	FK2_PauseTimerHandle parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Handle = Handle;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::K2_PauseTimerDelegate(struct FDelegate Delegate){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_PauseTimerDelegate");

	FK2_PauseTimerDelegate parms{};	
	parms.Delegate = Delegate;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::K2_PauseTimer(struct UObject* Object, struct FString FunctionName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_PauseTimer");

	FK2_PauseTimer parms{};	
	parms.Object = Object;
	parms.FunctionName = FunctionName;

	ProcessEvent(fn, &parms);
}

bool UKismetSystemLibrary::K2_IsValidTimerHandle(struct FTimerHandle Handle){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_IsValidTimerHandle");

	FK2_IsValidTimerHandle parms{};	
	parms.Handle = Handle;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::K2_IsTimerPausedHandle(struct UObject* WorldContextObject, struct FTimerHandle Handle){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_IsTimerPausedHandle");

	FK2_IsTimerPausedHandle parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Handle = Handle;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::K2_IsTimerPausedDelegate(struct FDelegate Delegate){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_IsTimerPausedDelegate");

	FK2_IsTimerPausedDelegate parms{};	
	parms.Delegate = Delegate;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::K2_IsTimerPaused(struct UObject* Object, struct FString FunctionName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_IsTimerPaused");

	FK2_IsTimerPaused parms{};	
	parms.Object = Object;
	parms.FunctionName = FunctionName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::K2_IsTimerActiveHandle(struct UObject* WorldContextObject, struct FTimerHandle Handle){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_IsTimerActiveHandle");

	FK2_IsTimerActiveHandle parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Handle = Handle;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::K2_IsTimerActiveDelegate(struct FDelegate Delegate){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_IsTimerActiveDelegate");

	FK2_IsTimerActiveDelegate parms{};	
	parms.Delegate = Delegate;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::K2_IsTimerActive(struct UObject* Object, struct FString FunctionName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_IsTimerActive");

	FK2_IsTimerActive parms{};	
	parms.Object = Object;
	parms.FunctionName = FunctionName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FTimerHandle UKismetSystemLibrary::K2_InvalidateTimerHandle(struct FTimerHandle& Handle){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_InvalidateTimerHandle");

	FK2_InvalidateTimerHandle parms{};	
	parms.Handle = Handle;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetSystemLibrary::K2_GetTimerRemainingTimeHandle(struct UObject* WorldContextObject, struct FTimerHandle Handle){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_GetTimerRemainingTimeHandle");

	FK2_GetTimerRemainingTimeHandle parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Handle = Handle;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetSystemLibrary::K2_GetTimerRemainingTimeDelegate(struct FDelegate Delegate){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_GetTimerRemainingTimeDelegate");

	FK2_GetTimerRemainingTimeDelegate parms{};	
	parms.Delegate = Delegate;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetSystemLibrary::K2_GetTimerRemainingTime(struct UObject* Object, struct FString FunctionName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_GetTimerRemainingTime");

	FK2_GetTimerRemainingTime parms{};	
	parms.Object = Object;
	parms.FunctionName = FunctionName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetSystemLibrary::K2_GetTimerElapsedTimeHandle(struct UObject* WorldContextObject, struct FTimerHandle Handle){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_GetTimerElapsedTimeHandle");

	FK2_GetTimerElapsedTimeHandle parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Handle = Handle;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetSystemLibrary::K2_GetTimerElapsedTimeDelegate(struct FDelegate Delegate){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_GetTimerElapsedTimeDelegate");

	FK2_GetTimerElapsedTimeDelegate parms{};	
	parms.Delegate = Delegate;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetSystemLibrary::K2_GetTimerElapsedTime(struct UObject* Object, struct FString FunctionName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_GetTimerElapsedTime");

	FK2_GetTimerElapsedTime parms{};	
	parms.Object = Object;
	parms.FunctionName = FunctionName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetSystemLibrary::K2_ClearTimerHandle(struct UObject* WorldContextObject, struct FTimerHandle Handle){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_ClearTimerHandle");

	FK2_ClearTimerHandle parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Handle = Handle;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::K2_ClearTimerDelegate(struct FDelegate Delegate){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_ClearTimerDelegate");

	FK2_ClearTimerDelegate parms{};	
	parms.Delegate = Delegate;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::K2_ClearTimer(struct UObject* Object, struct FString FunctionName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_ClearTimer");

	FK2_ClearTimer parms{};	
	parms.Object = Object;
	parms.FunctionName = FunctionName;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::K2_ClearAndInvalidateTimerHandle(struct UObject* WorldContextObject, struct FTimerHandle& Handle){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_ClearAndInvalidateTimerHandle");

	FK2_ClearAndInvalidateTimerHandle parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Handle = Handle;

	ProcessEvent(fn, &parms);
}

bool UKismetSystemLibrary::IsValidSoftObjectReference(struct TSoftObjectPtr<UObject>& SoftObjectReference){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsValidSoftObjectReference");

	FIsValidSoftObjectReference parms{};	
	parms.SoftObjectReference = SoftObjectReference;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::IsValidSoftClassReference(struct TSoftClassPtr<UObject>& SoftClassReference){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsValidSoftClassReference");

	FIsValidSoftClassReference parms{};	
	parms.SoftClassReference = SoftClassReference;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::IsValidPrimaryAssetType(struct FPrimaryAssetType PrimaryAssetType){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsValidPrimaryAssetType");

	FIsValidPrimaryAssetType parms{};	
	parms.PrimaryAssetType = PrimaryAssetType;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::IsValidPrimaryAssetId(struct FPrimaryAssetId PrimaryAssetId){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsValidPrimaryAssetId");

	FIsValidPrimaryAssetId parms{};	
	parms.PrimaryAssetId = PrimaryAssetId;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::IsValidClass(UObject* Class){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsValidClass");

	FIsValidClass parms{};	
	parms.Class = Class;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::IsValid(struct UObject* Object){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsValid");

	FIsValid parms{};	
	parms.Object = Object;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::IsUnattended(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsUnattended");

	FIsUnattended parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::IsStandalone(struct UObject* WorldContextObject){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsStandalone");

	FIsStandalone parms{};	
	parms.WorldContextObject = WorldContextObject;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::IsSplitScreen(struct UObject* WorldContextObject){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsSplitScreen");

	FIsSplitScreen parms{};	
	parms.WorldContextObject = WorldContextObject;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::IsServer(struct UObject* WorldContextObject){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsServer");

	FIsServer parms{};	
	parms.WorldContextObject = WorldContextObject;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::IsScreensaverEnabled(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsScreensaverEnabled");

	FIsScreensaverEnabled parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::IsPackagedForDistribution(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsPackagedForDistribution");

	FIsPackagedForDistribution parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::IsLoggedIn(struct APlayerController* SpecificPlayer){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsLoggedIn");

	FIsLoggedIn parms{};	
	parms.SpecificPlayer = SpecificPlayer;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::IsInterstitialAdRequested(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsInterstitialAdRequested");

	FIsInterstitialAdRequested parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::IsInterstitialAdAvailable(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsInterstitialAdAvailable");

	FIsInterstitialAdAvailable parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::IsDedicatedServer(struct UObject* WorldContextObject){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsDedicatedServer");

	FIsDedicatedServer parms{};	
	parms.WorldContextObject = WorldContextObject;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::IsControllerAssignedToGamepad(int32_t ControllerId){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsControllerAssignedToGamepad");

	FIsControllerAssignedToGamepad parms{};	
	parms.ControllerId = ControllerId;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetSystemLibrary::HideAdBanner(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.HideAdBanner");

	FHideAdBanner parms{};	

	ProcessEvent(fn, &parms);
}

bool UKismetSystemLibrary::HasMultipleLocalPlayers(struct UObject* WorldContextObject){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.HasMultipleLocalPlayers");

	FHasMultipleLocalPlayers parms{};	
	parms.WorldContextObject = WorldContextObject;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::GetVolumeButtonsHandledBySystem(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetVolumeButtonsHandledBySystem");

	FGetVolumeButtonsHandledBySystem parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetSystemLibrary::GetUniqueDeviceId(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetUniqueDeviceId");

	FGetUniqueDeviceId parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetSystemLibrary::GetSystemPath(struct UObject* Object){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetSystemPath");

	FGetSystemPath parms{};	
	parms.Object = Object;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::GetSupportedFullscreenResolutions(struct TArray<struct FIntPoint>& Resolutions){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetSupportedFullscreenResolutions");

	FGetSupportedFullscreenResolutions parms{};	
	parms.Resolutions = Resolutions;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TSoftObjectPtr<UObject> UKismetSystemLibrary::GetSoftObjectReferenceFromPrimaryAssetId(struct FPrimaryAssetId PrimaryAssetId){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetSoftObjectReferenceFromPrimaryAssetId");

	FGetSoftObjectReferenceFromPrimaryAssetId parms{};	
	parms.PrimaryAssetId = PrimaryAssetId;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FSoftObjectPath UKismetSystemLibrary::GetSoftObjectPath(struct UObject* Object){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetSoftObjectPath");

	FGetSoftObjectPath parms{};	
	parms.Object = Object;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TSoftClassPtr<UObject> UKismetSystemLibrary::GetSoftClassReferenceFromPrimaryAssetId(struct FPrimaryAssetId PrimaryAssetId){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetSoftClassReferenceFromPrimaryAssetId");

	FGetSoftClassReferenceFromPrimaryAssetId parms{};	
	parms.PrimaryAssetId = PrimaryAssetId;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FSoftClassPath UKismetSystemLibrary::GetSoftClassPath(UObject* Class){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetSoftClassPath");

	FGetSoftClassPath parms{};	
	parms.Class = Class;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetSystemLibrary::GetRenderingMaterialQualityLevel(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetRenderingMaterialQualityLevel");

	FGetRenderingMaterialQualityLevel parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetSystemLibrary::GetRenderingDetailMode(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetRenderingDetailMode");

	FGetRenderingDetailMode parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetSystemLibrary::GetProjectSavedDirectory(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetProjectSavedDirectory");

	FGetProjectSavedDirectory parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetSystemLibrary::GetProjectDirectory(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetProjectDirectory");

	FGetProjectDirectory parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetSystemLibrary::GetProjectContentDirectory(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetProjectContentDirectory");

	FGetProjectContentDirectory parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetSystemLibrary::GetPrimaryAssetsWithBundleState(struct TArray<struct FName>& RequiredBundles, struct TArray<struct FName>& ExcludedBundles, struct TArray<struct FPrimaryAssetType>& ValidTypes, bool bForceCurrentState, struct TArray<struct FPrimaryAssetId>& OutPrimaryAssetIdList){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetPrimaryAssetsWithBundleState");

	FGetPrimaryAssetsWithBundleState parms{};	
	parms.RequiredBundles = RequiredBundles;
	parms.ExcludedBundles = ExcludedBundles;
	parms.ValidTypes = ValidTypes;
	parms.bForceCurrentState = bForceCurrentState;
	parms.OutPrimaryAssetIdList = OutPrimaryAssetIdList;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::GetPrimaryAssetIdList(struct FPrimaryAssetType PrimaryAssetType, struct TArray<struct FPrimaryAssetId>& OutPrimaryAssetIdList){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetPrimaryAssetIdList");

	FGetPrimaryAssetIdList parms{};	
	parms.PrimaryAssetType = PrimaryAssetType;
	parms.OutPrimaryAssetIdList = OutPrimaryAssetIdList;

	ProcessEvent(fn, &parms);
}

struct FPrimaryAssetId UKismetSystemLibrary::GetPrimaryAssetIdFromSoftObjectReference(struct TSoftObjectPtr<UObject> SoftObjectReference){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetPrimaryAssetIdFromSoftObjectReference");

	FGetPrimaryAssetIdFromSoftObjectReference parms{};	
	parms.SoftObjectReference = SoftObjectReference;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FPrimaryAssetId UKismetSystemLibrary::GetPrimaryAssetIdFromSoftClassReference(struct TSoftClassPtr<UObject> SoftClassReference){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetPrimaryAssetIdFromSoftClassReference");

	FGetPrimaryAssetIdFromSoftClassReference parms{};	
	parms.SoftClassReference = SoftClassReference;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FPrimaryAssetId UKismetSystemLibrary::GetPrimaryAssetIdFromObject(struct UObject* Object){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetPrimaryAssetIdFromObject");

	FGetPrimaryAssetIdFromObject parms{};	
	parms.Object = Object;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FPrimaryAssetId UKismetSystemLibrary::GetPrimaryAssetIdFromClass(UObject* Class){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetPrimaryAssetIdFromClass");

	FGetPrimaryAssetIdFromClass parms{};	
	parms.Class = Class;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<struct FString> UKismetSystemLibrary::GetPreferredLanguages(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetPreferredLanguages");

	FGetPreferredLanguages parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetSystemLibrary::GetPlatformUserName(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetPlatformUserName");

	FGetPlatformUserName parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetSystemLibrary::GetPlatformUserDir(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetPlatformUserDir");

	FGetPlatformUserDir parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetSystemLibrary::GetPathName(struct UObject* Object){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetPathName");

	FGetPathName parms{};	
	parms.Object = Object;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UObject* UKismetSystemLibrary::GetOuterObject(struct UObject* Object){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetOuterObject");

	FGetOuterObject parms{};	
	parms.Object = Object;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetSystemLibrary::GetObjectName(struct UObject* Object){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetObjectName");

	FGetObjectName parms{};	
	parms.Object = Object;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UObject* UKismetSystemLibrary::GetObjectFromPrimaryAssetId(struct FPrimaryAssetId PrimaryAssetId){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetObjectFromPrimaryAssetId");

	FGetObjectFromPrimaryAssetId parms{};	
	parms.PrimaryAssetId = PrimaryAssetId;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetSystemLibrary::GetMinYResolutionForUI(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetMinYResolutionForUI");

	FGetMinYResolutionForUI parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetSystemLibrary::GetMinYResolutionFor3DView(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetMinYResolutionFor3DView");

	FGetMinYResolutionFor3DView parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetSystemLibrary::GetLocalCurrencySymbol(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetLocalCurrencySymbol");

	FGetLocalCurrencySymbol parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetSystemLibrary::GetLocalCurrencyCode(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetLocalCurrencyCode");

	FGetLocalCurrencyCode parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

double UKismetSystemLibrary::GetGameTimeInSeconds(struct UObject* WorldContextObject){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetGameTimeInSeconds");

	FGetGameTimeInSeconds parms{};	
	parms.WorldContextObject = WorldContextObject;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetSystemLibrary::GetGamepadControllerName(int32_t ControllerId){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetGamepadControllerName");

	FGetGamepadControllerName parms{};	
	parms.ControllerId = ControllerId;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UTexture2D* UKismetSystemLibrary::GetGamepadButtonGlyph(struct FString ButtonKey, int32_t ControllerIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetGamepadButtonGlyph");

	FGetGamepadButtonGlyph parms{};	
	parms.ButtonKey = ButtonKey;
	parms.ControllerIndex = ControllerIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetSystemLibrary::GetGameName(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetGameName");

	FGetGameName parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetSystemLibrary::GetGameBundleId(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetGameBundleId");

	FGetGameBundleId parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int64_t UKismetSystemLibrary::GetFrameCount(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetFrameCount");

	FGetFrameCount parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetSystemLibrary::GetEngineVersion(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetEngineVersion");

	FGetEngineVersion parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetSystemLibrary::GetDisplayName(struct UObject* Object){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetDisplayName");

	FGetDisplayName parms{};	
	parms.Object = Object;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetSystemLibrary::GetDeviceId(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetDeviceId");

	FGetDeviceId parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetSystemLibrary::GetDefaultLocale(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetDefaultLocale");

	FGetDefaultLocale parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetSystemLibrary::GetDefaultLanguage(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetDefaultLanguage");

	FGetDefaultLanguage parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::GetCurrentBundleState(struct FPrimaryAssetId PrimaryAssetId, bool bForceCurrentState, struct TArray<struct FName>& OutBundles){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetCurrentBundleState");

	FGetCurrentBundleState parms{};	
	parms.PrimaryAssetId = PrimaryAssetId;
	parms.bForceCurrentState = bForceCurrentState;
	parms.OutBundles = OutBundles;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::GetConvenientWindowedResolutions(struct TArray<struct FIntPoint>& Resolutions){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetConvenientWindowedResolutions");

	FGetConvenientWindowedResolutions parms{};	
	parms.Resolutions = Resolutions;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetSystemLibrary::GetConsoleVariableIntValue(struct FString VariableName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetConsoleVariableIntValue");

	FGetConsoleVariableIntValue parms{};	
	parms.VariableName = VariableName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UKismetSystemLibrary::GetConsoleVariableFloatValue(struct FString VariableName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetConsoleVariableFloatValue");

	FGetConsoleVariableFloatValue parms{};	
	parms.VariableName = VariableName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::GetConsoleVariableBoolValue(struct FString VariableName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetConsoleVariableBoolValue");

	FGetConsoleVariableBoolValue parms{};	
	parms.VariableName = VariableName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetSystemLibrary::GetComponentBounds(struct USceneComponent* Component, struct FVector& Origin, struct FVector& BoxExtent, float& SphereRadius){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetComponentBounds");

	FGetComponentBounds parms{};	
	parms.Component = Component;
	parms.Origin = Origin;
	parms.BoxExtent = BoxExtent;
	parms.SphereRadius = SphereRadius;

	ProcessEvent(fn, &parms);
}

struct FString UKismetSystemLibrary::GetCommandLine(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetCommandLine");

	FGetCommandLine parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

UObject* UKismetSystemLibrary::GetClassFromPrimaryAssetId(struct FPrimaryAssetId PrimaryAssetId){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetClassFromPrimaryAssetId");

	FGetClassFromPrimaryAssetId parms{};	
	parms.PrimaryAssetId = PrimaryAssetId;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetSystemLibrary::GetClassDisplayName(UObject* Class){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetClassDisplayName");

	FGetClassDisplayName parms{};	
	parms.Class = Class;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetSystemLibrary::GetBuildVersion(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetBuildVersion");

	FGetBuildVersion parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetSystemLibrary::GetBuildConfiguration(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetBuildConfiguration");

	FGetBuildConfiguration parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetSystemLibrary::GetAdIDCount(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetAdIDCount");

	FGetAdIDCount parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetSystemLibrary::GetActorListFromComponentList(struct TArray<struct UPrimitiveComponent*>& ComponentList, UObject* ActorClassFilter, struct TArray<struct AActor*>& OutActorList){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetActorListFromComponentList");

	FGetActorListFromComponentList parms{};	
	parms.ComponentList = ComponentList;
	parms.ActorClassFilter = ActorClassFilter;
	parms.OutActorList = OutActorList;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::GetActorBounds(struct AActor* Actor, struct FVector& Origin, struct FVector& BoxExtent){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetActorBounds");

	FGetActorBounds parms{};	
	parms.Actor = Actor;
	parms.Origin = Origin;
	parms.BoxExtent = BoxExtent;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::ForceCloseAdBanner(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ForceCloseAdBanner");

	FForceCloseAdBanner parms{};	

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::FlushPersistentDebugLines(struct UObject* WorldContextObject){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.FlushPersistentDebugLines");

	FFlushPersistentDebugLines parms{};	
	parms.WorldContextObject = WorldContextObject;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::FlushDebugStrings(struct UObject* WorldContextObject){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.FlushDebugStrings");

	FFlushDebugStrings parms{};	
	parms.WorldContextObject = WorldContextObject;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::ExecuteConsoleCommand(struct UObject* WorldContextObject, struct FString Command, struct APlayerController* SpecificPlayer){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ExecuteConsoleCommand");

	FExecuteConsoleCommand parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Command = Command;
	parms.SpecificPlayer = SpecificPlayer;

	ProcessEvent(fn, &parms);
}

bool UKismetSystemLibrary::EqualEqual_SoftObjectReference(struct TSoftObjectPtr<UObject>& A, struct TSoftObjectPtr<UObject>& B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.EqualEqual_SoftObjectReference");

	FEqualEqual_SoftObjectReference parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::EqualEqual_SoftClassReference(struct TSoftClassPtr<UObject>& A, struct TSoftClassPtr<UObject>& B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.EqualEqual_SoftClassReference");

	FEqualEqual_SoftClassReference parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::EqualEqual_PrimaryAssetType(struct FPrimaryAssetType A, struct FPrimaryAssetType B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.EqualEqual_PrimaryAssetType");

	FEqualEqual_PrimaryAssetType parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::EqualEqual_PrimaryAssetId(struct FPrimaryAssetId A, struct FPrimaryAssetId B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.EqualEqual_PrimaryAssetId");

	FEqualEqual_PrimaryAssetId parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetSystemLibrary::EndTransaction(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.EndTransaction");

	FEndTransaction parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetSystemLibrary::DrawDebugString(struct UObject* WorldContextObject, struct FVector TextLocation, struct FString Text, struct AActor* TestBaseActor, struct FLinearColor TextColor, float Duration){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugString");

	FDrawDebugString parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.TextLocation = TextLocation;
	parms.Text = Text;
	parms.TestBaseActor = TestBaseActor;
	parms.TextColor = TextColor;
	parms.Duration = Duration;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::DrawDebugSphere(struct UObject* WorldContextObject, struct FVector Center, float Radius, int32_t Segments, struct FLinearColor LineColor, float Duration, float Thickness){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugSphere");

	FDrawDebugSphere parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Center = Center;
	parms.Radius = Radius;
	parms.Segments = Segments;
	parms.LineColor = LineColor;
	parms.Duration = Duration;
	parms.Thickness = Thickness;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::DrawDebugPoint(struct UObject* WorldContextObject, struct FVector Position, float Size, struct FLinearColor PointColor, float Duration){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugPoint");

	FDrawDebugPoint parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Position = Position;
	parms.Size = Size;
	parms.PointColor = PointColor;
	parms.Duration = Duration;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::DrawDebugPlane(struct UObject* WorldContextObject, struct FPlane& PlaneCoordinates, struct FVector Location, float Size, struct FLinearColor PlaneColor, float Duration){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugPlane");

	FDrawDebugPlane parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.PlaneCoordinates = PlaneCoordinates;
	parms.Location = Location;
	parms.Size = Size;
	parms.PlaneColor = PlaneColor;
	parms.Duration = Duration;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::DrawDebugLine(struct UObject* WorldContextObject, struct FVector LineStart, struct FVector LineEnd, struct FLinearColor LineColor, float Duration, float Thickness){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugLine");

	FDrawDebugLine parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.LineStart = LineStart;
	parms.LineEnd = LineEnd;
	parms.LineColor = LineColor;
	parms.Duration = Duration;
	parms.Thickness = Thickness;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::DrawDebugFrustum(struct UObject* WorldContextObject, struct FTransform& FrustumTransform, struct FLinearColor FrustumColor, float Duration, float Thickness){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugFrustum");

	FDrawDebugFrustum parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.FrustumTransform = FrustumTransform;
	parms.FrustumColor = FrustumColor;
	parms.Duration = Duration;
	parms.Thickness = Thickness;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::DrawDebugFloatHistoryTransform(struct UObject* WorldContextObject, struct FDebugFloatHistory& FloatHistory, struct FTransform& DrawTransform, struct FVector2D DrawSize, struct FLinearColor DrawColor, float Duration){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugFloatHistoryTransform");

	FDrawDebugFloatHistoryTransform parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.FloatHistory = FloatHistory;
	parms.DrawTransform = DrawTransform;
	parms.DrawSize = DrawSize;
	parms.DrawColor = DrawColor;
	parms.Duration = Duration;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::DrawDebugFloatHistoryLocation(struct UObject* WorldContextObject, struct FDebugFloatHistory& FloatHistory, struct FVector DrawLocation, struct FVector2D DrawSize, struct FLinearColor DrawColor, float Duration){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugFloatHistoryLocation");

	FDrawDebugFloatHistoryLocation parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.FloatHistory = FloatHistory;
	parms.DrawLocation = DrawLocation;
	parms.DrawSize = DrawSize;
	parms.DrawColor = DrawColor;
	parms.Duration = Duration;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::DrawDebugCylinder(struct UObject* WorldContextObject, struct FVector Start, struct FVector End, float Radius, int32_t Segments, struct FLinearColor LineColor, float Duration, float Thickness){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugCylinder");

	FDrawDebugCylinder parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Start = Start;
	parms.End = End;
	parms.Radius = Radius;
	parms.Segments = Segments;
	parms.LineColor = LineColor;
	parms.Duration = Duration;
	parms.Thickness = Thickness;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::DrawDebugCoordinateSystem(struct UObject* WorldContextObject, struct FVector AxisLoc, struct FRotator AxisRot, float Scale, float Duration, float Thickness){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugCoordinateSystem");

	FDrawDebugCoordinateSystem parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.AxisLoc = AxisLoc;
	parms.AxisRot = AxisRot;
	parms.Scale = Scale;
	parms.Duration = Duration;
	parms.Thickness = Thickness;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::DrawDebugConeInDegrees(struct UObject* WorldContextObject, struct FVector Origin, struct FVector Direction, float Length, float AngleWidth, float AngleHeight, int32_t NumSides, struct FLinearColor LineColor, float Duration, float Thickness){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugConeInDegrees");

	FDrawDebugConeInDegrees parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Origin = Origin;
	parms.Direction = Direction;
	parms.Length = Length;
	parms.AngleWidth = AngleWidth;
	parms.AngleHeight = AngleHeight;
	parms.NumSides = NumSides;
	parms.LineColor = LineColor;
	parms.Duration = Duration;
	parms.Thickness = Thickness;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::DrawDebugCone(struct UObject* WorldContextObject, struct FVector Origin, struct FVector Direction, float Length, float AngleWidth, float AngleHeight, int32_t NumSides, struct FLinearColor LineColor, float Duration, float Thickness){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugCone");

	FDrawDebugCone parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Origin = Origin;
	parms.Direction = Direction;
	parms.Length = Length;
	parms.AngleWidth = AngleWidth;
	parms.AngleHeight = AngleHeight;
	parms.NumSides = NumSides;
	parms.LineColor = LineColor;
	parms.Duration = Duration;
	parms.Thickness = Thickness;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::DrawDebugCircle(struct UObject* WorldContextObject, struct FVector Center, float Radius, int32_t NumSegments, struct FLinearColor LineColor, float Duration, float Thickness, struct FVector YAxis, struct FVector ZAxis, bool bDrawAxis){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugCircle");

	FDrawDebugCircle parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Center = Center;
	parms.Radius = Radius;
	parms.NumSegments = NumSegments;
	parms.LineColor = LineColor;
	parms.Duration = Duration;
	parms.Thickness = Thickness;
	parms.YAxis = YAxis;
	parms.ZAxis = ZAxis;
	parms.bDrawAxis = bDrawAxis;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::DrawDebugCapsule(struct UObject* WorldContextObject, struct FVector Center, float HalfHeight, float Radius, struct FRotator Rotation, struct FLinearColor LineColor, float Duration, float Thickness){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugCapsule");

	FDrawDebugCapsule parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Center = Center;
	parms.HalfHeight = HalfHeight;
	parms.Radius = Radius;
	parms.Rotation = Rotation;
	parms.LineColor = LineColor;
	parms.Duration = Duration;
	parms.Thickness = Thickness;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::DrawDebugCamera(struct ACameraActor* CameraActor, struct FLinearColor CameraColor, float Duration){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugCamera");

	FDrawDebugCamera parms{};	
	parms.CameraActor = CameraActor;
	parms.CameraColor = CameraColor;
	parms.Duration = Duration;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::DrawDebugBox(struct UObject* WorldContextObject, struct FVector Center, struct FVector Extent, struct FLinearColor LineColor, struct FRotator Rotation, float Duration, float Thickness){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugBox");

	FDrawDebugBox parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Center = Center;
	parms.Extent = Extent;
	parms.LineColor = LineColor;
	parms.Rotation = Rotation;
	parms.Duration = Duration;
	parms.Thickness = Thickness;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::DrawDebugArrow(struct UObject* WorldContextObject, struct FVector LineStart, struct FVector LineEnd, float ArrowSize, struct FLinearColor LineColor, float Duration, float Thickness){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugArrow");

	FDrawDebugArrow parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.LineStart = LineStart;
	parms.LineEnd = LineEnd;
	parms.ArrowSize = ArrowSize;
	parms.LineColor = LineColor;
	parms.Duration = Duration;
	parms.Thickness = Thickness;

	ProcessEvent(fn, &parms);
}

bool UKismetSystemLibrary::DoesImplementInterface(struct UObject* TestObject, UInterface* Interface){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DoesImplementInterface");

	FDoesImplementInterface parms{};	
	parms.TestObject = TestObject;
	parms.Interface = Interface;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetSystemLibrary::DelayUntilNextTick(struct UObject* WorldContextObject, struct FLatentActionInfo LatentInfo){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DelayUntilNextTick");

	FDelayUntilNextTick parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.LatentInfo = LatentInfo;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::Delay(struct UObject* WorldContextObject, float Duration, struct FLatentActionInfo LatentInfo){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Delay");

	FDelay parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Duration = Duration;
	parms.LatentInfo = LatentInfo;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::CreateCopyForUndoBuffer(struct UObject* ObjectToModify){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CreateCopyForUndoBuffer");

	FCreateCopyForUndoBuffer parms{};	
	parms.ObjectToModify = ObjectToModify;

	ProcessEvent(fn, &parms);
}

struct FString UKismetSystemLibrary::ConvertToRelativePath(struct FString Filename){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ConvertToRelativePath");

	FConvertToRelativePath parms{};	
	parms.Filename = Filename;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetSystemLibrary::ConvertToAbsolutePath(struct FString Filename){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ConvertToAbsolutePath");

	FConvertToAbsolutePath parms{};	
	parms.Filename = Filename;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FSoftObjectPath UKismetSystemLibrary::Conv_SoftObjRefToSoftObjPath(struct TSoftObjectPtr<UObject> SoftObjectReference){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Conv_SoftObjRefToSoftObjPath");

	FConv_SoftObjRefToSoftObjPath parms{};	
	parms.SoftObjectReference = SoftObjectReference;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FSoftClassPath UKismetSystemLibrary::Conv_SoftObjRefToSoftClassPath(struct TSoftClassPtr<UObject> SoftClassReference){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Conv_SoftObjRefToSoftClassPath");

	FConv_SoftObjRefToSoftClassPath parms{};	
	parms.SoftClassReference = SoftClassReference;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TSoftObjectPtr<UObject> UKismetSystemLibrary::Conv_SoftObjPathToSoftObjRef(struct FSoftObjectPath& SoftObjectPath){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Conv_SoftObjPathToSoftObjRef");

	FConv_SoftObjPathToSoftObjRef parms{};	
	parms.SoftObjectPath = SoftObjectPath;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetSystemLibrary::Conv_SoftObjectReferenceToString(struct TSoftObjectPtr<UObject>& SoftObjectReference){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Conv_SoftObjectReferenceToString");

	FConv_SoftObjectReferenceToString parms{};	
	parms.SoftObjectReference = SoftObjectReference;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UObject* UKismetSystemLibrary::Conv_SoftObjectReferenceToObject(struct TSoftObjectPtr<UObject>& SoftObject){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Conv_SoftObjectReferenceToObject");

	FConv_SoftObjectReferenceToObject parms{};	
	parms.SoftObject = SoftObject;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetSystemLibrary::Conv_SoftClassReferenceToString(struct TSoftClassPtr<UObject>& SoftClassReference){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Conv_SoftClassReferenceToString");

	FConv_SoftClassReferenceToString parms{};	
	parms.SoftClassReference = SoftClassReference;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

UObject* UKismetSystemLibrary::Conv_SoftClassReferenceToClass(struct TSoftClassPtr<UObject>& SoftClass){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Conv_SoftClassReferenceToClass");

	FConv_SoftClassReferenceToClass parms{};	
	parms.SoftClass = SoftClass;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TSoftClassPtr<UObject> UKismetSystemLibrary::Conv_SoftClassPathToSoftClassRef(struct FSoftClassPath& SoftClassPath){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Conv_SoftClassPathToSoftClassRef");

	FConv_SoftClassPathToSoftClassRef parms{};	
	parms.SoftClassPath = SoftClassPath;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetSystemLibrary::Conv_PrimaryAssetTypeToString(struct FPrimaryAssetType PrimaryAssetType){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Conv_PrimaryAssetTypeToString");

	FConv_PrimaryAssetTypeToString parms{};	
	parms.PrimaryAssetType = PrimaryAssetType;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetSystemLibrary::Conv_PrimaryAssetIdToString(struct FPrimaryAssetId PrimaryAssetId){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Conv_PrimaryAssetIdToString");

	FConv_PrimaryAssetIdToString parms{};	
	parms.PrimaryAssetId = PrimaryAssetId;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TSoftObjectPtr<UObject> UKismetSystemLibrary::Conv_ObjectToSoftObjectReference(struct UObject* Object){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Conv_ObjectToSoftObjectReference");

	FConv_ObjectToSoftObjectReference parms{};	
	parms.Object = Object;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

UObject* UKismetSystemLibrary::Conv_ObjectToClass(struct UObject* Object, UObject* Class){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Conv_ObjectToClass");

	FConv_ObjectToClass parms{};	
	parms.Object = Object;
	parms.Class = Class;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UObject* UKismetSystemLibrary::Conv_InterfaceToObject(struct TScriptInterface<IInterface>& Interface){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Conv_InterfaceToObject");

	FConv_InterfaceToObject parms{};	
	parms.Interface = Interface;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TSoftClassPtr<UObject> UKismetSystemLibrary::Conv_ClassToSoftClassReference(UObject*& Class){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Conv_ClassToSoftClassReference");

	FConv_ClassToSoftClassReference parms{};	
	parms.Class = Class;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetSystemLibrary::ControlScreensaver(bool bAllowScreenSaver){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ControlScreensaver");

	FControlScreensaver parms{};	
	parms.bAllowScreenSaver = bAllowScreenSaver;

	ProcessEvent(fn, &parms);
}

bool UKismetSystemLibrary::ComponentOverlapComponents(struct UPrimitiveComponent* Component, struct FTransform& ComponentTransform, struct TArray<enum class EObjectTypeQuery>& ObjectTypes, UObject* ComponentClassFilter, struct TArray<struct AActor*>& ActorsToIgnore, struct TArray<struct UPrimitiveComponent*>& OutComponents){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ComponentOverlapComponents");

	FComponentOverlapComponents parms{};	
	parms.Component = Component;
	parms.ComponentTransform = ComponentTransform;
	parms.ObjectTypes = ObjectTypes;
	parms.ComponentClassFilter = ComponentClassFilter;
	parms.ActorsToIgnore = ActorsToIgnore;
	parms.OutComponents = OutComponents;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::ComponentOverlapActors(struct UPrimitiveComponent* Component, struct FTransform& ComponentTransform, struct TArray<enum class EObjectTypeQuery>& ObjectTypes, UObject* ActorClassFilter, struct TArray<struct AActor*>& ActorsToIgnore, struct TArray<struct AActor*>& OutActors){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ComponentOverlapActors");

	FComponentOverlapActors parms{};	
	parms.Component = Component;
	parms.ComponentTransform = ComponentTransform;
	parms.ObjectTypes = ObjectTypes;
	parms.ActorClassFilter = ActorClassFilter;
	parms.ActorsToIgnore = ActorsToIgnore;
	parms.OutActors = OutActors;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetSystemLibrary::CollectGarbage(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CollectGarbage");

	FCollectGarbage parms{};	

	ProcessEvent(fn, &parms);
}

bool UKismetSystemLibrary::CapsuleTraceSingleForObjects(struct UObject* WorldContextObject, struct FVector Start, struct FVector End, float Radius, float HalfHeight, struct TArray<enum class EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, struct TArray<struct AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, struct FHitResult& OutHit, bool bIgnoreSelf, struct FLinearColor TraceColor, struct FLinearColor TraceHitColor, float DrawTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleTraceSingleForObjects");

	FCapsuleTraceSingleForObjects parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Start = Start;
	parms.End = End;
	parms.Radius = Radius;
	parms.HalfHeight = HalfHeight;
	parms.ObjectTypes = ObjectTypes;
	parms.bTraceComplex = bTraceComplex;
	parms.ActorsToIgnore = ActorsToIgnore;
	parms.DrawDebugType = DrawDebugType;
	parms.OutHit = OutHit;
	parms.bIgnoreSelf = bIgnoreSelf;
	parms.TraceColor = TraceColor;
	parms.TraceHitColor = TraceHitColor;
	parms.DrawTime = DrawTime;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::CapsuleTraceSingleByProfile(struct UObject* WorldContextObject, struct FVector Start, struct FVector End, float Radius, float HalfHeight, struct FName ProfileName, bool bTraceComplex, struct TArray<struct AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, struct FHitResult& OutHit, bool bIgnoreSelf, struct FLinearColor TraceColor, struct FLinearColor TraceHitColor, float DrawTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleTraceSingleByProfile");

	FCapsuleTraceSingleByProfile parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Start = Start;
	parms.End = End;
	parms.Radius = Radius;
	parms.HalfHeight = HalfHeight;
	parms.ProfileName = ProfileName;
	parms.bTraceComplex = bTraceComplex;
	parms.ActorsToIgnore = ActorsToIgnore;
	parms.DrawDebugType = DrawDebugType;
	parms.OutHit = OutHit;
	parms.bIgnoreSelf = bIgnoreSelf;
	parms.TraceColor = TraceColor;
	parms.TraceHitColor = TraceHitColor;
	parms.DrawTime = DrawTime;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::CapsuleTraceSingle(struct UObject* WorldContextObject, struct FVector Start, struct FVector End, float Radius, float HalfHeight, enum class ETraceTypeQuery TraceChannel, bool bTraceComplex, struct TArray<struct AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, struct FHitResult& OutHit, bool bIgnoreSelf, struct FLinearColor TraceColor, struct FLinearColor TraceHitColor, float DrawTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleTraceSingle");

	FCapsuleTraceSingle parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Start = Start;
	parms.End = End;
	parms.Radius = Radius;
	parms.HalfHeight = HalfHeight;
	parms.TraceChannel = TraceChannel;
	parms.bTraceComplex = bTraceComplex;
	parms.ActorsToIgnore = ActorsToIgnore;
	parms.DrawDebugType = DrawDebugType;
	parms.OutHit = OutHit;
	parms.bIgnoreSelf = bIgnoreSelf;
	parms.TraceColor = TraceColor;
	parms.TraceHitColor = TraceHitColor;
	parms.DrawTime = DrawTime;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::CapsuleTraceMultiForObjects(struct UObject* WorldContextObject, struct FVector Start, struct FVector End, float Radius, float HalfHeight, struct TArray<enum class EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, struct TArray<struct AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, struct TArray<struct FHitResult>& OutHits, bool bIgnoreSelf, struct FLinearColor TraceColor, struct FLinearColor TraceHitColor, float DrawTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleTraceMultiForObjects");

	FCapsuleTraceMultiForObjects parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Start = Start;
	parms.End = End;
	parms.Radius = Radius;
	parms.HalfHeight = HalfHeight;
	parms.ObjectTypes = ObjectTypes;
	parms.bTraceComplex = bTraceComplex;
	parms.ActorsToIgnore = ActorsToIgnore;
	parms.DrawDebugType = DrawDebugType;
	parms.OutHits = OutHits;
	parms.bIgnoreSelf = bIgnoreSelf;
	parms.TraceColor = TraceColor;
	parms.TraceHitColor = TraceHitColor;
	parms.DrawTime = DrawTime;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::CapsuleTraceMultiByProfile(struct UObject* WorldContextObject, struct FVector Start, struct FVector End, float Radius, float HalfHeight, struct FName ProfileName, bool bTraceComplex, struct TArray<struct AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, struct TArray<struct FHitResult>& OutHits, bool bIgnoreSelf, struct FLinearColor TraceColor, struct FLinearColor TraceHitColor, float DrawTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleTraceMultiByProfile");

	FCapsuleTraceMultiByProfile parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Start = Start;
	parms.End = End;
	parms.Radius = Radius;
	parms.HalfHeight = HalfHeight;
	parms.ProfileName = ProfileName;
	parms.bTraceComplex = bTraceComplex;
	parms.ActorsToIgnore = ActorsToIgnore;
	parms.DrawDebugType = DrawDebugType;
	parms.OutHits = OutHits;
	parms.bIgnoreSelf = bIgnoreSelf;
	parms.TraceColor = TraceColor;
	parms.TraceHitColor = TraceHitColor;
	parms.DrawTime = DrawTime;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::CapsuleTraceMulti(struct UObject* WorldContextObject, struct FVector Start, struct FVector End, float Radius, float HalfHeight, enum class ETraceTypeQuery TraceChannel, bool bTraceComplex, struct TArray<struct AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, struct TArray<struct FHitResult>& OutHits, bool bIgnoreSelf, struct FLinearColor TraceColor, struct FLinearColor TraceHitColor, float DrawTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleTraceMulti");

	FCapsuleTraceMulti parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Start = Start;
	parms.End = End;
	parms.Radius = Radius;
	parms.HalfHeight = HalfHeight;
	parms.TraceChannel = TraceChannel;
	parms.bTraceComplex = bTraceComplex;
	parms.ActorsToIgnore = ActorsToIgnore;
	parms.DrawDebugType = DrawDebugType;
	parms.OutHits = OutHits;
	parms.bIgnoreSelf = bIgnoreSelf;
	parms.TraceColor = TraceColor;
	parms.TraceHitColor = TraceHitColor;
	parms.DrawTime = DrawTime;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::CapsuleOverlapComponents(struct UObject* WorldContextObject, struct FVector CapsulePos, float Radius, float HalfHeight, struct TArray<enum class EObjectTypeQuery>& ObjectTypes, UObject* ComponentClassFilter, struct TArray<struct AActor*>& ActorsToIgnore, struct TArray<struct UPrimitiveComponent*>& OutComponents){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleOverlapComponents");

	FCapsuleOverlapComponents parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.CapsulePos = CapsulePos;
	parms.Radius = Radius;
	parms.HalfHeight = HalfHeight;
	parms.ObjectTypes = ObjectTypes;
	parms.ComponentClassFilter = ComponentClassFilter;
	parms.ActorsToIgnore = ActorsToIgnore;
	parms.OutComponents = OutComponents;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::CapsuleOverlapActors(struct UObject* WorldContextObject, struct FVector CapsulePos, float Radius, float HalfHeight, struct TArray<enum class EObjectTypeQuery>& ObjectTypes, UObject* ActorClassFilter, struct TArray<struct AActor*>& ActorsToIgnore, struct TArray<struct AActor*>& OutActors){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleOverlapActors");

	FCapsuleOverlapActors parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.CapsulePos = CapsulePos;
	parms.Radius = Radius;
	parms.HalfHeight = HalfHeight;
	parms.ObjectTypes = ObjectTypes;
	parms.ActorClassFilter = ActorClassFilter;
	parms.ActorsToIgnore = ActorsToIgnore;
	parms.OutActors = OutActors;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::CanLaunchURL(struct FString URL){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CanLaunchURL");

	FCanLaunchURL parms{};	
	parms.URL = URL;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UKismetSystemLibrary::CancelTransaction(int32_t Index){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CancelTransaction");

	FCancelTransaction parms{};	
	parms.Index = Index;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::BreakSoftObjectPath(struct FSoftObjectPath InSoftObjectPath, struct FString& PathString){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BreakSoftObjectPath");

	FBreakSoftObjectPath parms{};	
	parms.InSoftObjectPath = InSoftObjectPath;
	parms.PathString = PathString;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::BreakSoftClassPath(struct FSoftClassPath InSoftClassPath, struct FString& PathString){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BreakSoftClassPath");

	FBreakSoftClassPath parms{};	
	parms.InSoftClassPath = InSoftClassPath;
	parms.PathString = PathString;

	ProcessEvent(fn, &parms);
}

void UKismetSystemLibrary::BreakARFilter(struct FARFilter InARFilter, struct TArray<struct FName>& PackageNames, struct TArray<struct FName>& PackagePaths, struct TArray<struct FSoftObjectPath>& SoftObjectPaths, struct TArray<struct FTopLevelAssetPath>& ClassPaths, struct TSet<struct FTopLevelAssetPath>& RecursiveClassPathsExclusionSet, struct TArray<struct FName>& ClassNames, struct TSet<struct FName>& RecursiveClassesExclusionSet, bool& bRecursivePaths, bool& bRecursiveClasses, bool& bIncludeOnlyOnDiskAssets){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BreakARFilter");

	FBreakARFilter parms{};	
	parms.InARFilter = InARFilter;
	parms.PackageNames = PackageNames;
	parms.PackagePaths = PackagePaths;
	parms.SoftObjectPaths = SoftObjectPaths;
	parms.ClassPaths = ClassPaths;
	parms.RecursiveClassPathsExclusionSet = RecursiveClassPathsExclusionSet;
	parms.ClassNames = ClassNames;
	parms.RecursiveClassesExclusionSet = RecursiveClassesExclusionSet;
	parms.bRecursivePaths = bRecursivePaths;
	parms.bRecursiveClasses = bRecursiveClasses;
	parms.bIncludeOnlyOnDiskAssets = bIncludeOnlyOnDiskAssets;

	ProcessEvent(fn, &parms);
}

bool UKismetSystemLibrary::BoxTraceSingleForObjects(struct UObject* WorldContextObject, struct FVector Start, struct FVector End, struct FVector HalfSize, struct FRotator Orientation, struct TArray<enum class EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, struct TArray<struct AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, struct FHitResult& OutHit, bool bIgnoreSelf, struct FLinearColor TraceColor, struct FLinearColor TraceHitColor, float DrawTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BoxTraceSingleForObjects");

	FBoxTraceSingleForObjects parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Start = Start;
	parms.End = End;
	parms.HalfSize = HalfSize;
	parms.Orientation = Orientation;
	parms.ObjectTypes = ObjectTypes;
	parms.bTraceComplex = bTraceComplex;
	parms.ActorsToIgnore = ActorsToIgnore;
	parms.DrawDebugType = DrawDebugType;
	parms.OutHit = OutHit;
	parms.bIgnoreSelf = bIgnoreSelf;
	parms.TraceColor = TraceColor;
	parms.TraceHitColor = TraceHitColor;
	parms.DrawTime = DrawTime;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::BoxTraceSingleByProfile(struct UObject* WorldContextObject, struct FVector Start, struct FVector End, struct FVector HalfSize, struct FRotator Orientation, struct FName ProfileName, bool bTraceComplex, struct TArray<struct AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, struct FHitResult& OutHit, bool bIgnoreSelf, struct FLinearColor TraceColor, struct FLinearColor TraceHitColor, float DrawTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BoxTraceSingleByProfile");

	FBoxTraceSingleByProfile parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Start = Start;
	parms.End = End;
	parms.HalfSize = HalfSize;
	parms.Orientation = Orientation;
	parms.ProfileName = ProfileName;
	parms.bTraceComplex = bTraceComplex;
	parms.ActorsToIgnore = ActorsToIgnore;
	parms.DrawDebugType = DrawDebugType;
	parms.OutHit = OutHit;
	parms.bIgnoreSelf = bIgnoreSelf;
	parms.TraceColor = TraceColor;
	parms.TraceHitColor = TraceHitColor;
	parms.DrawTime = DrawTime;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::BoxTraceSingle(struct UObject* WorldContextObject, struct FVector Start, struct FVector End, struct FVector HalfSize, struct FRotator Orientation, enum class ETraceTypeQuery TraceChannel, bool bTraceComplex, struct TArray<struct AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, struct FHitResult& OutHit, bool bIgnoreSelf, struct FLinearColor TraceColor, struct FLinearColor TraceHitColor, float DrawTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BoxTraceSingle");

	FBoxTraceSingle parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Start = Start;
	parms.End = End;
	parms.HalfSize = HalfSize;
	parms.Orientation = Orientation;
	parms.TraceChannel = TraceChannel;
	parms.bTraceComplex = bTraceComplex;
	parms.ActorsToIgnore = ActorsToIgnore;
	parms.DrawDebugType = DrawDebugType;
	parms.OutHit = OutHit;
	parms.bIgnoreSelf = bIgnoreSelf;
	parms.TraceColor = TraceColor;
	parms.TraceHitColor = TraceHitColor;
	parms.DrawTime = DrawTime;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::BoxTraceMultiForObjects(struct UObject* WorldContextObject, struct FVector Start, struct FVector End, struct FVector HalfSize, struct FRotator Orientation, struct TArray<enum class EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, struct TArray<struct AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, struct TArray<struct FHitResult>& OutHits, bool bIgnoreSelf, struct FLinearColor TraceColor, struct FLinearColor TraceHitColor, float DrawTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BoxTraceMultiForObjects");

	FBoxTraceMultiForObjects parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Start = Start;
	parms.End = End;
	parms.HalfSize = HalfSize;
	parms.Orientation = Orientation;
	parms.ObjectTypes = ObjectTypes;
	parms.bTraceComplex = bTraceComplex;
	parms.ActorsToIgnore = ActorsToIgnore;
	parms.DrawDebugType = DrawDebugType;
	parms.OutHits = OutHits;
	parms.bIgnoreSelf = bIgnoreSelf;
	parms.TraceColor = TraceColor;
	parms.TraceHitColor = TraceHitColor;
	parms.DrawTime = DrawTime;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::BoxTraceMultiByProfile(struct UObject* WorldContextObject, struct FVector Start, struct FVector End, struct FVector HalfSize, struct FRotator Orientation, struct FName ProfileName, bool bTraceComplex, struct TArray<struct AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, struct TArray<struct FHitResult>& OutHits, bool bIgnoreSelf, struct FLinearColor TraceColor, struct FLinearColor TraceHitColor, float DrawTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BoxTraceMultiByProfile");

	FBoxTraceMultiByProfile parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Start = Start;
	parms.End = End;
	parms.HalfSize = HalfSize;
	parms.Orientation = Orientation;
	parms.ProfileName = ProfileName;
	parms.bTraceComplex = bTraceComplex;
	parms.ActorsToIgnore = ActorsToIgnore;
	parms.DrawDebugType = DrawDebugType;
	parms.OutHits = OutHits;
	parms.bIgnoreSelf = bIgnoreSelf;
	parms.TraceColor = TraceColor;
	parms.TraceHitColor = TraceHitColor;
	parms.DrawTime = DrawTime;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::BoxTraceMulti(struct UObject* WorldContextObject, struct FVector Start, struct FVector End, struct FVector HalfSize, struct FRotator Orientation, enum class ETraceTypeQuery TraceChannel, bool bTraceComplex, struct TArray<struct AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, struct TArray<struct FHitResult>& OutHits, bool bIgnoreSelf, struct FLinearColor TraceColor, struct FLinearColor TraceHitColor, float DrawTime){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BoxTraceMulti");

	FBoxTraceMulti parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.Start = Start;
	parms.End = End;
	parms.HalfSize = HalfSize;
	parms.Orientation = Orientation;
	parms.TraceChannel = TraceChannel;
	parms.bTraceComplex = bTraceComplex;
	parms.ActorsToIgnore = ActorsToIgnore;
	parms.DrawDebugType = DrawDebugType;
	parms.OutHits = OutHits;
	parms.bIgnoreSelf = bIgnoreSelf;
	parms.TraceColor = TraceColor;
	parms.TraceHitColor = TraceHitColor;
	parms.DrawTime = DrawTime;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::BoxOverlapComponents(struct UObject* WorldContextObject, struct FVector BoxPos, struct FVector Extent, struct TArray<enum class EObjectTypeQuery>& ObjectTypes, UObject* ComponentClassFilter, struct TArray<struct AActor*>& ActorsToIgnore, struct TArray<struct UPrimitiveComponent*>& OutComponents){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BoxOverlapComponents");

	FBoxOverlapComponents parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.BoxPos = BoxPos;
	parms.Extent = Extent;
	parms.ObjectTypes = ObjectTypes;
	parms.ComponentClassFilter = ComponentClassFilter;
	parms.ActorsToIgnore = ActorsToIgnore;
	parms.OutComponents = OutComponents;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetSystemLibrary::BoxOverlapActors(struct UObject* WorldContextObject, struct FVector BoxPos, struct FVector BoxExtent, struct TArray<enum class EObjectTypeQuery>& ObjectTypes, UObject* ActorClassFilter, struct TArray<struct AActor*>& ActorsToIgnore, struct TArray<struct AActor*>& OutActors){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BoxOverlapActors");

	FBoxOverlapActors parms{};	
	parms.WorldContextObject = WorldContextObject;
	parms.BoxPos = BoxPos;
	parms.BoxExtent = BoxExtent;
	parms.ObjectTypes = ObjectTypes;
	parms.ActorClassFilter = ActorClassFilter;
	parms.ActorsToIgnore = ActorsToIgnore;
	parms.OutActors = OutActors;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UKismetSystemLibrary::BeginTransaction(struct FString Context, struct FText Description, struct UObject* PrimaryObject){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BeginTransaction");

	FBeginTransaction parms{};	
	parms.Context = Context;
	parms.Description = Description;
	parms.PrimaryObject = PrimaryObject;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FDebugFloatHistory UKismetSystemLibrary::AddFloatHistorySample(float Value, struct FDebugFloatHistory& FloatHistory){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.AddFloatHistorySample");

	FAddFloatHistorySample parms{};	
	parms.Value = Value;
	parms.FloatHistory = FloatHistory;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetStringTableLibrary::IsRegisteredTableId(struct FName TableId){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringTableLibrary.IsRegisteredTableId");

	FIsRegisteredTableId parms{};	
	parms.TableId = TableId;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UKismetStringTableLibrary::IsRegisteredTableEntry(struct FName TableId, struct FString Key){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringTableLibrary.IsRegisteredTableEntry");

	FIsRegisteredTableEntry parms{};	
	parms.TableId = TableId;
	parms.Key = Key;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringTableLibrary::GetTableNamespace(struct FName TableId){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringTableLibrary.GetTableNamespace");

	FGetTableNamespace parms{};	
	parms.TableId = TableId;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringTableLibrary::GetTableEntrySourceString(struct FName TableId, struct FString Key){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringTableLibrary.GetTableEntrySourceString");

	FGetTableEntrySourceString parms{};	
	parms.TableId = TableId;
	parms.Key = Key;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UKismetStringTableLibrary::GetTableEntryMetaData(struct FName TableId, struct FString Key, struct FName MetaDataId){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringTableLibrary.GetTableEntryMetaData");

	FGetTableEntryMetaData parms{};	
	parms.TableId = TableId;
	parms.Key = Key;
	parms.MetaDataId = MetaDataId;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<struct FName> UKismetStringTableLibrary::GetRegisteredStringTables(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringTableLibrary.GetRegisteredStringTables");

	FGetRegisteredStringTables parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<struct FName> UKismetStringTableLibrary::GetMetaDataIdsFromStringTableEntry(struct FName TableId, struct FString Key){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringTableLibrary.GetMetaDataIdsFromStringTableEntry");

	FGetMetaDataIdsFromStringTableEntry parms{};	
	parms.TableId = TableId;
	parms.Key = Key;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<struct FString> UKismetStringTableLibrary::GetKeysFromStringTable(struct FName TableId){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.KismetStringTableLibrary.GetKeysFromStringTable");

	FGetKeysFromStringTable parms{};	
	parms.TableId = TableId;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UImportanceSamplingLibrary::RandomSobolFloat(int32_t Index, int32_t Dimension, float Seed){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ImportanceSamplingLibrary.RandomSobolFloat");

	FRandomSobolFloat parms{};	
	parms.Index = Index;
	parms.Dimension = Dimension;
	parms.Seed = Seed;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UImportanceSamplingLibrary::RandomSobolCell3D(int32_t Index, int32_t NumCells, struct FVector Cell, struct FVector Seed){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ImportanceSamplingLibrary.RandomSobolCell3D");

	FRandomSobolCell3D parms{};	
	parms.Index = Index;
	parms.NumCells = NumCells;
	parms.Cell = Cell;
	parms.Seed = Seed;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector2D UImportanceSamplingLibrary::RandomSobolCell2D(int32_t Index, int32_t NumCells, struct FVector2D Cell, struct FVector2D Seed){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ImportanceSamplingLibrary.RandomSobolCell2D");

	FRandomSobolCell2D parms{};	
	parms.Index = Index;
	parms.NumCells = NumCells;
	parms.Cell = Cell;
	parms.Seed = Seed;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UImportanceSamplingLibrary::NextSobolFloat(int32_t Index, int32_t Dimension, float PreviousValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ImportanceSamplingLibrary.NextSobolFloat");

	FNextSobolFloat parms{};	
	parms.Index = Index;
	parms.Dimension = Dimension;
	parms.PreviousValue = PreviousValue;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector UImportanceSamplingLibrary::NextSobolCell3D(int32_t Index, int32_t NumCells, struct FVector PreviousValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ImportanceSamplingLibrary.NextSobolCell3D");

	FNextSobolCell3D parms{};	
	parms.Index = Index;
	parms.NumCells = NumCells;
	parms.PreviousValue = PreviousValue;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FVector2D UImportanceSamplingLibrary::NextSobolCell2D(int32_t Index, int32_t NumCells, struct FVector2D PreviousValue){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ImportanceSamplingLibrary.NextSobolCell2D");

	FNextSobolCell2D parms{};	
	parms.Index = Index;
	parms.NumCells = NumCells;
	parms.PreviousValue = PreviousValue;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FImportanceTexture UImportanceSamplingLibrary::MakeImportanceTexture(struct UTexture2D* Texture, enum class EImportanceWeight WeightingFunc){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ImportanceSamplingLibrary.MakeImportanceTexture");

	FMakeImportanceTexture parms{};	
	parms.Texture = Texture;
	parms.WeightingFunc = WeightingFunc;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UImportanceSamplingLibrary::ImportanceSample(struct FImportanceTexture& Texture, struct FVector2D& Rand, int32_t Samples, float Intensity, struct FVector2D& SamplePosition, struct FLinearColor& SampleColor, float& SampleIntensity, float& SampleSize){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ImportanceSamplingLibrary.ImportanceSample");

	FImportanceSample parms{};	
	parms.Texture = Texture;
	parms.Rand = Rand;
	parms.Samples = Samples;
	parms.Intensity = Intensity;
	parms.SamplePosition = SamplePosition;
	parms.SampleColor = SampleColor;
	parms.SampleIntensity = SampleIntensity;
	parms.SampleSize = SampleSize;

	ProcessEvent(fn, &parms);
}

void UImportanceSamplingLibrary::BreakImportanceTexture(struct FImportanceTexture& ImportanceTexture, struct UTexture2D*& Texture, enum class EImportanceWeight& WeightingFunc){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ImportanceSamplingLibrary.BreakImportanceTexture");

	FBreakImportanceTexture parms{};	
	parms.ImportanceTexture = ImportanceTexture;
	parms.Texture = Texture;
	parms.WeightingFunc = WeightingFunc;

	ProcessEvent(fn, &parms);
}

void ALightWeightInstanceManager::OnRep_Transforms(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LightWeightInstanceManager.OnRep_Transforms");

	FOnRep_Transforms parms{};	

	ProcessEvent(fn, &parms);
}

void ALightWeightInstanceStaticMeshManager::OnRep_StaticMesh(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LightWeightInstanceStaticMeshManager.OnRep_StaticMesh");

	FOnRep_StaticMesh parms{};	

	ProcessEvent(fn, &parms);
}

void ALocationVolume::Unload(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LocationVolume.Unload");

	FUnload parms{};	

	ProcessEvent(fn, &parms);
}

void ALocationVolume::Load(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LocationVolume.Load");

	FLoad parms{};	

	ProcessEvent(fn, &parms);
}

bool ALocationVolume::IsLoaded(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.LocationVolume.IsLoaded");

	FIsLoaded parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UMaterialInstanceDynamic::SetVectorParameterValueByInfo(struct FMaterialParameterInfo& ParameterInfo, struct FLinearColor Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.SetVectorParameterValueByInfo");

	FSetVectorParameterValueByInfo parms{};	
	parms.ParameterInfo = ParameterInfo;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UMaterialInstanceDynamic::SetVectorParameterValue(struct FName ParameterName, struct FLinearColor Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.SetVectorParameterValue");

	FSetVectorParameterValue parms{};	
	parms.ParameterName = ParameterName;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UMaterialInstanceDynamic::SetTextureParameterValueByInfo(struct FMaterialParameterInfo& ParameterInfo, struct UTexture* Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.SetTextureParameterValueByInfo");

	FSetTextureParameterValueByInfo parms{};	
	parms.ParameterInfo = ParameterInfo;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UMaterialInstanceDynamic::SetTextureParameterValue(struct FName ParameterName, struct UTexture* Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.SetTextureParameterValue");

	FSetTextureParameterValue parms{};	
	parms.ParameterName = ParameterName;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UMaterialInstanceDynamic::SetScalarParameterValueByInfo(struct FMaterialParameterInfo& ParameterInfo, float Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.SetScalarParameterValueByInfo");

	FSetScalarParameterValueByInfo parms{};	
	parms.ParameterInfo = ParameterInfo;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UMaterialInstanceDynamic::SetScalarParameterValue(struct FName ParameterName, float Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.SetScalarParameterValue");

	FSetScalarParameterValue parms{};	
	parms.ParameterName = ParameterName;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

bool UMaterialInstanceDynamic::SetScalarParameterByIndex(int32_t ParameterIndex, float Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.SetScalarParameterByIndex");

	FSetScalarParameterByIndex parms{};	
	parms.ParameterIndex = ParameterIndex;
	parms.Value = Value;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UMaterialInstanceDynamic::SetRuntimeVirtualTextureParameterValueByInfo(struct FMaterialParameterInfo& ParameterInfo, struct URuntimeVirtualTexture* Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.SetRuntimeVirtualTextureParameterValueByInfo");

	FSetRuntimeVirtualTextureParameterValueByInfo parms{};	
	parms.ParameterInfo = ParameterInfo;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UMaterialInstanceDynamic::SetRuntimeVirtualTextureParameterValue(struct FName ParameterName, struct URuntimeVirtualTexture* Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.SetRuntimeVirtualTextureParameterValue");

	FSetRuntimeVirtualTextureParameterValue parms{};	
	parms.ParameterName = ParameterName;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UMaterialInstanceDynamic::SetDoubleVectorParameterValue(struct FName ParameterName, struct FVector4 Value){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.SetDoubleVectorParameterValue");

	FSetDoubleVectorParameterValue parms{};	
	parms.ParameterName = ParameterName;
	parms.Value = Value;

	ProcessEvent(fn, &parms);
}

void UMaterialInstanceDynamic::K2_InterpolateMaterialInstanceParams(struct UMaterialInstance* SourceA, struct UMaterialInstance* SourceB, float Alpha){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.K2_InterpolateMaterialInstanceParams");

	FK2_InterpolateMaterialInstanceParams parms{};	
	parms.SourceA = SourceA;
	parms.SourceB = SourceB;
	parms.Alpha = Alpha;

	ProcessEvent(fn, &parms);
}

struct FLinearColor UMaterialInstanceDynamic::K2_GetVectorParameterValueByInfo(struct FMaterialParameterInfo& ParameterInfo){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.K2_GetVectorParameterValueByInfo");

	FK2_GetVectorParameterValueByInfo parms{};	
	parms.ParameterInfo = ParameterInfo;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FLinearColor UMaterialInstanceDynamic::K2_GetVectorParameterValue(struct FName ParameterName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.K2_GetVectorParameterValue");

	FK2_GetVectorParameterValue parms{};	
	parms.ParameterName = ParameterName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UTexture* UMaterialInstanceDynamic::K2_GetTextureParameterValueByInfo(struct FMaterialParameterInfo& ParameterInfo){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.K2_GetTextureParameterValueByInfo");

	FK2_GetTextureParameterValueByInfo parms{};	
	parms.ParameterInfo = ParameterInfo;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UTexture* UMaterialInstanceDynamic::K2_GetTextureParameterValue(struct FName ParameterName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.K2_GetTextureParameterValue");

	FK2_GetTextureParameterValue parms{};	
	parms.ParameterName = ParameterName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UMaterialInstanceDynamic::K2_GetScalarParameterValueByInfo(struct FMaterialParameterInfo& ParameterInfo){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.K2_GetScalarParameterValueByInfo");

	FK2_GetScalarParameterValueByInfo parms{};	
	parms.ParameterInfo = ParameterInfo;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UMaterialInstanceDynamic::K2_GetScalarParameterValue(struct FName ParameterName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.K2_GetScalarParameterValue");

	FK2_GetScalarParameterValue parms{};	
	parms.ParameterName = ParameterName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UMaterialInstanceDynamic::K2_CopyMaterialInstanceParameters(struct UMaterialInterface* Source, bool bQuickParametersOnly){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.K2_CopyMaterialInstanceParameters");

	FK2_CopyMaterialInstanceParameters parms{};	
	parms.Source = Source;
	parms.bQuickParametersOnly = bQuickParametersOnly;

	ProcessEvent(fn, &parms);
}

bool UMaterialInstanceDynamic::InitializeScalarParameterAndGetIndex(struct FName& ParameterName, float Value, int32_t& OutParameterIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.InitializeScalarParameterAndGetIndex");

	FInitializeScalarParameterAndGetIndex parms{};	
	parms.ParameterName = ParameterName;
	parms.Value = Value;
	parms.OutParameterIndex = OutParameterIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UMaterialInstanceDynamic::CopyParameterOverrides(struct UMaterialInstance* MaterialInstance){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.CopyParameterOverrides");

	FCopyParameterOverrides parms{};	
	parms.MaterialInstance = MaterialInstance;

	ProcessEvent(fn, &parms);
}

void UMaterialInstanceDynamic::CopyInterpParameters(struct UMaterialInstance* Source){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.CopyInterpParameters");

	FCopyInterpParameters parms{};	
	parms.Source = Source;

	ProcessEvent(fn, &parms);
}

void UMeshVertexPainterKismetLibrary::RemovePaintedVertices(struct UStaticMeshComponent* StaticMeshComponent){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MeshVertexPainterKismetLibrary.RemovePaintedVertices");

	FRemovePaintedVertices parms{};	
	parms.StaticMeshComponent = StaticMeshComponent;

	ProcessEvent(fn, &parms);
}

void UMeshVertexPainterKismetLibrary::PaintVerticesSingleColor(struct UStaticMeshComponent* StaticMeshComponent, struct FLinearColor& FillColor, bool bConvertToSRGB){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MeshVertexPainterKismetLibrary.PaintVerticesSingleColor");

	FPaintVerticesSingleColor parms{};	
	parms.StaticMeshComponent = StaticMeshComponent;
	parms.FillColor = FillColor;
	parms.bConvertToSRGB = bConvertToSRGB;

	ProcessEvent(fn, &parms);
}

void UMeshVertexPainterKismetLibrary::PaintVerticesLerpAlongAxis(struct UStaticMeshComponent* StaticMeshComponent, struct FLinearColor& StartColor, struct FLinearColor& EndColor, uint8_t Axis, bool bConvertToSRGB){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.MeshVertexPainterKismetLibrary.PaintVerticesLerpAlongAxis");

	FPaintVerticesLerpAlongAxis parms{};	
	parms.StaticMeshComponent = StaticMeshComponent;
	parms.StartColor = StartColor;
	parms.EndColor = EndColor;
	parms.Axis = Axis;
	parms.bConvertToSRGB = bConvertToSRGB;

	ProcessEvent(fn, &parms);
}

void UAsyncPhysicsInputComponent::ServerRPCBufferInput(struct UAsyncPhysicsData* AsyncPhysicsData){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AsyncPhysicsInputComponent.ServerRPCBufferInput");

	FServerRPCBufferInput parms{};	
	parms.AsyncPhysicsData = AsyncPhysicsData;

	ProcessEvent(fn, &parms);
}

struct UAsyncPhysicsData* UAsyncPhysicsInputComponent::GetDataToWrite(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AsyncPhysicsInputComponent.GetDataToWrite");

	FGetDataToWrite parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UAsyncPhysicsData* UAsyncPhysicsInputComponent::GetDataToConsume(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.AsyncPhysicsInputComponent.GetDataToConsume");

	FGetDataToConsume parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UPhysicsHandleComponent::SetTargetRotation(struct FRotator NewRotation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.SetTargetRotation");

	FSetTargetRotation parms{};	
	parms.NewRotation = NewRotation;

	ProcessEvent(fn, &parms);
}

void UPhysicsHandleComponent::SetTargetLocationAndRotation(struct FVector NewLocation, struct FRotator NewRotation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.SetTargetLocationAndRotation");

	FSetTargetLocationAndRotation parms{};	
	parms.NewLocation = NewLocation;
	parms.NewRotation = NewRotation;

	ProcessEvent(fn, &parms);
}

void UPhysicsHandleComponent::SetTargetLocation(struct FVector NewLocation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.SetTargetLocation");

	FSetTargetLocation parms{};	
	parms.NewLocation = NewLocation;

	ProcessEvent(fn, &parms);
}

void UPhysicsHandleComponent::SetLinearStiffness(float NewLinearStiffness){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.SetLinearStiffness");

	FSetLinearStiffness parms{};	
	parms.NewLinearStiffness = NewLinearStiffness;

	ProcessEvent(fn, &parms);
}

void UPhysicsHandleComponent::SetLinearDamping(float NewLinearDamping){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.SetLinearDamping");

	FSetLinearDamping parms{};	
	parms.NewLinearDamping = NewLinearDamping;

	ProcessEvent(fn, &parms);
}

void UPhysicsHandleComponent::SetInterpolationSpeed(float NewInterpolationSpeed){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.SetInterpolationSpeed");

	FSetInterpolationSpeed parms{};	
	parms.NewInterpolationSpeed = NewInterpolationSpeed;

	ProcessEvent(fn, &parms);
}

void UPhysicsHandleComponent::SetAngularStiffness(float NewAngularStiffness){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.SetAngularStiffness");

	FSetAngularStiffness parms{};	
	parms.NewAngularStiffness = NewAngularStiffness;

	ProcessEvent(fn, &parms);
}

void UPhysicsHandleComponent::SetAngularDamping(float NewAngularDamping){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.SetAngularDamping");

	FSetAngularDamping parms{};	
	parms.NewAngularDamping = NewAngularDamping;

	ProcessEvent(fn, &parms);
}

void UPhysicsHandleComponent::ReleaseComponent(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.ReleaseComponent");

	FReleaseComponent parms{};	

	ProcessEvent(fn, &parms);
}

void UPhysicsHandleComponent::GrabComponentAtLocationWithRotation(struct UPrimitiveComponent* Component, struct FName InBoneName, struct FVector Location, struct FRotator Rotation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.GrabComponentAtLocationWithRotation");

	FGrabComponentAtLocationWithRotation parms{};	
	parms.Component = Component;
	parms.InBoneName = InBoneName;
	parms.Location = Location;
	parms.Rotation = Rotation;

	ProcessEvent(fn, &parms);
}

void UPhysicsHandleComponent::GrabComponentAtLocation(struct UPrimitiveComponent* Component, struct FName InBoneName, struct FVector GrabLocation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.GrabComponentAtLocation");

	FGrabComponentAtLocation parms{};	
	parms.Component = Component;
	parms.InBoneName = InBoneName;
	parms.GrabLocation = GrabLocation;

	ProcessEvent(fn, &parms);
}

void UPhysicsHandleComponent::GrabComponent(struct UPrimitiveComponent* Component, struct FName InBoneName, struct FVector GrabLocation, bool bConstrainRotation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.GrabComponent");

	FGrabComponent parms{};	
	parms.Component = Component;
	parms.InBoneName = InBoneName;
	parms.GrabLocation = GrabLocation;
	parms.bConstrainRotation = bConstrainRotation;

	ProcessEvent(fn, &parms);
}

void UPhysicsHandleComponent::GetTargetLocationAndRotation(struct FVector& TargetLocation, struct FRotator& TargetRotation){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.GetTargetLocationAndRotation");

	FGetTargetLocationAndRotation parms{};	
	parms.TargetLocation = TargetLocation;
	parms.TargetRotation = TargetRotation;

	ProcessEvent(fn, &parms);
}

struct UPrimitiveComponent* UPhysicsHandleComponent::GetGrabbedComponent(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.GetGrabbedComponent");

	FGetGrabbedComponent parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FPlatformUserId UPlatformInputDeviceMapperLibrary::PlatformUserId_None(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlatformInputDeviceMapperLibrary.PlatformUserId_None");

	FPlatformUserId_None parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UPlatformInputDeviceMapperLibrary::NotEqual_PlatformUserId(struct FPlatformUserId A, struct FPlatformUserId B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlatformInputDeviceMapperLibrary.NotEqual_PlatformUserId");

	FNotEqual_PlatformUserId parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UPlatformInputDeviceMapperLibrary::NotEqual_InputDeviceId(struct FInputDeviceId A, struct FInputDeviceId B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlatformInputDeviceMapperLibrary.NotEqual_InputDeviceId");

	FNotEqual_InputDeviceId parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UPlatformInputDeviceMapperLibrary::IsValidPlatformId(struct FPlatformUserId userID){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlatformInputDeviceMapperLibrary.IsValidPlatformId");

	FIsValidPlatformId parms{};	
	parms.userID = userID;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UPlatformInputDeviceMapperLibrary::IsValidInputDevice(struct FInputDeviceId DeviceID){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlatformInputDeviceMapperLibrary.IsValidInputDevice");

	FIsValidInputDevice parms{};	
	parms.DeviceID = DeviceID;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UPlatformInputDeviceMapperLibrary::IsUnpairedUserId(struct FPlatformUserId PlatformId){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlatformInputDeviceMapperLibrary.IsUnpairedUserId");

	FIsUnpairedUserId parms{};	
	parms.PlatformId = PlatformId;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UPlatformInputDeviceMapperLibrary::IsInputDeviceMappedToUnpairedUser(struct FInputDeviceId InputDevice){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlatformInputDeviceMapperLibrary.IsInputDeviceMappedToUnpairedUser");

	FIsInputDeviceMappedToUnpairedUser parms{};	
	parms.InputDevice = InputDevice;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FInputDeviceId UPlatformInputDeviceMapperLibrary::InputDeviceId_None(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlatformInputDeviceMapperLibrary.InputDeviceId_None");

	FInputDeviceId_None parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FPlatformUserId UPlatformInputDeviceMapperLibrary::GetUserForUnpairedInputDevices(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlatformInputDeviceMapperLibrary.GetUserForUnpairedInputDevices");

	FGetUserForUnpairedInputDevices parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FPlatformUserId UPlatformInputDeviceMapperLibrary::GetUserForInputDevice(struct FInputDeviceId DeviceID){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlatformInputDeviceMapperLibrary.GetUserForInputDevice");

	FGetUserForInputDevice parms{};	
	parms.DeviceID = DeviceID;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FInputDeviceId UPlatformInputDeviceMapperLibrary::GetPrimaryInputDeviceForUser(struct FPlatformUserId userID){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlatformInputDeviceMapperLibrary.GetPrimaryInputDeviceForUser");

	FGetPrimaryInputDeviceForUser parms{};	
	parms.userID = userID;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

uint8_t UPlatformInputDeviceMapperLibrary::GetInputDeviceConnectionState(struct FInputDeviceId DeviceID){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlatformInputDeviceMapperLibrary.GetInputDeviceConnectionState");

	FGetInputDeviceConnectionState parms{};	
	parms.DeviceID = DeviceID;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FInputDeviceId UPlatformInputDeviceMapperLibrary::GetDefaultInputDevice(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlatformInputDeviceMapperLibrary.GetDefaultInputDevice");

	FGetDefaultInputDevice parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UPlatformInputDeviceMapperLibrary::GetAllInputDevicesForUser(struct FPlatformUserId userID, struct TArray<struct FInputDeviceId>& OutInputDevices){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlatformInputDeviceMapperLibrary.GetAllInputDevicesForUser");

	FGetAllInputDevicesForUser parms{};	
	parms.userID = userID;
	parms.OutInputDevices = OutInputDevices;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UPlatformInputDeviceMapperLibrary::GetAllInputDevices(struct TArray<struct FInputDeviceId>& OutInputDevices){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlatformInputDeviceMapperLibrary.GetAllInputDevices");

	FGetAllInputDevices parms{};	
	parms.OutInputDevices = OutInputDevices;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UPlatformInputDeviceMapperLibrary::GetAllConnectedInputDevices(struct TArray<struct FInputDeviceId>& OutInputDevices){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlatformInputDeviceMapperLibrary.GetAllConnectedInputDevices");

	FGetAllConnectedInputDevices parms{};	
	parms.OutInputDevices = OutInputDevices;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t UPlatformInputDeviceMapperLibrary::GetAllActiveUsers(struct TArray<struct FPlatformUserId>& OutUsers){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlatformInputDeviceMapperLibrary.GetAllActiveUsers");

	FGetAllActiveUsers parms{};	
	parms.OutUsers = OutUsers;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UPlatformInputDeviceMapperLibrary::EqualEqual_PlatformUserId(struct FPlatformUserId A, struct FPlatformUserId B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlatformInputDeviceMapperLibrary.EqualEqual_PlatformUserId");

	FEqualEqual_PlatformUserId parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UPlatformInputDeviceMapperLibrary::EqualEqual_InputDeviceId(struct FInputDeviceId A, struct FInputDeviceId B){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.PlatformInputDeviceMapperLibrary.EqualEqual_InputDeviceId");

	FEqualEqual_InputDeviceId parms{};	
	parms.A = A;
	parms.B = B;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UHealthSnapshotBlueprintLibrary::StopPerformanceSnapshots(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.HealthSnapshotBlueprintLibrary.StopPerformanceSnapshots");

	FStopPerformanceSnapshots parms{};	

	ProcessEvent(fn, &parms);
}

void UHealthSnapshotBlueprintLibrary::StartPerformanceSnapshots(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.HealthSnapshotBlueprintLibrary.StartPerformanceSnapshots");

	FStartPerformanceSnapshots parms{};	

	ProcessEvent(fn, &parms);
}

void UHealthSnapshotBlueprintLibrary::LogPerformanceSnapshot(struct FString SnapshotTitle, bool bResetStats){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.HealthSnapshotBlueprintLibrary.LogPerformanceSnapshot");

	FLogPerformanceSnapshot parms{};	
	parms.SnapshotTitle = SnapshotTitle;
	parms.bResetStats = bResetStats;

	ProcessEvent(fn, &parms);
}

void UReplaySubsystem::RequestCheckpoint(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ReplaySubsystem.RequestCheckpoint");

	FRequestCheckpoint parms{};	

	ProcessEvent(fn, &parms);
}

bool UReplaySubsystem::IsRecording(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ReplaySubsystem.IsRecording");

	FIsRecording parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UReplaySubsystem::IsPlaying(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ReplaySubsystem.IsPlaying");

	FIsPlaying parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

float UReplaySubsystem::GetReplayCurrentTime(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ReplaySubsystem.GetReplayCurrentTime");

	FGetReplayCurrentTime parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FString UReplaySubsystem::GetActiveReplayName(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.ReplaySubsystem.GetActiveReplayName");

	FGetActiveReplayName parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void USkeletalMesh::SetSkeleton(struct USkeleton* InSkeleton){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.SetSkeleton");

	FSetSkeleton parms{};	
	parms.InSkeleton = InSkeleton;

	ProcessEvent(fn, &parms);
}

void USkeletalMesh::SetMorphTargets(struct TArray<struct UMorphTarget*>& InMorphTargets){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.SetMorphTargets");

	FSetMorphTargets parms{};	
	parms.InMorphTargets = InMorphTargets;

	ProcessEvent(fn, &parms);
}

void USkeletalMesh::SetMinLODForQualityLevels(struct TMap<uint8_t, int32_t>& QualityLevelMinimumLODs, int32_t Default){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.SetMinLODForQualityLevels");

	FSetMinLODForQualityLevels parms{};	
	parms.QualityLevelMinimumLODs = QualityLevelMinimumLODs;
	parms.Default = Default;

	ProcessEvent(fn, &parms);
}

void USkeletalMesh::SetMeshClothingAssets(struct TArray<struct UClothingAssetBase*>& InMeshClothingAssets){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.SetMeshClothingAssets");

	FSetMeshClothingAssets parms{};	
	parms.InMeshClothingAssets = InMeshClothingAssets;

	ProcessEvent(fn, &parms);
}

void USkeletalMesh::SetMaterials(struct TArray<struct FSkeletalMaterial>& InMaterials){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.SetMaterials");

	FSetMaterials parms{};	
	parms.InMaterials = InMaterials;

	ProcessEvent(fn, &parms);
}

void USkeletalMesh::SetLODSettings(struct USkeletalMeshLODSettings* InLODSettings){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.SetLODSettings");

	FSetLODSettings parms{};	
	parms.InLODSettings = InLODSettings;

	ProcessEvent(fn, &parms);
}

void USkeletalMesh::SetDefaultAnimatingRig(struct TSoftObjectPtr<UObject> InAnimatingRig){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.SetDefaultAnimatingRig");

	FSetDefaultAnimatingRig parms{};	
	parms.InAnimatingRig = InAnimatingRig;

	ProcessEvent(fn, &parms);
}

int32_t USkeletalMesh::NumSockets(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.NumSockets");

	FNumSockets parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<struct FString> USkeletalMesh::K2_GetAllMorphTargetNames(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.K2_GetAllMorphTargetNames");

	FK2_GetAllMorphTargetNames parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool USkeletalMesh::IsSectionUsingCloth(int32_t InSectionIndex, bool bCheckCorrespondingSections){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.IsSectionUsingCloth");

	FIsSectionUsingCloth parms{};	
	parms.InSectionIndex = InSectionIndex;
	parms.bCheckCorrespondingSections = bCheckCorrespondingSections;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct USkeletalMeshSocket* USkeletalMesh::GetSocketByIndex(int32_t Index){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.GetSocketByIndex");

	FGetSocketByIndex parms{};	
	parms.Index = Index;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct USkeleton* USkeletalMesh::GetSkeleton(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.GetSkeleton");

	FGetSkeleton parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UPhysicsAsset* USkeletalMesh::GetShadowPhysicsAsset(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.GetShadowPhysicsAsset");

	FGetShadowPhysicsAsset parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UPhysicsAsset* USkeletalMesh::GetPhysicsAsset(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.GetPhysicsAsset");

	FGetPhysicsAsset parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<struct UNodeMappingContainer*> USkeletalMesh::GetNodeMappingData(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.GetNodeMappingData");

	FGetNodeMappingData parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UNodeMappingContainer* USkeletalMesh::GetNodeMappingContainer(struct UBlueprint* SourceAsset){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.GetNodeMappingContainer");

	FGetNodeMappingContainer parms{};	
	parms.SourceAsset = SourceAsset;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<struct UMorphTarget*> USkeletalMesh::GetMorphTargetsPtrConv(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.GetMorphTargetsPtrConv");

	FGetMorphTargetsPtrConv parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void USkeletalMesh::GetMinLODForQualityLevels(struct TMap<uint8_t, int32_t>& QualityLevelMinimumLODs, int32_t& Default){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.GetMinLODForQualityLevels");

	FGetMinLODForQualityLevels parms{};	
	parms.QualityLevelMinimumLODs = QualityLevelMinimumLODs;
	parms.Default = Default;

	ProcessEvent(fn, &parms);
}

struct TArray<struct UClothingAssetBase*> USkeletalMesh::GetMeshClothingAssets(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.GetMeshClothingAssets");

	FGetMeshClothingAssets parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TArray<struct FSkeletalMaterial> USkeletalMesh::GetMaterials(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.GetMaterials");

	FGetMaterials parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct USkeletalMeshLODSettings* USkeletalMesh::GetLODSettings(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.GetLODSettings");

	FGetLODSettings parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FBoxSphereBounds USkeletalMesh::GetImportedBounds(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.GetImportedBounds");

	FGetImportedBounds parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TSoftObjectPtr<UObject> USkeletalMesh::GetDefaultAnimatingRig(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.GetDefaultAnimatingRig");

	FGetDefaultAnimatingRig parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FBoxSphereBounds USkeletalMesh::GetBounds(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.GetBounds");

	FGetBounds parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct USkeletalMeshSocket* USkeletalMesh::FindSocketAndIndex(struct FName InSocketName, int32_t& OutIndex){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.FindSocketAndIndex");

	FFindSocketAndIndex parms{};	
	parms.InSocketName = InSocketName;
	parms.OutIndex = OutIndex;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t URuntimeVirtualTexture::GetTileSize(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.RuntimeVirtualTexture.GetTileSize");

	FGetTileSize parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t URuntimeVirtualTexture::GetTileCount(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.RuntimeVirtualTexture.GetTileCount");

	FGetTileCount parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t URuntimeVirtualTexture::GetTileBorderSize(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.RuntimeVirtualTexture.GetTileBorderSize");

	FGetTileBorderSize parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t URuntimeVirtualTexture::GetSize(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.RuntimeVirtualTexture.GetSize");

	FGetSize parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

int32_t URuntimeVirtualTexture::GetPageTableSize(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.RuntimeVirtualTexture.GetPageTableSize");

	FGetPageTableSize parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UStereoLayerFunctionLibrary::ShowSplashScreen(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StereoLayerFunctionLibrary.ShowSplashScreen");

	FShowSplashScreen parms{};	

	ProcessEvent(fn, &parms);
}

void UStereoLayerFunctionLibrary::SetSplashScreen(struct UTexture* Texture, struct FVector2D Scale, struct FVector Offset, bool bShowLoadingMovie, bool bShowOnSet){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StereoLayerFunctionLibrary.SetSplashScreen");

	FSetSplashScreen parms{};	
	parms.Texture = Texture;
	parms.Scale = Scale;
	parms.Offset = Offset;
	parms.bShowLoadingMovie = bShowLoadingMovie;
	parms.bShowOnSet = bShowOnSet;

	ProcessEvent(fn, &parms);
}

void UStereoLayerFunctionLibrary::HideSplashScreen(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StereoLayerFunctionLibrary.HideSplashScreen");

	FHideSplashScreen parms{};	

	ProcessEvent(fn, &parms);
}

void UStereoLayerFunctionLibrary::EnableAutoLoadingSplashScreen(bool InAutoShowEnabled){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.StereoLayerFunctionLibrary.EnableAutoLoadingSplashScreen");

	FEnableAutoLoadingSplashScreen parms{};	
	parms.InAutoShowEnabled = InAutoShowEnabled;

	ProcessEvent(fn, &parms);
}

void UVOIPStatics::SetMicThreshold(float InThreshold){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.VOIPStatics.SetMicThreshold");

	FSetMicThreshold parms{};	
	parms.InThreshold = InThreshold;

	ProcessEvent(fn, &parms);
}

void UWorldPartitionBlueprintLibrary::UnloadActors(struct TArray<struct FGuid>& InActorsToLoad){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.WorldPartitionBlueprintLibrary.UnloadActors");

	FUnloadActors parms{};	
	parms.InActorsToLoad = InActorsToLoad;

	ProcessEvent(fn, &parms);
}

void UWorldPartitionBlueprintLibrary::LoadActors(struct TArray<struct FGuid>& InActorsToLoad){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.WorldPartitionBlueprintLibrary.LoadActors");

	FLoadActors parms{};	
	parms.InActorsToLoad = InActorsToLoad;

	ProcessEvent(fn, &parms);
}

struct FBox UWorldPartitionBlueprintLibrary::GetRuntimeWorldBounds(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.WorldPartitionBlueprintLibrary.GetRuntimeWorldBounds");

	FGetRuntimeWorldBounds parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UWorldPartitionBlueprintLibrary::GetIntersectingActorDescs(struct FBox& InBox, struct TArray<struct FActorDesc>& OutActorDescs){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.WorldPartitionBlueprintLibrary.GetIntersectingActorDescs");

	FGetIntersectingActorDescs parms{};	
	parms.InBox = InBox;
	parms.OutActorDescs = OutActorDescs;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FBox UWorldPartitionBlueprintLibrary::GetEditorWorldBounds(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.WorldPartitionBlueprintLibrary.GetEditorWorldBounds");

	FGetEditorWorldBounds parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UWorldPartitionBlueprintLibrary::GetActorDescs(struct TArray<struct FActorDesc>& OutActorDescs){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.WorldPartitionBlueprintLibrary.GetActorDescs");

	FGetActorDescs parms{};	
	parms.OutActorDescs = OutActorDescs;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void AWorldDataLayers::OnRep_LoadedDataLayerNames(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.WorldDataLayers.OnRep_LoadedDataLayerNames");

	FOnRep_LoadedDataLayerNames parms{};	

	ProcessEvent(fn, &parms);
}

void AWorldDataLayers::OnRep_EffectiveLoadedDataLayerNames(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.WorldDataLayers.OnRep_EffectiveLoadedDataLayerNames");

	FOnRep_EffectiveLoadedDataLayerNames parms{};	

	ProcessEvent(fn, &parms);
}

void AWorldDataLayers::OnRep_EffectiveActiveDataLayerNames(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.WorldDataLayers.OnRep_EffectiveActiveDataLayerNames");

	FOnRep_EffectiveActiveDataLayerNames parms{};	

	ProcessEvent(fn, &parms);
}

void AWorldDataLayers::OnRep_ActiveDataLayerNames(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.WorldDataLayers.OnRep_ActiveDataLayerNames");

	FOnRep_ActiveDataLayerNames parms{};	

	ProcessEvent(fn, &parms);
}

void AWorldDataLayers::OnDataLayerRuntimeStateChanged(struct UDataLayerInstance* InDataLayer, uint8_t InState){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.WorldDataLayers.OnDataLayerRuntimeStateChanged");

	FOnDataLayerRuntimeStateChanged parms{};	
	parms.InDataLayer = InDataLayer;
	parms.InState = InState;

	ProcessEvent(fn, &parms);
}

bool UDataLayer::IsVisible(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataLayer.IsVisible");

	FIsVisible parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UDataLayer::IsRuntime(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataLayer.IsRuntime");

	FIsRuntime parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UDataLayer::IsInitiallyVisible(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataLayer.IsInitiallyVisible");

	FIsInitiallyVisible parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UDataLayer::IsInitiallyActive(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataLayer.IsInitiallyActive");

	FIsInitiallyActive parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UDataLayer::IsEffectiveVisible(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataLayer.IsEffectiveVisible");

	FIsEffectiveVisible parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UDataLayer::IsDynamicallyLoaded(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataLayer.IsDynamicallyLoaded");

	FIsDynamicallyLoaded parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

uint8_t UDataLayer::GetInitialState(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataLayer.GetInitialState");

	FGetInitialState parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

uint8_t UDataLayer::GetInitialRuntimeState(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataLayer.GetInitialRuntimeState");

	FGetInitialRuntimeState parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FColor UDataLayer::GetDebugColor(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataLayer.GetDebugColor");

	FGetDebugColor parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FName UDataLayer::GetDataLayerLabel(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataLayer.GetDataLayerLabel");

	FGetDataLayerLabel parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UDataLayer::Equals(struct FActorDataLayer& ActorDataLayer){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataLayer.Equals");

	FEquals parms{};	
	parms.ActorDataLayer = ActorDataLayer;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UDataLayerAsset::IsRuntime(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataLayerAsset.IsRuntime");

	FIsRuntime parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

uint8_t UDataLayerAsset::GetType(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataLayerAsset.GetType");

	FGetType parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct FColor UDataLayerAsset::GetDebugColor(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataLayerAsset.GetDebugColor");

	FGetDebugColor parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UDataLayerSubsystem::SetDataLayerStateByLabel(struct FName& InDataLayerLabel, uint8_t InState){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataLayerSubsystem.SetDataLayerStateByLabel");

	FSetDataLayerStateByLabel parms{};	
	parms.InDataLayerLabel = InDataLayerLabel;
	parms.InState = InState;

	ProcessEvent(fn, &parms);
}

void UDataLayerSubsystem::SetDataLayerState(struct FActorDataLayer& InDataLayer, uint8_t InState){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataLayerSubsystem.SetDataLayerState");

	FSetDataLayerState parms{};	
	parms.InDataLayer = InDataLayer;
	parms.InState = InState;

	ProcessEvent(fn, &parms);
}

void UDataLayerSubsystem::SetDataLayerRuntimeStateByLabel(struct FName& InDataLayerLabel, uint8_t InState, bool bInIsRecursive){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataLayerSubsystem.SetDataLayerRuntimeStateByLabel");

	FSetDataLayerRuntimeStateByLabel parms{};	
	parms.InDataLayerLabel = InDataLayerLabel;
	parms.InState = InState;
	parms.bInIsRecursive = bInIsRecursive;

	ProcessEvent(fn, &parms);
}

void UDataLayerSubsystem::SetDataLayerRuntimeState(struct FActorDataLayer& InDataLayer, uint8_t InState, bool bInIsRecursive){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataLayerSubsystem.SetDataLayerRuntimeState");

	FSetDataLayerRuntimeState parms{};	
	parms.InDataLayer = InDataLayer;
	parms.InState = InState;
	parms.bInIsRecursive = bInIsRecursive;

	ProcessEvent(fn, &parms);
}

void UDataLayerSubsystem::SetDataLayerInstanceRuntimeState(struct UDataLayerAsset* InDataLayerAsset, uint8_t InState, bool bInIsRecursive){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataLayerSubsystem.SetDataLayerInstanceRuntimeState");

	FSetDataLayerInstanceRuntimeState parms{};	
	parms.InDataLayerAsset = InDataLayerAsset;
	parms.InState = InState;
	parms.bInIsRecursive = bInIsRecursive;

	ProcessEvent(fn, &parms);
}

struct TSet<struct FName> UDataLayerSubsystem::GetLoadedDataLayerNames(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataLayerSubsystem.GetLoadedDataLayerNames");

	FGetLoadedDataLayerNames parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

uint8_t UDataLayerSubsystem::GetDataLayerStateByLabel(struct FName& InDataLayerLabel){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataLayerSubsystem.GetDataLayerStateByLabel");

	FGetDataLayerStateByLabel parms{};	
	parms.InDataLayerLabel = InDataLayerLabel;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

uint8_t UDataLayerSubsystem::GetDataLayerState(struct FActorDataLayer& InDataLayer){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataLayerSubsystem.GetDataLayerState");

	FGetDataLayerState parms{};	
	parms.InDataLayer = InDataLayer;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

uint8_t UDataLayerSubsystem::GetDataLayerRuntimeStateByLabel(struct FName& InDataLayerLabel){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataLayerSubsystem.GetDataLayerRuntimeStateByLabel");

	FGetDataLayerRuntimeStateByLabel parms{};	
	parms.InDataLayerLabel = InDataLayerLabel;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

uint8_t UDataLayerSubsystem::GetDataLayerRuntimeState(struct FActorDataLayer& InDataLayer){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataLayerSubsystem.GetDataLayerRuntimeState");

	FGetDataLayerRuntimeState parms{};	
	parms.InDataLayer = InDataLayer;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

uint8_t UDataLayerSubsystem::GetDataLayerInstanceRuntimeState(struct UDataLayerAsset* InDataLayerAsset){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataLayerSubsystem.GetDataLayerInstanceRuntimeState");

	FGetDataLayerInstanceRuntimeState parms{};	
	parms.InDataLayerAsset = InDataLayerAsset;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UDataLayerInstance* UDataLayerSubsystem::GetDataLayerInstanceFromAsset(struct UDataLayerAsset* InDataLayerAsset){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataLayerSubsystem.GetDataLayerInstanceFromAsset");

	FGetDataLayerInstanceFromAsset parms{};	
	parms.InDataLayerAsset = InDataLayerAsset;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

uint8_t UDataLayerSubsystem::GetDataLayerInstanceEffectiveRuntimeState(struct UDataLayerAsset* InDataLayerAsset){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataLayerSubsystem.GetDataLayerInstanceEffectiveRuntimeState");

	FGetDataLayerInstanceEffectiveRuntimeState parms{};	
	parms.InDataLayerAsset = InDataLayerAsset;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UDataLayerInstance* UDataLayerSubsystem::GetDataLayerFromName(struct FName InDataLayerName){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataLayerSubsystem.GetDataLayerFromName");

	FGetDataLayerFromName parms{};	
	parms.InDataLayerName = InDataLayerName;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UDataLayerInstance* UDataLayerSubsystem::GetDataLayerFromLabel(struct FName InDataLayerLabel){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataLayerSubsystem.GetDataLayerFromLabel");

	FGetDataLayerFromLabel parms{};	
	parms.InDataLayerLabel = InDataLayerLabel;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

uint8_t UDataLayerSubsystem::GetDataLayerEffectiveRuntimeStateByLabel(struct FName& InDataLayerLabel){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataLayerSubsystem.GetDataLayerEffectiveRuntimeStateByLabel");

	FGetDataLayerEffectiveRuntimeStateByLabel parms{};	
	parms.InDataLayerLabel = InDataLayerLabel;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

uint8_t UDataLayerSubsystem::GetDataLayerEffectiveRuntimeState(struct FActorDataLayer& InDataLayer){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataLayerSubsystem.GetDataLayerEffectiveRuntimeState");

	FGetDataLayerEffectiveRuntimeState parms{};	
	parms.InDataLayer = InDataLayer;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct UDataLayerInstance* UDataLayerSubsystem::GetDataLayer(struct FActorDataLayer& InDataLayer){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataLayerSubsystem.GetDataLayer");

	FGetDataLayer parms{};	
	parms.InDataLayer = InDataLayer;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

struct TSet<struct FName> UDataLayerSubsystem::GetActiveDataLayerNames(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.DataLayerSubsystem.GetActiveDataLayerNames");

	FGetActiveDataLayerNames parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

void UWorldPartitionRuntimeLevelStreamingCell::OnLevelShown(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.WorldPartitionRuntimeLevelStreamingCell.OnLevelShown");

	FOnLevelShown parms{};	

	ProcessEvent(fn, &parms);
}

void UWorldPartitionRuntimeLevelStreamingCell::OnLevelHidden(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.WorldPartitionRuntimeLevelStreamingCell.OnLevelHidden");

	FOnLevelHidden parms{};	

	ProcessEvent(fn, &parms);
}

bool UWorldPartitionSubsystem::IsStreamingCompleted(uint8_t QueryState, struct TArray<struct FWorldPartitionStreamingQuerySource>& QuerySources, bool bExactState){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.WorldPartitionSubsystem.IsStreamingCompleted");

	FIsStreamingCompleted parms{};	
	parms.QueryState = QueryState;
	parms.QuerySources = QuerySources;
	parms.bExactState = bExactState;

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

bool UWorldPartitionSubsystem::IsAllStreamingCompleted(){

	static UFunction* fn = 0;
 	if(!fn)
		fn = (UFunction*)UObject::FindObject<UFunction>("Function Engine.WorldPartitionSubsystem.IsAllStreamingCompleted");

	FIsAllStreamingCompleted parms{};	

	ProcessEvent(fn, &parms);

	return parms.return_value;
}

